SCRIPT  /Users/manny/.vimrc
Sourced 1 time
Total time:   0.044864
 Self time:   0.001076

count  total (s)   self (s)
                            
    1              0.000095 set nocompatible              " be iMproved, required
    1              0.000056 execute pathogen#infect()
    1              0.000003 let base16colorspace=256
    1              0.000065 syntax on
    1              0.000080 filetype plugin indent on
    1              0.000045 colorscheme base16-default
    1              0.000119 set background=dark
                            
    1              0.000007 set mouse=a
    1              0.000005 if has("mouse_sgr")
    1              0.000006     set ttymouse=sgr
    1              0.000001 else
                                set ttymouse=xterm2
                            end
                            
    1              0.000019 set laststatus=2
    1              0.000004 let g:airline_theme='base16'
                            "let g:airline_theme='badwolf'
    1              0.000002 let g:airline_powerline_fonts = 1
    1              0.000003 let g:airline#extensions#tabline#enabled = 1
    1              0.000002 let g:airline#extensions#tabline#formatter = 'unique_tail'
                            
    1              0.000004 if !exists('g:airline_symbols')
    1              0.000002   let g:airline_symbols = {}
    1              0.000001 endif
    1              0.000004 let g:airline_symbols.space = "\ua0"
                            
                            " Spaces & Tabs {{{
    1              0.000002 set tabstop=2           " 2 space tab
                            "set expandtab           " use spaces for tabs
    1              0.000002 set softtabstop=2       " 2 space tab
    1              0.000002 set shiftwidth=2
    1              0.000002 set modelines=1
    1              0.000003 set autoindent
                            " }}}
                            
                            " UI Layout {{{
    1              0.000002 set number              " show line numbers
    1              0.000002 set showcmd             " show command in bottom bar
    1              0.000002 set cursorline
                            "hi CursorLine term=bold cterm=bold guibg=Black30
    1              0.000001 set wildmenu
                            "set lazyredraw
    1              0.000001 set showmatch           " higlight matching parenthesis
                            " }}}
                            
                            " Folding {{{
                            "=== folding ===
    1              0.000004 set foldmethod=indent   " fold based on indent level
    1              0.000002 set foldnestmax=10      " max 10 depth
    1              0.000002 set foldenable          " don't fold files by default on open
    1              0.000018 nnoremap <space> za
    1              0.000003 set foldlevelstart=10    " start with fold level of 1
                            " }}}
                            
                            " Syntastic {{{
    1              0.000003 let g:syntastic_python_flake8_args='--ignore=E501'
    1              0.000003 let g:syntastic_ignore_files = ['.java$']
    1              0.000003 set statusline+=%#warningmsg#
    1              0.000003 set statusline+=%{SyntasticStatuslineFlag()}
    1              0.000002 set statusline+=%*
                            
    1              0.000002 let g:syntastic_always_populate_loc_list = 1
    1              0.000002 let g:syntastic_auto_loc_list = 1
    1              0.000002 let g:syntastic_check_on_open = 1
    1              0.000002 let g:syntastic_check_on_wq = 0
                            " }}}
                            
                            " Searching {{{
    1              0.000001 set ignorecase          " ignore case when searching
    1              0.000002 set incsearch           " search as characters are entered
    1              0.000002 set hlsearch            " highlight all matches
                            " }}}
                            
                            " отключаем бэкапы и своп-файлы
    1              0.000002 set nobackup         " no backup files
    1              0.000001 set nowritebackup    " only in case you don't want a backup file while editing
    1              0.000005 set noswapfile       " no swap files
                            
    1              0.000009 set visualbell t_vb=
    1              0.000001 set novisualbell  
                            
                            
    1              0.000068 set enc=utf-8        " utf-8 по дефолту в файлах
    1              0.000003 set ls=2             " всегда показываем статусбар
    1              0.000002 set incsearch        " инкреминтируемый поиск
    1              0.000001 set hlsearch         " подсветка результатов поиска
    1              0.000003 set nu               " показывать номера строк
    1              0.000001 set scrolloff=5      " 5 строк при скролле за раз
                            
    1              0.000007 map <F1> :NERDTreeToggle<CR>
                            "игноррируемые файлы с расширениями
    1              0.000005 let NERDTreeIgnore=['\~$', '\.pyc$', '\.pyo$', '\.class$', 'pip-log\.txt$', '\.o$']  
                            
    1              0.000002 set backspace=indent,eol,start
    1              0.000023 aunmenu Help.
    1              0.000003 let no_buffers_menu=1
    1              0.000002 set mousemodel=popup
                            
                            " Pasting  without inditation
    1              0.000003 set pastetoggle=<C-D>
    1              0.000005 map <C-O> :!<Enter>
    1              0.000006 map <C-A> :%y+<Enter>

SCRIPT  /Users/manny/.vim/autoload/pathogen.vim
Sourced 1 time
Total time:   0.000419
 Self time:   0.000419

count  total (s)   self (s)
                            " pathogen.vim - path option manipulation
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      2.4
                            
                            " Install in ~/.vim/autoload (or ~\vimfiles\autoload).
                            "
                            " For management of individually installed plugins in ~/.vim/bundle (or
                            " ~\vimfiles\bundle), adding `execute pathogen#infect()` to the top of your
                            " .vimrc is the only other setup necessary.
                            "
                            " The API is documented inline below.
                            
    1              0.000015 if exists("g:loaded_pathogen") || &cp
                              finish
                            endif
    1              0.000006 let g:loaded_pathogen = 1
                            
                            " Point of entry for basic default usage.  Give a relative path to invoke
                            " pathogen#interpose() (defaults to "bundle/{}"), or an absolute path to invoke
                            " pathogen#surround().  Curly braces are expanded with pathogen#expand():
                            " "bundle/{}" finds all subdirectories inside "bundle" inside all directories
                            " in the runtime path.
    1              0.000004 function! pathogen#infect(...) abort
                              for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
                                if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
                                  call pathogen#surround(path)
                                elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#surround(path . '/{}')
                                elseif path =~# '[{}*]'
                                  call pathogen#interpose(path)
                                else
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#interpose(path . '/{}')
                                endif
                              endfor
                              call pathogen#cycle_filetype()
                              if pathogen#is_disabled($MYVIMRC)
                                return 'finish'
                              endif
                              return ''
                            endfunction
                            
                            " Split a path into a list.
    1              0.000003 function! pathogen#split(path) abort
                              if type(a:path) == type([]) | return a:path | endif
                              if empty(a:path) | return [] | endif
                              let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
                              return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')
                            endfunction
                            
                            " Convert a list to a path.
    1              0.000001 function! pathogen#join(...) abort
                              if type(a:1) == type(1) && a:1
                                let i = 1
                                let space = ' '
                              else
                                let i = 0
                                let space = ''
                              endif
                              let path = ""
                              while i < a:0
                                if type(a:000[i]) == type([])
                                  let list = a:000[i]
                                  let j = 0
                                  while j < len(list)
                                    let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
                                    let path .= ',' . escaped
                                    let j += 1
                                  endwhile
                                else
                                  let path .= "," . a:000[i]
                                endif
                                let i += 1
                              endwhile
                              return substitute(path,'^,','','')
                            endfunction
                            
                            " Convert a list to a path with escaped spaces for 'path', 'tag', etc.
    1              0.000002 function! pathogen#legacyjoin(...) abort
                              return call('pathogen#join',[1] + a:000)
                            endfunction
                            
                            " Turn filetype detection off and back on again if it was already enabled.
    1              0.000002 function! pathogen#cycle_filetype() abort
                              if exists('g:did_load_filetypes')
                                filetype off
                                filetype on
                              endif
                            endfunction
                            
                            " Check if a bundle is disabled.  A bundle is considered disabled if its
                            " basename or full name is included in the list g:pathogen_blacklist or the
                            " comma delimited environment variable $VIMBLACKLIST.
    1              0.000003 function! pathogen#is_disabled(path) abort
                              if a:path =~# '\~$'
                                return 1
                              endif
                              let sep = pathogen#slash()
                              let blacklist = map(
                                    \ get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) +
                                    \ pathogen#split($VIMBLACKLIST),
                                    \ 'substitute(v:val, "[\\/]$", "", "")')
                              return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
                            endfunction
                            
                            " Prepend the given directory to the runtime path and append its corresponding
                            " after directory.  Curly braces are expanded with pathogen#expand().
    1              0.000002 function! pathogen#surround(path) abort
                              let sep = pathogen#slash()
                              let rtp = pathogen#split(&rtp)
                              let path = fnamemodify(a:path, ':p:s?[\\/]\=$??')
                              let before = filter(pathogen#expand(path), '!pathogen#is_disabled(v:val)')
                              let after = filter(reverse(pathogen#expand(path, sep.'after')), '!pathogen#is_disabled(v:val[0:-7])')
                              call filter(rtp, 'index(before + after, v:val) == -1')
                              let &rtp = pathogen#join(before, rtp, after)
                              return &rtp
                            endfunction
                            
                            " For each directory in the runtime path, add a second entry with the given
                            " argument appended.  Curly braces are expanded with pathogen#expand().
    1              0.000003 function! pathogen#interpose(name) abort
                              let sep = pathogen#slash()
                              let name = a:name
                              if has_key(s:done_bundles, name)
                                return ""
                              endif
                              let s:done_bundles[name] = 1
                              let list = []
                              for dir in pathogen#split(&rtp)
                                if dir =~# '\<after$'
                                  let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
                                else
                                  let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
                                endif
                              endfor
                              let &rtp = pathogen#join(pathogen#uniq(list))
                              return 1
                            endfunction
                            
    1              0.000003 let s:done_bundles = {}
                            
                            " Invoke :helptags on all non-$VIM doc directories in runtimepath.
    1              0.000002 function! pathogen#helptags() abort
                              let sep = pathogen#slash()
                              for glob in pathogen#split(&rtp)
                                for dir in map(split(glob(glob), "\n"), 'v:val.sep."/doc/".sep')
                                  if (dir)[0 : strlen($VIMRUNTIME)] !=# $VIMRUNTIME.sep && filewritable(dir) == 2 && !empty(split(glob(dir.'*.txt'))) && (!filereadable(dir.'tags') || filewritable(dir.'tags'))
                                    silent! execute 'helptags' pathogen#fnameescape(dir)
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000008 command! -bar Helptags :call pathogen#helptags()
                            
                            " Execute the given command.  This is basically a backdoor for --remote-expr.
    1              0.000002 function! pathogen#execute(...) abort
                              for command in a:000
                                execute command
                              endfor
                              return ''
                            endfunction
                            
                            " Section: Unofficial
                            
    1              0.000003 function! pathogen#is_absolute(path) abort
                              return a:path =~# (has('win32') ? '^\%([\\/]\|\w:\)[\\/]\|^[~$]' : '^[/~$]')
                            endfunction
                            
                            " Given a string, returns all possible permutations of comma delimited braced
                            " alternatives of that string.  pathogen#expand('/{a,b}/{c,d}') yields
                            " ['/a/c', '/a/d', '/b/c', '/b/d'].  Empty braces are treated as a wildcard
                            " and globbed.  Actual globs are preserved.
    1              0.000002 function! pathogen#expand(pattern, ...) abort
                              let after = a:0 ? a:1 : ''
                              if a:pattern =~# '{[^{}]\+}'
                                let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
                                let found = map(split(pat, ',', 1), 'pre.v:val.post')
                                let results = []
                                for pattern in found
                                  call extend(results, pathogen#expand(pattern))
                                endfor
                              elseif a:pattern =~# '{}'
                                let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
                                let post = a:pattern[strlen(pat) : -1]
                                let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
                              else
                                let results = [a:pattern]
                              endif
                              let vf = pathogen#slash() . 'vimfiles'
                              call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
                              return filter(results, '!empty(v:val)')
                            endfunction
                            
                            " \ on Windows unless shellslash is set, / everywhere else.
    1              0.000002 function! pathogen#slash() abort
                              return !exists("+shellslash") || &shellslash ? '/' : '\'
                            endfunction
                            
    1              0.000002 function! pathogen#separator() abort
                              return pathogen#slash()
                            endfunction
                            
                            " Convenience wrapper around glob() which returns a list.
    1              0.000002 function! pathogen#glob(pattern) abort
                              let files = split(glob(a:pattern),"\n")
                              return map(files,'substitute(v:val,"[".pathogen#slash()."/]$","","")')
                            endfunction
                            
                            " Like pathogen#glob(), only limit the results to directories.
    1              0.000003 function! pathogen#glob_directories(pattern) abort
                              return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')
                            endfunction
                            
                            " Remove duplicates from a list.
    1              0.000002 function! pathogen#uniq(list) abort
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
                                  call remove(a:list,i)
                                elseif a:list[i] ==# ''
                                  let i += 1
                                  let empty = 1
                                else
                                  let seen[a:list[i]] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction
                            
                            " Backport of fnameescape().
    1              0.000002 function! pathogen#fnameescape(string) abort
                              if exists('*fnameescape')
                                return fnameescape(a:string)
                              elseif a:string ==# '-'
                                return '\-'
                              else
                                return substitute(escape(a:string," \t\n*?[{`$\\%#'\"|!<"),'^[+>]','\\&','')
                              endif
                            endfunction
                            
                            " Like findfile(), but hardcoded to use the runtimepath.
    1              0.000002 function! pathogen#runtime_findfile(file,count) abort
                              let rtp = pathogen#join(1,pathogen#split(&rtp))
                              let file = findfile(a:file,rtp,a:count)
                              if file ==# ''
                                return ''
                              else
                                return fnamemodify(file,':p')
                              endif
                            endfunction
                            
                            " Section: Deprecated
                            
    1              0.000003 function! s:warn(msg) abort
                              echohl WarningMsg
                              echomsg a:msg
                              echohl NONE
                            endfunction
                            
                            " Prepend all subdirectories of path to the rtp, and append all 'after'
                            " directories in those subdirectories.  Deprecated.
    1              0.000003 function! pathogen#runtime_prepend_subdirectories(path) abort
                              call s:warn('Change pathogen#runtime_prepend_subdirectories('.string(a:path).') to pathogen#infect('.string(a:path.'/{}').')')
                              return pathogen#surround(a:path . pathogen#slash() . '{}')
                            endfunction
                            
    1              0.000002 function! pathogen#incubate(...) abort
                              let name = a:0 ? a:1 : 'bundle/{}'
                              call s:warn('Change pathogen#incubate('.(a:0 ? string(a:1) : '').') to pathogen#infect('.string(name).')')
                              return pathogen#interpose(name)
                            endfunction
                            
                            " Deprecated alias for pathogen#interpose().
    1              0.000002 function! pathogen#runtime_append_all_bundles(...) abort
                              if a:0
                                call s:warn('Change pathogen#runtime_append_all_bundles('.string(a:1).') to pathogen#infect('.string(a:1.'/{}').')')
                              else
                                call s:warn('Change pathogen#runtime_append_all_bundles() to pathogen#infect()')
                              endif
                              return pathogen#interpose(a:0 ? a:1 . '/{}' : 'bundle/{}')
                            endfunction
                            
    1              0.000004 if exists(':Vedit')
                              finish
                            endif
                            
    1              0.000003 let s:vopen_warning = 0
                            
    1              0.000003 function! s:find(count,cmd,file,lcd)
                              let rtp = pathogen#join(1,pathogen#split(&runtimepath))
                              let file = pathogen#runtime_findfile(a:file,a:count)
                              if file ==# ''
                                return "echoerr 'E345: Can''t find file \"".a:file."\" in runtimepath'"
                              endif
                              if !s:vopen_warning
                                let s:vopen_warning = 1
                                let warning = '|echohl WarningMsg|echo "Install scriptease.vim to continue using :V'.a:cmd.'"|echohl NONE'
                              else
                                let warning = ''
                              endif
                              if a:lcd
                                let path = file[0:-strlen(a:file)-2]
                                execute 'lcd `=path`'
                                return a:cmd.' '.pathogen#fnameescape(a:file) . warning
                              else
                                return a:cmd.' '.pathogen#fnameescape(file) . warning
                              endif
                            endfunction
                            
    1              0.000003 function! s:Findcomplete(A,L,P)
                              let sep = pathogen#slash()
                              let cheats = {
                                    \'a': 'autoload',
                                    \'d': 'doc',
                                    \'f': 'ftplugin',
                                    \'i': 'indent',
                                    \'p': 'plugin',
                                    \'s': 'syntax'}
                              if a:A =~# '^\w[\\/]' && has_key(cheats,a:A[0])
                                let request = cheats[a:A[0]].a:A[1:-1]
                              else
                                let request = a:A
                              endif
                              let pattern = substitute(request,'/\|\'.sep,'*'.sep,'g').'*'
                              let found = {}
                              for path in pathogen#split(&runtimepath)
                                let path = expand(path, ':p')
                                let matches = split(glob(path.sep.pattern),"\n")
                                call map(matches,'isdirectory(v:val) ? v:val.sep : v:val')
                                call map(matches,'expand(v:val, ":p")[strlen(path)+1:-1]')
                                for match in matches
                                  let found[match] = 1
                                endfor
                              endfor
                              return sort(keys(found))
                            endfunction
                            
    1              0.000016 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Ve       :execute s:find(<count>,'edit<bang>',<q-args>,0)
    1              0.000011 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vedit    :execute s:find(<count>,'edit<bang>',<q-args>,0)
    1              0.000011 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vopen    :execute s:find(<count>,'edit<bang>',<q-args>,1)
    1              0.000011 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vsplit   :execute s:find(<count>,'split',<q-args>,<bang>1)
    1              0.000010 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vvsplit  :execute s:find(<count>,'vsplit',<q-args>,<bang>1)
    1              0.000011 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vtabedit :execute s:find(<count>,'tabedit',<q-args>,<bang>1)
    1              0.000011 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vpedit   :execute s:find(<count>,'pedit',<q-args>,<bang>1)
    1              0.000010 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vread    :execute s:find(<count>,'read',<q-args>,<bang>1)
                            
                            " vim:set et sw=2 foldmethod=expr foldexpr=getline(v\:lnum)=~'^\"\ Section\:'?'>1'\:getline(v\:lnum)=~#'^fu'?'a1'\:getline(v\:lnum)=~#'^endf'?'s1'\:'=':

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/syntax/syntax.vim
Sourced 1 time
Total time:   0.024588
 Self time:   0.000253

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000005 if !has("syntax")
                              finish
                            endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000004 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
                            endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1              0.000080 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000003 if exists("did_load_filetypes")
                              let s:did_ft = 1
                            else
    1              0.000084   filetype on
    1              0.000004   let s:did_ft = 0
    1              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    1              0.000001 augroup syntaxset
    1              0.000006   au! FileType *	exe "set syntax=" . expand("<amatch>")
    1              0.000001 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1              0.000002 doautoall syntaxset FileType
    1              0.000002 if !s:did_ft
    1              0.000001   doautoall filetypedetect BufRead
    1              0.000003 endif

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/syntax/synload.vim
Sourced 1 time
Total time:   0.000499
 Self time:   0.000238

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2012 Sep 25
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000005 if !has("syntax")
                              finish
                            endif
                            
                            " let others know that syntax has been switched on
    1              0.000002 let syntax_on = 1
                            
                            " Set the default highlighting colors.  Use a color scheme if specified.
    1              0.000003 if exists("colors_name")
                              exe "colors " . colors_name
                            else
    1              0.000076   runtime! syntax/syncolor.vim
    1              0.000001 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000005 let s:cpo_save = &cpo
    1              0.000014 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000007 au! Syntax
                            
    1              0.000006 au Syntax *		call s:SynSet()
                            
    1              0.000004 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
                                for name in split(s, '\.')
                                  exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000022 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000005 if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
                              execute "source " . mysyntaxfile
                            endif
                            
                            " Restore 'cpoptions'
    1              0.000005 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/syntax/syncolor.vim
Sourced 5 times
Total time:   0.001104
 Self time:   0.001104

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    5              0.000032 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    3              0.000026   command -nargs=* SynColor hi <args>
    3              0.000020   command -nargs=* SynLink hi link <args>
    3              0.000003 else
    2              0.000004   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
                                command -nargs=* SynColor hi def <args>
                                command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    2              0.000014     command -nargs=* SynColor hi <args>
    2              0.000012     command -nargs=* SynLink hi! link <args>
    2              0.000003   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    2              0.000002 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    5              0.000011 if &background == "dark"
    5              0.000052   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    5              0.000043   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    5              0.000041   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    5              0.000034   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    5              0.000035   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    5              0.000039   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    5              0.000029   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    5              0.000028   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    5              0.000030   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    5              0.000005 else
                              SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
                              SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            endif
    5              0.000035 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    5              0.000034 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    5              0.000018 SynLink String		Constant
    5              0.000017 SynLink Character	Constant
    5              0.000017 SynLink Number		Constant
    5              0.000013 SynLink Boolean		Constant
    5              0.000015 SynLink Float		Number
    5              0.000016 SynLink Function	Identifier
    5              0.000017 SynLink Conditional	Statement
    5              0.000014 SynLink Repeat		Statement
    5              0.000017 SynLink Label		Statement
    5              0.000015 SynLink Operator	Statement
    5              0.000013 SynLink Keyword		Statement
    5              0.000017 SynLink Exception	Statement
    5              0.000015 SynLink Include		PreProc
    5              0.000015 SynLink Define		PreProc
    5              0.000015 SynLink Macro		PreProc
    5              0.000014 SynLink PreCondit	PreProc
    5              0.000016 SynLink StorageClass	Type
    5              0.000015 SynLink Structure	Type
    5              0.000013 SynLink Typedef		Type
    5              0.000018 SynLink Tag		Special
    5              0.000015 SynLink SpecialChar	Special
    5              0.000013 SynLink Delimiter	Special
    5              0.000016 SynLink SpecialComment	Special
    5              0.000015 SynLink Debug		Special
                            
    5              0.000005 delcommand SynColor
    5              0.000017 delcommand SynLink

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/filetype.vim
Sourced 2 times
Total time:   0.023821
 Self time:   0.023741

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Apr 29
                            
                            " Listen very carefully, I will say this only once
    2              0.000009 if exists("did_load_filetypes")
    1              0.000002   finish
                            endif
    1              0.000003 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000004 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000002 augroup filetypedetect
                            
                            " Ignored extensions
    1              0.000004 if exists("*fnameescape")
    1              0.000067 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    1              0.000012 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    1              0.000009 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
    1              0.000002 elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    1              0.000003 if !exists("g:ft_ignore_pat")
    1              0.000002   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000000 endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    1              0.000003 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Abaqus or Trasys
    1              0.000006 au BufNewFile,BufRead *.inp			call s:Check_inp()
                            
    1              0.000002 func! s:Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " A-A-P recipe
    1              0.000006 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    1              0.000024 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    1              0.000005 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    1              0.000005 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    1              0.000005 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    1              0.000007 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    1              0.000011 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    1              0.000004 if has("vms")
                              au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
                            else
    1              0.000007   au BufNewFile,BufRead *.gpr			setf ada
    1              0.000001 endif
                            
                            " AHDL
    1              0.000006 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    1              0.000005 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    1              0.000008 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
    1              0.000008 au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache style config file
    1              0.000009 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    1              0.000015 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    1              0.000008 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    1              0.000006 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    1              0.000006 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    1              0.000021 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    1              0.000006 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    1              0.000008 au BufNewFile,BufRead apt.conf		       setf aptconf
    1              0.000008 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    1              0.000043 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    1              0.000013 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    1              0.000008 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    1              0.000011 au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
    1              0.000011 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    1              0.000007 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    1              0.000012 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    1              0.000021 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    1              0.000022 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    1              0.000002 func! s:FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call s:FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    1              0.000002 func! s:FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Macro (VAX)
    1              0.000009 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    1              0.000009 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    1              0.000006 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    1              0.000008 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    1              0.000015 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    1              0.000006 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    1              0.000006 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    1              0.000005 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    1              0.000015 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    1              0.000006 au BufNewFile,BufRead *.bas			call s:FTVB("basic")
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    1              0.000003 func! s:FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    1              0.000019 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    1              0.000009 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    1              0.000011 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    1              0.000010 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    1              0.000007 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    1              0.000008 au BufNewFile,BufRead *.btm			call s:FTbtm()
    1              0.000003 func! s:FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
                            " BC calculator
    1              0.000006 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    1              0.000006 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    1              0.000005 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    1              0.000008 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
    1              0.000014 au BufNewFile,BufRead named.conf,rndc.conf	setf named
                            
                            " BIND zone
    1              0.000008 au BufNewFile,BufRead named.root		setf bindzone
    1              0.000006 au BufNewFile,BufRead *.db			call s:BindzoneCheck('')
                            
    1              0.000002 func! s:BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            " Blank
    1              0.000008 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    1              0.000017 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " Bazel (http://bazel.io)
    1              0.000018 autocmd BufRead,BufNewFile *.bzl,BUILD,WORKSPACE setfiletype bzl
                            
                            " C or lpc
    1              0.000007 au BufNewFile,BufRead *.c			call s:FTlpc()
                            
    1              0.000002 func! s:FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
                            " Calendar
    1              0.000007 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    1              0.000006 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    1              0.000009 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    1              0.000007 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    1              0.000006 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    1              0.000030 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    1              0.000008 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    1              0.000009 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    1              0.000007 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    1              0.000007 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    1              0.000005 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    1              0.000019 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    1              0.000008 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    1              0.000008 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    1              0.000057 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    1              0.000006 if has("fname_case")
                              au BufNewFile,BufRead *.C,*.H setf cpp
                            endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    1              0.000007 au BufNewFile,BufRead *.h			call s:FTheader()
                            
    1              0.000002 func! s:FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " Ch (CHscript)
    1              0.000008 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    1              0.000007 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    1              0.000010 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    1              0.000007 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    1              0.000032 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    1              0.000013 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    1              0.000021 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    1              0.000016 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    1              0.000007 au BufNewFile,BufRead *.ch			call s:FTchange()
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" ir "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    1              0.000002 func! s:FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
                            " ChordPro
    1              0.000034 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    1              0.000013 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    1              0.000010 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    1              0.000007 au BufNewFile,BufRead *.ent			call s:FTent()
                            
    1              0.000002 func! s:FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
                            " Clipper (or FoxPro; could also be eviews)
    1              0.000011 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    1              0.000026 au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
    1              0.000022 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    1              0.000028 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    1              0.000011 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    1              0.000023 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    1              0.000010 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    1              0.000011 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    1              0.000017 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    1              0.000018 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    1              0.000010 au BufNewFile,BufRead *.cu			setf cuda
                            
                            " Dockerfile
    1              0.000010 au BufNewFile,BufRead Dockerfile		setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
    1              0.000008 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    1              0.000011 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    1              0.000012 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Euphoria 3 or 4
    1              0.000031 au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
    1              0.000005 if has("fname_case")
                               au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
                            endif
                            
    1              0.000002 func! s:EuphoriaCheck()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                setf euphoria3
                              endif
                            endfunc
                            
                            " Lynx config files
    1              0.000010 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    1              0.000021 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    1              0.000013 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    1              0.000008 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    1              0.000009 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    1              0.000011 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    1              0.000013 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    1              0.000008 au BufNewFile,BufRead *.pld			setf cupl
    1              0.000011 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    1              0.000010 au BufNewFile,BufRead */debian/control		setf debcontrol
    1              0.000013 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
    1              0.000011 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    1              0.000015 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    1              0.000010 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    1              0.000014 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    1              0.000011 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    1              0.000008 au BufNewFile,BufRead *.d			call s:DtraceCheck()
                            
    1              0.000002 func! s:DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
                            " Desktop files
    1              0.000020 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    1              0.000018 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    1              0.000010 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    1              0.000022 au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff
                            
                            " Dircolors
    1              0.000027 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    1              0.000014 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    1              0.000010 au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')
                            
                            " DOT
    1              0.000008 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    1              0.000011 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    1              0.000008 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    1              0.000009 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    1              0.000008 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    1              0.000028 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    1              0.000011 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    1              0.000009 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    1              0.000008 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    1              0.000017 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo)
    1              0.000011 au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif
                            
                            " Embedix Component Description
    1              0.000009 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
    1              0.000016 au BufNewFile,BufRead *.e,*.E			call s:FTe()
                            
                            " Elinks configuration
    1              0.000022 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
    1              0.000002 func! s:FTe()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                let n = 1
                                while n < 100 && n < line("$")
                                  if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                                    setf specman
                                    return
                                  endif
                                  let n = n + 1
                                endwhile
                                setf eiffel
                              endif
                            endfunc
                            
                            " ERicsson LANGuage; Yaws is erlang too
    1              0.000024 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    1              0.000014 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    1              0.000010 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    1              0.000017 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    1              0.000010 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    1              0.000009 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    1              0.000012 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    1              0.000010 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    1              0.000009 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    1              0.000009 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    1              0.000018 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    1              0.000009 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    1              0.000013 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    1              0.000017 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    1              0.000013 au BufNewFile,BufRead auto.master		setf conf
    1              0.000016 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    1              0.000018 au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
    1              0.000009 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    1              0.000005 if has("fname_case")
                              au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
                            endif
    1              0.000075 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    1              0.000011 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    1              0.000017 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    1              0.000013 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    1              0.000017 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    1              0.000021 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    1              0.000014 au BufNewFile,BufRead COMMIT_EDITMSG		setf gitcommit
    1              0.000012 au BufNewFile,BufRead MERGE_MSG			setf gitcommit
    1              0.000027 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    1              0.000014 au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
    1              0.000014 au BufNewFile,BufRead */.config/git/config	setf gitconfig
    1              0.000005 if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config	setf gitconfig
                            endif
    1              0.000013 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    1              0.000016 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    1              0.000012 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    1              0.000023 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    1              0.000019 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    1              0.000014 au BufNewFile,BufRead */.gnupg/options		setf gpg
    1              0.000016 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    1              0.000014 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
                            
                            " gnash(1) configuration files
    1              0.000040 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    1              0.000011 au BufNewFile,BufRead gitolite.conf		setf gitolite
    1              0.000015 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    1              0.000022 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    1              0.000011 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
    1              0.000013 au BufNewFile,BufRead *.go			setf go
                            
                            " GrADS scripts
    1              0.000010 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    1              0.000010 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    1              0.000020 au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
    1              0.000010 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    1              0.000082 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    1              0.000020 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    1              0.000013 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    1              0.000019 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    1              0.000021 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    1              0.000011 au BufNewFile,BufRead *.lhs			setf lhaskell
    1              0.000011 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    1              0.000013 au BufNewFile,BufRead *.ht			setf haste
    1              0.000012 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    1              0.000043 au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    1              0.000022 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    1              0.000014 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    1              0.000036 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
                            
                            " Distinguish between HTML, XHTML and Django
    1              0.000003 func! s:FThtml()
                              let n = 1
                              while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\|load\)\>\|{#\s\+'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf html
                            endfunc
                            
                            " HTML with Ruby - eRuby
    1              0.000023 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    1              0.000012 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    1              0.000011 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    1              0.000017 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    1              0.000025 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    1              0.000011 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    1              0.000022 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    1              0.000012 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    1              0.000010 au BufNewFile,BufRead *.idl			call s:FTidl()
                            
                            " Distinguish between standard IDL and MS-IDL
    1              0.000003 func! s:FTidl()
                              let n = 1
                              while n < 50 && n < line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    1              0.000022 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    1              0.000013 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    1              0.000014 au BufNewFile,BufRead .indent.pro		setf indent
    1              0.000012 au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    1              0.000011 au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')
                            
                            " Distinguish between "default" and Cproto prototype file. */
    1              0.000003 func! s:ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            
                            " Indent RC
    1              0.000013 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    1              0.000020 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    1              0.000025 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    1              0.000040 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
    1              0.000035 au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c 	setf upstreamlog
    1              0.000036 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    1              0.000038 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
    1              0.000036 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
    1              0.000033 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    1              0.000033 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    1              0.000012 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    1              0.000015 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    1              0.000011 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    1              0.000010 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    1              0.000023 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    1              0.000020 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    1              0.000024 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    1              0.000022 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    1              0.000042 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript
                            
                            " Java Server Pages
    1              0.000016 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000037 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    1              0.000016 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    1              0.000014 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    1              0.000012 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    1              0.000032 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
    1              0.000024 au BufNewFile,BufRead *.json,*.jsonp		setf json
                            
                            " Kixtart
    1              0.000013 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    1              0.000011 au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
    1              0.000011 au BufNewFile,BufRead *.kv			setf kivy
                            
                            " KDE script
    1              0.000014 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    1              0.000024 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    1              0.000026 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    1              0.000022 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    1              0.000042 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    1              0.000014 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    1              0.000013 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    1              0.000011 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
    1              0.000014 au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
    1              0.000041 au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
    1              0.000029 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    1              0.000031 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    1              0.000034 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    1              0.000016 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    1              0.000014 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    1              0.000004 if has("fname_case")
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
                            else
    1              0.000079   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
    1              0.000002 endif
                            
                            " SBCL implementation of Common Lisp
    1              0.000026 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    1              0.000023 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    1              0.000021 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    1              0.000017 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    1              0.000019 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    1              0.000014 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    1              0.000014 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    1              0.000025 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    1              0.000021 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    1              0.000015 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
    1              0.000014 au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
    1              0.000012 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    1              0.000015 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    1              0.000015 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    1              0.000015 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn)
    1              0.000146 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    1              0.000029 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    1              0.000026 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    1              0.000048 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    1              0.000024 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    1              0.000016 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    1              0.000013 au BufNewFile,BufRead *.man			setf man
                            
                            " Man config
    1              0.000027 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    1              0.000035 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    1              0.000014 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    1              0.000068 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
    1              0.000034 au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Matlab or Objective C
    1              0.000015 au BufNewFile,BufRead *.m			call s:FTm()
                            
    1              0.000003 func! s:FTm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              if exists("g:filetype_m")
                                exe "setf " . g:filetype_m
                              else
                                setf matlab
                              endif
                            endfunc
                            
                            " Mathematica notebook
    1              0.000018 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    1              0.000014 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    1              0.000019 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    1              0.000026 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    1              0.000037 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    1              0.000015 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    1              0.000012 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    1              0.000014 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
    1              0.000026 au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
    1              0.000014 au BufNewFile,BufRead *.mms			call s:FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    1              0.000013 au BufNewFile,BufRead *.mmp			setf mmp
                            
    1              0.000003 func! s:FTmms()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            
                            " Modsim III (or LambdaProlog)
    1              0.000019 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2  (.md removed in favor of Markdown)
    1              0.000049 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    1              0.000016 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    1              0.000059 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    1              0.000019 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    1              0.000053 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    1              0.000037 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
    1              0.000120 au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
    1              0.000123 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    1              0.000061 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    1              0.000027 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    1              0.000026 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    1              0.000044 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    1              0.000023 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    1              0.000021 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    1              0.000033 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " Nano
    1              0.000041 au BufNewFile,BufRead */etc/nanorc,*.nanorc  	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    1              0.000028 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Netrc
    1              0.000027 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    1              0.000021 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    1              0.000027 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    1              0.000028 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    1              0.000091 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    1              0.000025 au BufNewFile,BufRead *.[1-9]			call s:FTnroff()
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    1              0.000006 func! s:FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Nroff or Objective C++
    1              0.000030 au BufNewFile,BufRead *.mm			call s:FTmm()
                            
    1              0.000004 func! s:FTmm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
                            " Not Quite C
    1              0.000027 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSIS
    1              0.000045 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
    1              0.000096 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    1              0.000025 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    1              0.000044 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    1              0.000024 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    1              0.000027 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    1              0.000026 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    1              0.000023 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    1              0.000026 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    1              0.000056 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    1              0.000162 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    1              0.000027 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    1              0.000030 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    1              0.000025 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " Perl
    1              0.000008 if has("fname_case")
                              au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
                            else
    1              0.000030   au BufNewFile,BufRead *.pl			call s:FTpl()
    1              0.000002 endif
    1              0.000049 au BufNewFile,BufRead *.plx,*.al		setf perl
    1              0.000060 au BufNewFile,BufRead *.p6,*.pm6,*.pl6		setf perl6
                            
    1              0.000004 func! s:FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
                            " Perl, XPM or XPM2
    1              0.000032 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    1              0.000026 au BufNewFile,BufRead *.pod			setf pod
    1              0.000025 au BufNewFile,BufRead *.pod6			setf pod6
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    1              0.000086 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
    1              0.000082 au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
    1              0.000044 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    1              0.000032 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    1              0.000082 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
    1              0.000049 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    1              0.000061 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    1              0.000048 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    1              0.000025 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    1              0.000049 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    1              0.000026 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    1              0.000141 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    1              0.000028 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    1              0.000029 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    1              0.000032 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    1              0.000028 au BufNewFile,BufRead *.inc			call s:FTinc()
                            
    1              0.000003 func! s:FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                else
                                  call s:FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
                            " Printcap and Termcap
    1              0.000038 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    1              0.000028 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    1              0.000023 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    1              0.000046 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    1              0.000028 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    1              0.000025 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    1              0.000025 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    1              0.000048 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    1              0.000028 au BufNewFile,BufRead *.w			call s:FTprogress_cweb()
                            
    1              0.000005 func! s:FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
                            " Progress or assembly
    1              0.000028 au BufNewFile,BufRead *.i			call s:FTprogress_asm()
                            
    1              0.000004 func! s:FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call s:FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            " Progress or Pascal
    1              0.000026 au BufNewFile,BufRead *.p			call s:FTprogress_pascal()
                            
    1              0.000004 func! s:FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
                            	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    1              0.000034 au BufNewFile,BufRead *.psf			setf psf
    1              0.000057 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    1              0.000042 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    1              0.000029 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
    1              0.000026 au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
    1              0.000032 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    1              0.000048 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python
    1              0.000053 au BufNewFile,BufRead *.py,*.pyw		setf python
                            
                            " Quixote (Python-based web framework)
    1              0.000028 au BufNewFile,BufRead *.ptl			setf python
                            
                            " Radiance
    1              0.000053 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    1              0.000052 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    1              0.000029 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    1              0.000044 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    1              0.000044 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    1              0.000029 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    1              0.000190 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
    1              0.000007 if has("fname_case")
                              au BufNewFile,BufRead *.s,*.S			setf r
                            else
    1              0.000029   au BufNewFile,BufRead *.s			setf r
    1              0.000002 endif
                            
                            " R Help file
    1              0.000006 if has("fname_case")
                              au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
    1              0.000028   au BufNewFile,BufRead *.rd			setf rhelp
    1              0.000002 endif
                            
                            " R noweb file
    1              0.000005 if has("fname_case")
                              au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
    1              0.000072   au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
    1              0.000002 endif
                            
                            " R Markdown file
    1              0.000006 if has("fname_case")
                              au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
                            else
    1              0.000049   au BufNewFile,BufRead *.rmd,*.smd			setf rmd
    1              0.000002 endif
                            
                            " R reStructuredText file
    1              0.000005 if has("fname_case")
                              au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
                            else
    1              0.000050   au BufNewFile,BufRead *.rrst,*.srst			setf rrst
    1              0.000003 endif
                            
                            " Rexx, Rebol or R
    1              0.000040 au BufNewFile,BufRead *.r,*.R			call s:FTr()
                            
    1              0.000004 func! s:FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
                            " Remind
    1              0.000073 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    1              0.000032 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    1              0.000029 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    1              0.000028 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    1              0.000031 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    1              0.000029 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    1              0.000024 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    1              0.000027 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    1              0.000032 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    1              0.000050 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    1              0.000052 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    1              0.000028 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rackup
    1              0.000025 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    1              0.000031 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    1              0.000069 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    1              0.000095 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    1              0.000029 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    1              0.000030 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    1              0.000032 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    1              0.000028 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    1              0.000027 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scilab
    1              0.000055 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    1              0.000028 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    1              0.000027 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    1              0.000055 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    1              0.000030 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    1              0.000030 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    1              0.000033 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    1              0.000029 au BufNewFile,BufRead *.mc			call s:McSetf()
                            
    1              0.000004 func! s:McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Services
    1              0.000036 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    1              0.000032 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    1              0.000031 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    1              0.000030 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    1              0.000032 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    1              0.000059 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    1              0.000218 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    1              0.000044 au BufNewFile,BufRead catalog			setf catalog
    1              0.000032 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
    1              0.000254 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call SetFileTypeSH("bash")
    1              0.000059 au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
    1              0.000102 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
    1              0.000033 au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call SetFileTypeSH("bash") |
                            	\ endif
                            
                            " Also called from scripts.vim.
    1              0.000005 func! SetFileTypeSH(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    1              0.000003 func! SetFileTypeShell(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
                            " tcsh scripts
    1              0.000105 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    1              0.000163 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
                            
    1              0.000005 func! s:CSH()
                              if exists("g:filetype_csh")
                                call SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call SetFileTypeShell("tcsh")
                              else
                                call SetFileTypeShell("csh")
                              endif
                            endfunc
                            
                            " Z-Shell script
    1              0.000079 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    1              0.000080 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    1              0.000035 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    1              0.000084 au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
    1              0.000061 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    1              0.000033 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    1              0.000059 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    1              0.000120 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    1              0.000077 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    1              0.000087 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    1              0.000032 au BufNewFile,BufRead .slrnrc			setf slrnrc
    1              0.000033 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    1              0.000034 au BufNewFile,BufRead *.st			setf st
    1              0.000039 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    1              0.000034 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    1              0.000039 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    1              0.000039 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    1              0.000053 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    1              0.000060 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    1              0.000058 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    1              0.000086 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    1              0.000034 au BufNewFile,BufRead *.rules			call s:FTRules()
                            
    1              0.000008 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    1              0.000004 func! s:FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              if path =~ '^/\(etc\|usr/share\)/polkit-1/rules\.d'
                                setf javascript
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                                    setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
                            
                            " Spec (Linux RPM)
    1              0.000039 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    1              0.000078 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    1              0.000040 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    1              0.000055 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    1              0.000062 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    1              0.000034 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    1              0.000130 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    1              0.000040 au BufNewFile,BufRead *.sql			call s:SQL()
                            
    1              0.000003 func! s:SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " SQLJ
    1              0.000035 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    1              0.000061 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    1              0.000057 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    1              0.000036 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    1              0.000129 au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
                            
                            " SMCL
    1              0.000085 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    1              0.000037 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    1              0.000039 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    1              0.000036 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    1              0.000058 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
    1              0.000044 au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}	setf systemd
                            
                            " Synopsys Design Constraints
    1              0.000041 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    1              0.000060 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    1              0.000036 au BufNewFile,BufRead *.svg			setf svg
                            
                            " If the file has an extension of 't' and is in a directory 't' or 'xt' then
                            " it is almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    1              0.000004 func! s:FTperl()
                              let dirname = expand("%:p:h:t")
                              if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              if search('^use\s\s*\k', 'nc', 30)
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Tads (or Nroff or Perl test file)
    1              0.000037 au BufNewFile,BufRead *.t
                            	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif
                            
                            " Tags
    1              0.000038 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    1              0.000037 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    1              0.000036 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    1              0.000034 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    1              0.000151 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    1              0.000042 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    1              0.000037 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language
    1              0.000033 au BufRead,BufNewFile *.ttl			setf teraterm
                            
                            " Terminfo
    1              0.000037 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    1              0.000148 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    1              0.000037 au BufNewFile,BufRead *.tex			call s:FTtex()
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
    1              0.000003 func! s:FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'plain'
                                endif
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
                            " ConTeXt
    1              0.000085 au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
                            
                            " Texinfo
    1              0.000086 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    1              0.000039 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    1              0.000059 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    1              0.000092 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " TPP - Text Presentation Program
    1              0.000038 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    1              0.000037 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    1              0.000032 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    1              0.000034 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    1              0.000038 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    1              0.000033 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " TWIG files
    1              0.000033 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
    1              0.000075 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    1              0.000043 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    1              0.000043 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    1              0.000036 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    1              0.000035 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    1              0.000036 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    1              0.000042 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    1              0.000039 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    1              0.000060 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    1              0.000075 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
    1              0.000039 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    1              0.000039 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    1              0.000099 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    1              0.000034 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    1              0.000065 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
    1              0.000067 au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
    1              0.000153 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    1              0.000038 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    1              0.000129 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    1              0.000067 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    1              0.000104 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    1              0.000045 au BufNewFile,BufRead *.frm			call s:FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    1              0.000033 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    1              0.000034 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    1              0.000034 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
    1              0.000030 au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Webmacro
    1              0.000029 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    1              0.000075 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    1              0.000033 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    1              0.000036 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    1              0.000033 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WvDial
    1              0.000053 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    1              0.000032 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    1              0.000030 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    1              0.000039 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    1              0.000032 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    1              0.000058 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    1              0.000011 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    1              0.000004 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    1              0.000035 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    1              0.000033 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    1              0.000054 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    1              0.000086 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    1              0.000036 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    1              0.000128 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    1              0.000060 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    1              0.000036 au BufNewFile,BufRead *.ms
                            	\ if !s:FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    1              0.000036 au BufNewFile,BufRead *.xml			call s:FTxml()
                            
    1              0.000005 func! s:FTxml()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
                            " XMI (holding UML models) is also XML
    1              0.000036 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    1              0.000058 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    1              0.000055 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    1              0.000036 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    1              0.000034 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    1              0.000030 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    1              0.000033 au BufNewFile,BufRead *.xlf			setf xml
    1              0.000036 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    1              0.000034 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    1              0.000032 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    1              0.000131 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    1              0.000038 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    1              0.000098 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    1              0.000103 au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
    1              0.000033 au BufNewFile,BufRead *.y			call s:FTy()
                            
    1              0.000006 func! s:FTy()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
                            
                            " Yaml
    1              0.000061 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
    1              0.000097 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    1              0.000063 au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
    1              0.000039 au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    1              0.000088 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
                            "   zsql (zope sql method)
    1              0.000033 au BufNewFile,BufRead *.zsql			call s:SQL()
                            
                            " Z80 assembler asz80
    1              0.000035 au BufNewFile,BufRead *.z8a			setf z8a
                            
    1              0.000002 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    1              0.000010 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    1              0.000001 augroup filetypedetect
    1              0.000035 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    1              0.000011 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
    1              0.000121 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    1              0.000127 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    1              0.000033 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    1              0.000034 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    1              0.000031 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " BIND zone
    1              0.000058 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    1              0.000085 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    1              0.000048 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    1              0.000084 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    1              0.000038 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    1              0.000034 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    1              0.000032 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    1              0.000060 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    1              0.000040 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    1              0.000034 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    1              0.000056 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    1              0.000054 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    1              0.000034 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    1              0.000037 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    1              0.000033 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    1              0.000034 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    1              0.000036 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    1              0.000034 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    1              0.000044 au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
                            " Modconf
    1              0.000039 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    1              0.000034 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    1              0.000063 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    1              0.000055 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Nroff macros
    1              0.000038 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " Pam conf
    1              0.000035 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    1              0.000045 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    1              0.000044 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    1              0.000035 au BufRead,BufNewFile *.rdf			call s:Redif()
    1              0.000004 func! s:Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            " Remind
    1              0.000035 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    1              0.000032 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    1              0.000031 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    1              0.000078 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    1              0.000033 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    1              0.000035 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    1              0.000033 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    1              0.000031 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    1              0.000035 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    1              0.000056 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    1              0.000086 au BufNewFile,BufRead *.txt,*.text,README	setf text
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    1              0.000180 runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    1              0.000002 augroup END
                            
                            " Generic configuration file (check this last, it's just guessing!)
    1              0.000037 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    1              0.000010 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    1              0.000002 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    1              0.000012 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /Users/manny/.vim/bundle/swift/ftdetect/swift.vim
Sourced 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
                            autocmd BufNewFile,BufRead *.swift set filetype=swift
    1              0.000014 autocmd BufRead * call s:Swift()
    1              0.000004 function! s:Swift()
                              if !empty(&filetype)
                                return
                              endif
                            
                              let line = getline(1)
                              if line =~ "^#!.*swift"
                                setfiletype swift
                              endif
                            endfunction

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/ftplugin.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000005 if exists("did_load_ftplugin")
                              finish
                            endif
    1              0.000003 let did_load_ftplugin = 1
                            
    1              0.000002 augroup filetypeplugin
    1              0.000005   au FileType * call s:LoadFTPlugin()
                            
    1              0.000003   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/indent.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000004 if exists("did_indent_on")
                              finish
                            endif
    1              0.000003 let did_indent_on = 1
                            
    1              0.000002 augroup filetypeindent
    1              0.000005   au FileType * call s:LoadIndent()
    1              0.000003   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /Users/manny/.vim/bundle/base16-vim/colors/base16-default.vim
Sourced 2 times
Total time:   0.016759
 Self time:   0.003063

count  total (s)   self (s)
                            " Base16 Default (https://github.com/chriskempson/base16)
                            " Scheme: Chris Kempson (http://chriskempson.com)
                            
                            " This enables the coresponding base16-shell script to run so that
                            " :colorscheme works in terminals supported by base16-shell scripts
                            " User must set this variable in .vimrc
                            "   let g:base16_shell_path=base16-builder/output/shell/
    2              0.000015 if !has('gui_running')
    2              0.000008   if exists("g:base16_shell_path")
                                execute "silent !/bin/sh ".g:base16_shell_path."/base16-default.".&background.".sh"
                              endif
    2              0.000002 endif
                            
                            " GUI color definitions
    2              0.000007 let s:gui00 = "181818"
    2              0.000004 let s:gui01 = "282828"
    2              0.000004 let s:gui02 = "383838"
    2              0.000003 let s:gui03 = "585858"
    2              0.000003 let s:gui04 = "b8b8b8"
    2              0.000004 let s:gui05 = "d8d8d8"
    2              0.000003 let s:gui06 = "e8e8e8"
    2              0.000004 let s:gui07 = "f8f8f8"
    2              0.000004 let s:gui08 = "ab4642"
    2              0.000004 let s:gui09 = "dc9656"
    2              0.000004 let s:gui0A = "f7ca88"
    2              0.000004 let s:gui0B = "a1b56c"
    2              0.000003 let s:gui0C = "86c1b9"
    2              0.000004 let s:gui0D = "7cafc2"
    2              0.000004 let s:gui0E = "ba8baf"
    2              0.000003 let s:gui0F = "a16946"
                            
                            " Terminal color definitions
    2              0.000004 let s:cterm00 = "00"
    2              0.000004 let s:cterm03 = "08"
    2              0.000003 let s:cterm05 = "07"
    2              0.000003 let s:cterm07 = "15"
    2              0.000004 let s:cterm08 = "01"
    2              0.000004 let s:cterm0A = "03"
    2              0.000003 let s:cterm0B = "02"
    2              0.000002 let s:cterm0C = "06"
    2              0.000003 let s:cterm0D = "04"
    2              0.000007 let s:cterm0E = "05"
    2              0.000009 if exists('base16colorspace') && base16colorspace == "256"
    2              0.000004   let s:cterm01 = "18"
    2              0.000004   let s:cterm02 = "19"
    2              0.000004   let s:cterm04 = "20"
    2              0.000003   let s:cterm06 = "21"
    2              0.000004   let s:cterm09 = "16"
    2              0.000004   let s:cterm0F = "17"
    2              0.000002 else
                              let s:cterm01 = "10"
                              let s:cterm02 = "11"
                              let s:cterm04 = "12"
                              let s:cterm06 = "13"
                              let s:cterm09 = "09"
                              let s:cterm0F = "14"
                            endif
                            
                            " Theme setup
    2              0.000449 hi clear
    2              0.000200 syntax reset
    2              0.000009 let g:colors_name = "base16-default"
                            
                            " Highlighting function
    2              0.000012 fun <sid>hi(group, guifg, guibg, ctermfg, ctermbg, attr)
                              if a:guifg != ""
                                exec "hi " . a:group . " guifg=#" . s:gui(a:guifg)
                              endif
                              if a:guibg != ""
                                exec "hi " . a:group . " guibg=#" . s:gui(a:guibg)
                              endif
                              if a:ctermfg != ""
                                exec "hi " . a:group . " ctermfg=" . s:cterm(a:ctermfg)
                              endif
                              if a:ctermbg != ""
                                exec "hi " . a:group . " ctermbg=" . s:cterm(a:ctermbg)
                              endif
                              if a:attr != ""
                                exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
                              endif
                            endfun
                            
                            " Return GUI color for light/dark variants
    2              0.000004 fun s:gui(color)
                              if &background == "dark"
                                return a:color
                              endif
                            
                              if a:color == s:gui00
                                return s:gui07
                              elseif a:color == s:gui01
                                return s:gui06
                              elseif a:color == s:gui02
                                return s:gui05
                              elseif a:color == s:gui03
                                return s:gui04
                              elseif a:color == s:gui04
                                return s:gui03
                              elseif a:color == s:gui05
                                return s:gui02
                              elseif a:color == s:gui06
                                return s:gui01
                              elseif a:color == s:gui07
                                return s:gui00
                              endif
                            
                              return a:color
                            endfun
                            
                            " Return terminal color for light/dark variants
    2              0.000004 fun s:cterm(color)
                              if &background == "dark"
                                return a:color
                              endif
                            
                              if a:color == s:cterm00
                                return s:cterm07
                              elseif a:color == s:cterm01
                                return s:cterm06
                              elseif a:color == s:cterm02
                                return s:cterm05
                              elseif a:color == s:cterm03
                                return s:cterm04
                              elseif a:color == s:cterm04
                                return s:cterm03
                              elseif a:color == s:cterm05
                                return s:cterm02
                              elseif a:color == s:cterm06
                                return s:cterm01
                              elseif a:color == s:cterm07
                                return s:cterm00
                              endif
                            
                              return a:color
                            endfun
                            
                            " Vim editor colors
    2   0.000120   0.000037 call <sid>hi("Bold",          "", "", "", "", "bold")
    2   0.000121   0.000016 call <sid>hi("Debug",         s:gui08, "", s:cterm08, "", "")
    2   0.000120   0.000015 call <sid>hi("Directory",     s:gui0D, "", s:cterm0D, "", "")
    2   0.000138   0.000013 call <sid>hi("ErrorMsg",      s:gui08, s:gui00, s:cterm08, s:cterm00, "")
    2   0.000171   0.000016 call <sid>hi("Exception",     s:gui08, "", s:cterm08, "", "")
    2   0.000145   0.000018 call <sid>hi("FoldColumn",    "", s:gui01, "", s:cterm01, "")
    2   0.000162   0.000016 call <sid>hi("Folded",        s:gui03, s:gui01, s:cterm03, s:cterm01, "")
    2   0.000147   0.000015 call <sid>hi("IncSearch",     s:gui01, s:gui09, s:cterm01, s:cterm09, "none")
    2   0.000074   0.000012 call <sid>hi("Italic",        "", "", "", "", "none")
    2   0.000137   0.000017 call <sid>hi("Macro",         s:gui08, "", s:cterm08, "", "")
    2   0.000137   0.000014 call <sid>hi("MatchParen",    s:gui00, s:gui03, s:cterm00, s:cterm03,  "")
    2   0.000097   0.000012 call <sid>hi("ModeMsg",       s:gui0B, "", s:cterm0B, "", "")
    2   0.000106   0.000012 call <sid>hi("MoreMsg",       s:gui0B, "", s:cterm0B, "", "")
    2   0.000111   0.000028 call <sid>hi("Question",      s:gui0D, "", s:cterm0D, "", "")
    2   0.000129   0.000013 call <sid>hi("Search",        s:gui03, s:gui0A, s:cterm03, s:cterm0A,  "")
    2   0.000093   0.000012 call <sid>hi("SpecialKey",    s:gui03, "", s:cterm03, "", "")
    2   0.000093   0.000013 call <sid>hi("TooLong",       s:gui08, "", s:cterm08, "", "")
    2   0.000092   0.000011 call <sid>hi("Underlined",    s:gui08, "", s:cterm08, "", "")
    2   0.000092   0.000010 call <sid>hi("Visual",        "", s:gui02, "", s:cterm02, "")
    2   0.000103   0.000016 call <sid>hi("VisualNOS",     s:gui08, "", s:cterm08, "", "")
    2   0.000093   0.000012 call <sid>hi("WarningMsg",    s:gui08, "", s:cterm08, "", "")
    2   0.000093   0.000011 call <sid>hi("WildMenu",      s:gui08, "", s:cterm08, "", "")
    2   0.000104   0.000013 call <sid>hi("Title",         s:gui0D, "", s:cterm0D, "", "none")
    2   0.000128   0.000011 call <sid>hi("Conceal",       s:gui0D, s:gui00, s:cterm0D, s:cterm00, "")
    2   0.000131   0.000013 call <sid>hi("Cursor",        s:gui00, s:gui05, s:cterm00, s:cterm05, "")
    2   0.000094   0.000011 call <sid>hi("NonText",       s:gui03, "", s:cterm03, "", "")
    2   0.000125   0.000011 call <sid>hi("Normal",        s:gui05, s:gui00, s:cterm05, s:cterm00, "")
    2   0.000130   0.000013 call <sid>hi("LineNr",        s:gui03, s:gui01, s:cterm03, s:cterm01, "")
    2   0.000128   0.000012 call <sid>hi("SignColumn",    s:gui03, s:gui01, s:cterm03, s:cterm01, "")
    2   0.000092   0.000011 call <sid>hi("SpecialKey",    s:gui03, "", s:cterm03, "", "")
    2   0.000139   0.000013 call <sid>hi("StatusLine",    s:gui04, s:gui02, s:cterm04, s:cterm02, "none")
    2   0.000141   0.000014 call <sid>hi("StatusLineNC",  s:gui03, s:gui01, s:cterm03, s:cterm01, "none")
    2   0.000140   0.000013 call <sid>hi("VertSplit",     s:gui02, s:gui02, s:cterm02, s:cterm02, "none")
    2   0.000104   0.000012 call <sid>hi("ColorColumn",   "", s:gui01, "", s:cterm01, "none")
    2   0.000101   0.000012 call <sid>hi("CursorColumn",  "", s:gui01, "", s:cterm01, "none")
    2   0.000101   0.000011 call <sid>hi("CursorLine",    "", s:gui01, "", s:cterm01, "none")
    2   0.000130   0.000013 call <sid>hi("CursorLineNr",  s:gui03, s:gui01, s:cterm03, s:cterm01, "")
    2   0.000139   0.000012 call <sid>hi("PMenu",         s:gui04, s:gui01, s:cterm04, s:cterm01, "none")
    2   0.000132   0.000014 call <sid>hi("PMenuSel",      s:gui01, s:gui04, s:cterm01, s:cterm04, "")
    2   0.000149   0.000013 call <sid>hi("TabLine",       s:gui03, s:gui01, s:cterm03, s:cterm01, "none")
    2   0.000140   0.000012 call <sid>hi("TabLineFill",   s:gui03, s:gui01, s:cterm03, s:cterm01, "none")
    2   0.000142   0.000012 call <sid>hi("TabLineSel",    s:gui0B, s:gui01, s:cterm0B, s:cterm01, "none")
                            
                            " Standard syntax highlighting
    2   0.000096   0.000013 call <sid>hi("Boolean",      s:gui09, "", s:cterm09, "", "")
    2   0.000092   0.000010 call <sid>hi("Character",    s:gui08, "", s:cterm08, "", "")
    2   0.000094   0.000012 call <sid>hi("Comment",      s:gui03, "", s:cterm03, "", "")
    2   0.000093   0.000010 call <sid>hi("Conditional",  s:gui0E, "", s:cterm0E, "", "")
    2   0.000095   0.000012 call <sid>hi("Constant",     s:gui09, "", s:cterm09, "", "")
    2   0.000104   0.000012 call <sid>hi("Define",       s:gui0E, "", s:cterm0E, "", "none")
    2   0.000094   0.000012 call <sid>hi("Delimiter",    s:gui0F, "", s:cterm0F, "", "")
    2   0.000094   0.000012 call <sid>hi("Float",        s:gui09, "", s:cterm09, "", "")
    2   0.000093   0.000012 call <sid>hi("Function",     s:gui0D, "", s:cterm0D, "", "")
    2   0.000103   0.000013 call <sid>hi("Identifier",   s:gui08, "", s:cterm08, "", "none")
    2   0.000092   0.000011 call <sid>hi("Include",      s:gui0D, "", s:cterm0D, "", "")
    2   0.000092   0.000012 call <sid>hi("Keyword",      s:gui0E, "", s:cterm0E, "", "")
    2   0.000093   0.000011 call <sid>hi("Label",        s:gui0A, "", s:cterm0A, "", "")
    2   0.000093   0.000011 call <sid>hi("Number",       s:gui09, "", s:cterm09, "", "")
    2   0.000103   0.000011 call <sid>hi("Operator",     s:gui05, "", s:cterm05, "", "none")
    2   0.000094   0.000013 call <sid>hi("PreProc",      s:gui0A, "", s:cterm0A, "", "")
    2   0.000093   0.000012 call <sid>hi("Repeat",       s:gui0A, "", s:cterm0A, "", "")
    2   0.000093   0.000010 call <sid>hi("Special",      s:gui0C, "", s:cterm0C, "", "")
    2   0.000093   0.000011 call <sid>hi("SpecialChar",  s:gui0F, "", s:cterm0F, "", "")
    2   0.000094   0.000013 call <sid>hi("Statement",    s:gui08, "", s:cterm08, "", "")
    2   0.000093   0.000010 call <sid>hi("StorageClass", s:gui0A, "", s:cterm0A, "", "")
    2   0.000094   0.000011 call <sid>hi("String",       s:gui0B, "", s:cterm0B, "", "")
    2   0.000094   0.000012 call <sid>hi("Structure",    s:gui0E, "", s:cterm0E, "", "")
    2   0.000095   0.000013 call <sid>hi("Tag",          s:gui0A, "", s:cterm0A, "", "")
    2   0.000132   0.000011 call <sid>hi("Todo",         s:gui0A, s:gui01, s:cterm0A, s:cterm01, "")
    2   0.000104   0.000012 call <sid>hi("Type",         s:gui0A, "", s:cterm0A, "", "none")
    2   0.000095   0.000013 call <sid>hi("Typedef",      s:gui0A, "", s:cterm0A, "", "")
                            
                            " C highlighting
    2   0.000095   0.000011 call <sid>hi("cOperator",   s:gui0C, "", s:cterm0C, "", "")
    2   0.000095   0.000011 call <sid>hi("cPreCondit",  s:gui0E, "", s:cterm0E, "", "")
                            
                            " CSS highlighting
    2   0.000094   0.000011 call <sid>hi("cssBraces",      s:gui05, "", s:cterm05, "", "")
    2   0.000105   0.000011 call <sid>hi("cssClassName",   s:gui0E, "", s:cterm0E, "", "")
    2   0.000097   0.000012 call <sid>hi("cssColor",       s:gui0C, "", s:cterm0C, "", "")
                            
                            " Diff highlighting
    2   0.000137   0.000012 call <sid>hi("DiffAdd",      s:gui0B, s:gui01,  s:cterm0B, s:cterm01, "")
    2   0.000143   0.000014 call <sid>hi("DiffChange",   s:gui03, s:gui01,  s:cterm03, s:cterm01, "")
    2   0.000131   0.000012 call <sid>hi("DiffDelete",   s:gui08, s:gui01,  s:cterm08, s:cterm01, "")
    2   0.000143   0.000012 call <sid>hi("DiffText",     s:gui0D, s:gui01,  s:cterm0D, s:cterm01, "")
    2   0.000155   0.000012 call <sid>hi("DiffAdded",    s:gui0B, s:gui00,  s:cterm0B, s:cterm00, "")
    2   0.000140   0.000012 call <sid>hi("DiffFile",     s:gui08, s:gui00,  s:cterm08, s:cterm00, "")
    2   0.000133   0.000012 call <sid>hi("DiffNewFile",  s:gui0B, s:gui00,  s:cterm0B, s:cterm00, "")
    2   0.000193   0.000017 call <sid>hi("DiffLine",     s:gui0D, s:gui00,  s:cterm0D, s:cterm00, "")
    2   0.000178   0.000023 call <sid>hi("DiffRemoved",  s:gui08, s:gui00,  s:cterm08, s:cterm00, "")
                            
                            " Git highlighting
    2   0.000094   0.000013 call <sid>hi("gitCommitOverflow",  s:gui08, "", s:cterm08, "", "")
    2   0.000101   0.000012 call <sid>hi("gitCommitSummary",   s:gui0B, "", s:cterm0B, "", "")
                              
                            " GitGutter highlighting
    2   0.000131   0.000011 call <sid>hi("GitGutterAdd",     s:gui0B, s:gui01, s:cterm0B, s:cterm01, "")
    2   0.000131   0.000011 call <sid>hi("GitGutterChange",  s:gui0D, s:gui01, s:cterm0D, s:cterm01, "")
    2   0.000130   0.000013 call <sid>hi("GitGutterDelete",  s:gui08, s:gui01, s:cterm08, s:cterm01, "")
    2   0.000135   0.000013 call <sid>hi("GitGutterChangeDelete",  s:gui0E, s:gui01, s:cterm0E, s:cterm01, "")
                            
                            " HTML highlighting
    2   0.000093   0.000010 call <sid>hi("htmlBold",    s:gui0A, "", s:cterm0A, "", "")
    2   0.000095   0.000013 call <sid>hi("htmlItalic",  s:gui0E, "", s:cterm0E, "", "")
    2   0.000102   0.000011 call <sid>hi("htmlEndTag",  s:gui05, "", s:cterm05, "", "")
    2   0.000099   0.000012 call <sid>hi("htmlTag",     s:gui05, "", s:cterm05, "", "")
                            
                            " JavaScript highlighting
    2   0.000113   0.000011 call <sid>hi("javaScript",        s:gui05, "", s:cterm05, "", "")
    2   0.000105   0.000012 call <sid>hi("javaScriptBraces",  s:gui05, "", s:cterm05, "", "")
    2   0.000095   0.000012 call <sid>hi("javaScriptNumber",  s:gui09, "", s:cterm09, "", "")
                            
                            " Markdown highlighting
    2   0.000104   0.000011 call <sid>hi("markdownCode",              s:gui0B, "", s:cterm0B, "", "")
    2   0.000130   0.000012 call <sid>hi("markdownError",             s:gui05, s:gui00, s:cterm05, s:cterm00, "")
    2   0.000098   0.000012 call <sid>hi("markdownCodeBlock",         s:gui0B, "", s:cterm0B, "", "")
    2   0.000095   0.000013 call <sid>hi("markdownHeadingDelimiter",  s:gui0D, "", s:cterm0D, "", "")
                            
                            " NERDTree highlighting
    2   0.000092   0.000012 call <sid>hi("NERDTreeDirSlash",  s:gui0D, "", s:cterm0D, "", "")
    2   0.000093   0.000012 call <sid>hi("NERDTreeExecFile",  s:gui05, "", s:cterm05, "", "")
                            
                            " PHP highlighting
    2   0.000092   0.000010 call <sid>hi("phpMemberSelector",  s:gui05, "", s:cterm05, "", "")
    2   0.000094   0.000013 call <sid>hi("phpComparison",      s:gui05, "", s:cterm05, "", "")
    2   0.000094   0.000011 call <sid>hi("phpParent",          s:gui05, "", s:cterm05, "", "")
                            
                            " Python highlighting
    2   0.000094   0.000012 call <sid>hi("pythonOperator",  s:gui0E, "", s:cterm0E, "", "")
    2   0.000109   0.000013 call <sid>hi("pythonRepeat",    s:gui0E, "", s:cterm0E, "", "")
                            
                            " Ruby highlighting
    2   0.000127   0.000015 call <sid>hi("rubyAttribute",               s:gui0D, "", s:cterm0D, "", "")
    2   0.000128   0.000015 call <sid>hi("rubyConstant",                s:gui0A, "", s:cterm0A, "", "")
    2   0.000127   0.000017 call <sid>hi("rubyInterpolation",           s:gui0B, "", s:cterm0B, "", "")
    2   0.000129   0.000015 call <sid>hi("rubyInterpolationDelimiter",  s:gui0F, "", s:cterm0F, "", "")
    2   0.000129   0.000016 call <sid>hi("rubyRegexp",                  s:gui0C, "", s:cterm0C, "", "")
    2   0.000129   0.000017 call <sid>hi("rubySymbol",                  s:gui0B, "", s:cterm0B, "", "")
    2   0.000132   0.000016 call <sid>hi("rubyStringDelimiter",         s:gui0B, "", s:cterm0B, "", "")
                            
                            " SASS highlighting
    2   0.000128   0.000016 call <sid>hi("sassidChar",     s:gui08, "", s:cterm08, "", "")
    2   0.000131   0.000017 call <sid>hi("sassClassChar",  s:gui09, "", s:cterm09, "", "")
    2   0.000131   0.000016 call <sid>hi("sassInclude",    s:gui0E, "", s:cterm0E, "", "")
    2   0.000129   0.000016 call <sid>hi("sassMixing",     s:gui0E, "", s:cterm0E, "", "")
    2   0.000131   0.000017 call <sid>hi("sassMixinName",  s:gui0D, "", s:cterm0D, "", "")
                            
                            " Signify highlighting
    2   0.000170   0.000018 call <sid>hi("SignifySignAdd",     s:gui0B, s:gui01, s:cterm0B, s:cterm01, "")
    2   0.000133   0.000014 call <sid>hi("SignifySignChange",  s:gui0D, s:gui01, s:cterm0D, s:cterm01, "")
    2   0.000130   0.000015 call <sid>hi("SignifySignDelete",  s:gui08, s:gui01, s:cterm08, s:cterm01, "")
                            
                            " Spelling highlighting
    2   0.000111   0.000011 call <sid>hi("SpellBad",     "", s:gui00, "", s:cterm00, "undercurl")
    2   0.000110   0.000012 call <sid>hi("SpellLocal",   "", s:gui00, "", s:cterm00, "undercurl")
    2   0.000109   0.000012 call <sid>hi("SpellCap",     "", s:gui00, "", s:cterm00, "undercurl")
    2   0.000120   0.000012 call <sid>hi("SpellRare",    "", s:gui00, "", s:cterm00, "undercurl")
                            
                            " Remove functions
    2              0.000011 delf <sid>hi
    2              0.000010 delf <sid>gui
    2              0.000012 delf <sid>cterm
                            
                            " Remove color variables
    2              0.000019 unlet s:gui00 s:gui01 s:gui02 s:gui03  s:gui04  s:gui05  s:gui06  s:gui07  s:gui08  s:gui09 s:gui0A  s:gui0B  s:gui0C  s:gui0D  s:gui0E  s:gui0F
    2              0.000026 unlet s:cterm00 s:cterm01 s:cterm02 s:cterm03 s:cterm04 s:cterm05 s:cterm06 s:cterm07 s:cterm08 s:cterm09 s:cterm0A s:cterm0B s:cterm0C s:cterm0D s:cterm0E s:cterm0F

SCRIPT  /Users/manny/.vim/bundle/swift/plugin/swift.vim
Sourced 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
Sourced 2 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_autoloclist') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000004 let g:loaded_syntastic_notifier_autoloclist = 1
                            
    1              0.000003 let g:SyntasticAutoloclistNotifier = {}
                            
                            " Public methods {{{1
                            "
    1              0.000003 function! g:SyntasticAutoloclistNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticAutoloclistNotifier.refresh(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
                                call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticAutoloclistNotifier.AutoToggle(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
                                let auto_loc_list = syntastic#util#var('auto_loc_list')
                                if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
                                    if auto_loc_list == 1 || auto_loc_list == 2
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
                                        lclose
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
Sourced 2 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_balloons') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000003 let g:loaded_syntastic_notifier_balloons = 1
                            
    1              0.000005 if !has('balloon_eval')
    1              0.000002     let g:syntastic_enable_balloons = 0
    1              0.000001 endif
                            
    1              0.000002 let g:SyntasticBalloonsNotifier = {}
                            
                            " Public methods {{{1
                            
    1              0.000001 function! g:SyntasticBalloonsNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticBalloonsNotifier.enabled() abort " {{{2
                                return has('balloon_eval') && syntastic#util#var('enable_balloons')
                            endfunction " }}}2
                            
                            " Update the error balloons
    1              0.000002 function! g:SyntasticBalloonsNotifier.refresh(loclist) abort " {{{2
                                unlet! b:syntastic_private_balloons
                                if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " Reset the error balloons
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000002 function! g:SyntasticBalloonsNotifier.reset(loclist) abort " {{{2
                                let b:syntastic_private_balloons = {}
                                if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000003 function! SyntasticBalloonsExprNotifier() abort " {{{2
                                if !exists('b:syntastic_private_balloons')
                                    return ''
                                endif
                                return get(b:syntastic_private_balloons, v:beval_lnum, '')
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/checker.vim
Sourced 2 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_checker') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
                            endif
    1              0.000003 let g:loaded_syntastic_checker = 1
                            
    1              0.000002 let g:SyntasticChecker = {}
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticChecker.New(args, ...) abort " {{{2
                                let newObj = copy(self)
                            
                                let newObj._filetype = a:args['filetype']
                                let newObj._name = a:args['name']
                            
                                if a:0
                                    " redirected checker
                                    let newObj._exec = get(a:args, 'exec', a:1['_exec'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
                                else
                                    let newObj._exec = get(a:args, 'exec', newObj._name)
                                    let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
                                endif
                            
                                let newObj._locListFunc = function(prefix . 'GetLocList')
                            
                                if exists('*' . prefix . 'IsAvailable')
                                    let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
                                else
                                    let newObj._isAvailableFunc = function('s:_isAvailableDefault')
                                endif
                            
                                if exists('*' . prefix . 'GetHighlightRegex')
                                    let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
                                endif
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getFiletype() abort " {{{2
                                return self._filetype
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getName() abort " {{{2
                                return self._name
                            endfunction " }}}2
                            
                            " Synchronise _exec with user's setting.  Force re-validation if needed.
                            "
                            " XXX: This function must be called at least once before calling either
                            " getExec() or getExecEscaped().  Normally isAvailable() does that for you
                            " automatically, but you should keep still this in mind if you change the
                            " current checker workflow.
    1              0.000001 function! g:SyntasticChecker.syncExec() abort " {{{2
                                let user_exec =
                                    \ expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec :
                                    \ syntastic#util#var(self._filetype . '_' . self._name . '_exec'), 1 )
                            
                                if user_exec !=# '' && user_exec !=# self._exec
                                    let self._exec = user_exec
                                    if has_key(self, '_available')
                                        " we have a new _exec on the block, it has to be validated
                                        call remove(self, '_available')
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getExec() abort " {{{2
                                return self._exec
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getExecEscaped() abort " {{{2
                                return syntastic#util#shescape(self._exec)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getLocListRaw() abort " {{{2
                                let checker_start = reltime()
                                let name = self._filetype . '/' . self._name
                            
                                if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) .
                                            \ ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' .
                                            \ 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
                                try
                                    let list = self._locListFunc()
                                    if self._exec !=# ''
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
                                    endif
                                catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
                                call self._populateHighlightRegexes(list)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
                                call self._quietMessages(list)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE,
                                    \ 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
                                return list
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getLocList() abort " {{{2
                                return g:SyntasticLoclist.New(self.getLocListRaw())
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getVersion(...) abort " {{{2
                                if !exists('self._version')
                                    let command = a:0 ? a:1 : self.getExecEscaped() . ' --version'
                                    let version_output = syntastic#util#system(command)
                                    call self.log('getVersion: ' . string(command) . ': ' .
                                        \ string(split(version_output, "\n", 1)) .
                                        \ (v:shell_error ? ' (exit code ' . v:shell_error . ')' : '') )
                                    let parsed_ver = syntastic#util#parseVersion(version_output)
                                    if len(parsed_ver)
                                        call self.setVersion(parsed_ver)
                                    else
                                        call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                        call syntastic#log#error("checker " . self._filetype . "/" . self._name . ": can't parse version string (abnormal termination?)")
                                    endif
                                endif
                                return get(self, '_version', [])
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.setVersion(version) abort " {{{2
                                if len(a:version)
                                    let self._version = copy(a:version)
                                    call self.log(self.getExec() . ' version =', a:version)
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.log(msg, ...) abort " {{{2
                                let leader = self._filetype . '/' . self._name . ': '
                                if a:0 > 0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
                                else
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.makeprgBuild(opts) abort " {{{2
                                let basename = self._filetype . '_' . self._name . '_'
                            
                                let parts = []
                                call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
                                call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
                                call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
                                return join(parts)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.isAvailable() abort " {{{2
                                call self.syncExec()
                                if !has_key(self, '_available')
                                    let self._available = self._isAvailableFunc()
                                endif
                                return self._available
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.isDisabled() abort " {{{2
                                return has_key(self, '_enable') && syntastic#util#var(self._enable, -1) <= 0
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.wantSort() abort " {{{2
                                return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)
                            endfunction " }}}2
                            
                            " This method is no longer used by syntastic.  It's here only to maintain
                            " backwards compatibility with external checkers which might depend on it.
    1              0.000002 function! g:SyntasticChecker.setWantSort(val) abort " {{{2
                                if !exists('g:syntastic_' . self._filetype . '_' . self._name . '_sort')
                                    let g:syntastic_{self._filetype}_{self._name}_sort = a:val
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticChecker._quietMessages(errors) abort " {{{2
                                " wildcard quiet_messages
                                let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
                                if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
                                let name = self._filetype . '_' . self._name
                                try
                                    call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
                                catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
                                if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker._populateHighlightRegexes(errors) abort " {{{2
                                if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker._getOpt(opts, basename, name, default) abort " {{{2
                                let ret = []
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
                                call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
                                return ret
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000002 function! s:_isAvailableDefault() dict " {{{2
                                return executable(self.getExec())
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
Sourced 2 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_cursor') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
                            endif
    1              0.000003 let g:loaded_syntastic_notifier_cursor = 1
                            
    1              0.000002 let g:SyntasticCursorNotifier = {}
                            
                            " Public methods {{{1
                            
    1              0.000001 function! g:SyntasticCursorNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticCursorNotifier.enabled() abort " {{{2
                                return syntastic#util#var('echo_current_error')
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticCursorNotifier.refresh(loclist) abort " {{{2
                                if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif
                            endfunction " }}}2
                            
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000002 function! g:SyntasticCursorNotifier.reset(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
                                autocmd! syntastic CursorMoved
                                unlet! b:syntastic_private_messages
                                let b:syntastic_private_line = -1
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000002 function! SyntasticRefreshCursor() abort " {{{2
                                if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
                                    return
                                endif
                            
                                if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
                                let l = line('.')
                                let current_messages = get(b:syntastic_private_messages, l, {})
                            
                                if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
                                if b:syntastic_cursor_columns
                                    let c = virtcol('.')
                                    if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
                                    if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
                                        let b:syntastic_private_line = l
                                    endif
                            
                                    if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
                                        let b:syntastic_private_idx = -1
                                        echo
                                    endif
                                else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000003 function! s:_is_same_index(line, old_line, column, idx, messages) abort " {{{2
                                if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
                                    if len(a:messages) <= 1
                                        return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
                                    return 0
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:_find_index(column, messages) abort " {{{2
                                let max = len(a:messages) - 1
                                if max == 0
                                    return 0
                                endif
                                let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
                                while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
                                return a:column < a:messages[max].scol ? min : max
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
Sourced 2 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_highlighting') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
                            endif
    1              0.000003 let g:loaded_syntastic_notifier_highlighting = 1
                            
                            " Highlighting requires getmatches introduced in 7.1.040
    1              0.000005 let s:has_highlighting = v:version > 701 || (v:version == 701 && has('patch040'))
    1              0.000003 lockvar s:has_highlighting
                            
    1              0.000003 let g:SyntasticHighlightingNotifier = {}
                            
    1              0.000002 let s:setup_done = 0
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticHighlightingNotifier.New() abort " {{{2
                                let newObj = copy(self)
                            
                                if !s:setup_done
                                    call self._setup()
                                    let s:setup_done = 1
                                    lockvar s:setup_done
                                endif
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticHighlightingNotifier.enabled() abort " {{{2
                                return s:has_highlighting && syntastic#util#var('enable_highlighting')
                            endfunction " }}}2
                            
                            " Sets error highlights in the current window
    1              0.000002 function! g:SyntasticHighlightingNotifier.refresh(loclist) abort " {{{2
                                if self.enabled()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
                                    call self._reset()
                                    let buf = bufnr('')
                                    let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
                                    for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Remove all error highlights from the window
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000002 function! g:SyntasticHighlightingNotifier.reset(loclist) abort " {{{2
                                if s:has_highlighting
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
                                    call self._reset()
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
                            " One time setup: define our own highlighting
    1              0.000001 function! g:SyntasticHighlightingNotifier._setup() abort " {{{2
                                if s:has_highlighting
                                    if !hlexists('SyntasticError')
                                        highlight link SyntasticError SpellBad
                                    endif
                                    if !hlexists('SyntasticWarning')
                                        highlight link SyntasticWarning SpellCap
                                    endif
                                    if !hlexists('SyntasticStyleError')
                                        highlight link SyntasticStyleError SyntasticError
                                    endif
                                    if !hlexists('SyntasticStyleWarning')
                                        highlight link SyntasticStyleWarning SyntasticWarning
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticHighlightingNotifier._reset() abort " {{{2
                                for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
Sourced 2 times
Total time:   0.000468
 Self time:   0.000468

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_loclist') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000003 let g:loaded_syntastic_loclist = 1
                            
    1              0.000005 let g:SyntasticLoclist = {}
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticLoclist.New(rawLoclist) abort " {{{2
                                let newObj = copy(self)
                            
                                let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
                                for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
                                let newObj._rawLoclist = llist
                                let newObj._name = ''
                                let newObj._owner = bufnr('')
                                let newObj._sorted = 0
                                let newObj._columns = g:syntastic_cursor_columns
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.current() abort " {{{2
                                if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
                                return b:syntastic_loclist
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.extend(other) abort " {{{2
                                let list = self.copyRaw()
                                call extend(list, a:other.copyRaw())
                                return g:SyntasticLoclist.New(list)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.sort() abort " {{{2
                                if !self._sorted
                                    for e in self._rawLoclist
                                        call s:_set_screen_column(e)
                                    endfor
                            
                                    call sort(self._rawLoclist, self._columns ? 's:_compare_error_items_by_columns' : 's:_compare_error_items_by_lines')
                            
                                    let self._sorted = 1
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.isEmpty() abort " {{{2
                                return empty(self._rawLoclist)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.isNewerThan(stamp) abort " {{{2
                                if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
                                return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.copyRaw() abort " {{{2
                                return copy(self._rawLoclist)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getRaw() abort " {{{2
                                return self._rawLoclist
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getBuffers() abort " {{{2
                                return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getCursorColumns() abort " {{{2
                                return self._columns
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getStatuslineFlag() abort " {{{2
                                if !exists('self._stl_format')
                                    let self._stl_format = ''
                                endif
                                if !exists('self._stl_flag')
                                    let self._stl_flag = ''
                                endif
                            
                                if g:syntastic_stl_format !=# self._stl_format
                                    let self._stl_format = g:syntastic_stl_format
                            
                                    if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = {
                                            \ '%':  '%',
                                            \ 't':  num_issues,
                                            \ 'e':  num_errors,
                                            \ 'w':  num_warnings,
                                            \ 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''),
                                            \ 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''),
                                            \ 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''),
                                            \ 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'fe': (num_errors ? errors[0]['lnum'] : ''),
                                            \ 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''),
                                            \ 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
                                        let self._stl_flag = ''
                                    endif
                                endif
                            
                                return self._stl_flag
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getFirstError(...) abort " {{{2
                                let max_issues = len(self._rawLoclist)
                                if a:0 && a:1 < max_issues
                                    let max_issues = a:1
                                endif
                            
                                for idx in range(max_issues)
                                    if get(self._rawLoclist[idx], 'type', '') ==? 'E'
                                        return idx + 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getName() abort " {{{2
                                return len(self._name)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.setName(name) abort " {{{2
                                let self._name = a:name
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.getOwner() abort " {{{2
                                return self._owner
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.setOwner(buffer) abort " {{{2
                                let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.deploy() abort " {{{2
                                call self.setOwner(bufnr(''))
                                let self._stamp = syntastic#util#stamp()
                                for buf in self.getBuffers()
                                    call setbufvar(buf, 'syntastic_loclist', self)
                                endfor
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.destroy() abort " {{{2
                                for buf in self.getBuffers()
                                    call setbufvar(buf, 'syntastic_loclist', {})
                                endfor
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.decorate(tag) abort " {{{2
                                for e in self._rawLoclist
                                    let e['text'] .= ' [' . a:tag . ']'
                                endfor
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.balloons() abort " {{{2
                                if !exists('self._cachedBalloons')
                                    let sep = has('balloon_multiline') ? "\n" : ' | '
                            
                                    let self._cachedBalloons = {}
                                    for e in self._rawLoclist
                                        let buf = e['bufnr']
                            
                                        if !has_key(self._cachedBalloons, buf)
                                            let self._cachedBalloons[buf] = {}
                                        endif
                            
                                        if has_key(self._cachedBalloons[buf], e['lnum'])
                                            let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
                                        else
                                            let self._cachedBalloons[buf][e['lnum']] = e['text']
                                        endif
                                    endfor
                                endif
                            
                                return get(self._cachedBalloons, bufnr(''), {})
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.errors() abort " {{{2
                                if !exists('self._cachedErrors')
                                    let self._cachedErrors = self.filter({'type': 'E'})
                                endif
                                return self._cachedErrors
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.warnings() abort " {{{2
                                if !exists('self._cachedWarnings')
                                    let self._cachedWarnings = self.filter({'type': 'W'})
                                endif
                                return self._cachedWarnings
                            endfunction " }}}2
                            
                            " Legacy function.  Syntastic no longer calls it, but we keep it
                            " around because other plugins (f.i. powerline) depend on it.
    1              0.000001 function! g:SyntasticLoclist.hasErrorsOrWarningsToDisplay() abort " {{{2
                                return !self.isEmpty()
                            endfunction " }}}2
                            
                            " cache used by EchoCurrentError()
    1              0.000002 function! g:SyntasticLoclist.messages(buf) abort " {{{2
                                if !exists('self._cachedMessages')
                                    let self._cachedMessages = {}
                            
                                    let errors = self.errors() + self.warnings()
                                    for e in errors
                                        let b = e['bufnr']
                                        let l = e['lnum']
                            
                                        if !has_key(self._cachedMessages, b)
                                            let self._cachedMessages[b] = {}
                                        endif
                            
                                        if !has_key(self._cachedMessages[b], l)
                                            let self._cachedMessages[b][l] = [e]
                                        elseif self._columns
                                            call add(self._cachedMessages[b][l], e)
                                        endif
                                    endfor
                            
                                    if self._columns
                                        if !self._sorted
                                            for b in keys(self._cachedMessages)
                                                for l in keys(self._cachedMessages[b])
                                                    if len(self._cachedMessages[b][l]) > 1
                                                        for e in self._cachedMessages[b][l]
                                                            call s:_set_screen_column(e)
                                                        endfor
                                                        call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
                                                    endif
                                                endfor
                                            endfor
                                        endif
                            
                                        for b in keys(self._cachedMessages)
                                            for l in keys(self._cachedMessages[b])
                                                call s:_remove_shadowed_items(self._cachedMessages[b][l])
                                            endfor
                                        endfor
                                    endif
                                endif
                            
                                return get(self._cachedMessages, a:buf, {})
                            endfunction " }}}2
                            
                            "Filter the list and return new native loclist
                            "e.g.
                            "  .filter({'bufnr': 10, 'type': 'e'})
                            "
                            "would return all errors for buffer 10.
                            "
                            "Note that all comparisons are done with ==?
    1              0.000002 function! g:SyntasticLoclist.filter(filters) abort " {{{2
                                let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
                                let filter = len(conditions) == 1 ?
                                    \ conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                                return filter(copy(self._rawLoclist), filter)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.setloclist() abort " {{{2
                                if !exists('w:syntastic_loclist_set')
                                    let w:syntastic_loclist_set = []
                                endif
                                if empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [bufnr(''), b:changedtick]
                                    let replace = g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
                                    call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
                                    call syntastic#util#setChangedtick()
                                    let w:syntastic_loclist_set = [bufnr(''), b:syntastic_changedtick]
                                endif
                            endfunction " }}}2
                            
                            "display the cached errors for this buf in the location list
    1              0.000002 function! g:SyntasticLoclist.show() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: show')
                                call self.setloclist()
                            
                                if !self.isEmpty()
                                    let num = winnr()
                                    execute 'lopen ' . syntastic#util#var('loc_list_height')
                                    if num != winnr()
                                        execute num . 'wincmd w'
                                    endif
                            
                                    " try to find the loclist window and set w:quickfix_title
                                    let errors = getloclist(0)
                                    for buf in tabpagebuflist()
                                        if buflisted(buf) && bufloaded(buf) && getbufvar(buf, '&buftype') ==# 'quickfix'
                                            let win = bufwinnr(buf)
                                            let title = getwinvar(win, 'quickfix_title')
                            
                                            " TODO: try to make sure we actually own this window; sadly,
                                            " errors == getloclist(0) is the only somewhat safe way to
                                            " achieve that
                                            if strpart(title, 0, 16) ==# ':SyntasticCheck ' ||
                                                        \ ( (title ==# '' || title ==# ':setloclist()') && errors == getloclist(0) )
                                                call setwinvar(win, 'quickfix_title', ':SyntasticCheck ' . self._name)
                                                call setbufvar(buf, 'syntastic_owner_buffer', self._owner)
                                            endif
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Public functions {{{1
                            
    1              0.000002 function! SyntasticLoclistHide() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
                                silent! lclose
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000002 function! s:_translate(key, val) abort " {{{2
                                return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)
                            endfunction " }}}2
                            
    1              0.000003 function! s:_set_screen_column(item) abort " {{{2
                                if !has_key(a:item, 'scol')
                                    let col = get(a:item, 'col', 0)
                                    if col != 0 && get(a:item, 'vcol', 0) == 0
                                        let buf = str2nr(a:item['bufnr'])
                                        try
                                            let line = getbufline(buf, a:item['lnum'])[0]
                                        catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
                                        let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
                                    else
                                        let a:item['scol'] = col
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:_remove_shadowed_items(errors) abort " {{{2
                                " keep only the first message at a given column
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            
                                " merge messages with the same text
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            endfunction " }}}2
                            
    1              0.000003 function! s:_compare_error_items_by_columns(a, b) abort " {{{2
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:_compare_error_items_by_lines(a, b) abort " {{{2
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
Sourced 2 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_modemap') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
                            endif
    1              0.000002 let g:loaded_syntastic_modemap = 1
                            
    1              0.000002 let g:SyntasticModeMap = {}
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticModeMap.Instance() abort " {{{2
                                if !exists('s:SyntasticModeMapInstance')
                                    let s:SyntasticModeMapInstance = copy(self)
                                    call s:SyntasticModeMapInstance.synch()
                                endif
                            
                                return s:SyntasticModeMapInstance
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.synch() abort " {{{2
                                if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
                                    let self._mode = 'active'
                                    let self._activeFiletypes = []
                                    let self._passiveFiletypes = []
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.allowsAutoChecking(filetype) abort " {{{2
                                let fts = split(a:filetype, '\m\.')
                            
                                if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
                                    return self._noFiletypesArePassive(fts)
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.doAutoChecking() abort " {{{2
                                let local_mode = get(b:, 'syntastic_mode', '')
                                if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
                                return self.allowsAutoChecking(&filetype)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.isPassive() abort " {{{2
                                return self._mode ==# 'passive'
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.toggleMode() abort " {{{2
                                call self.synch()
                            
                                if self._mode ==# 'active'
                                    let self._mode = 'passive'
                                else
                                    let self._mode = 'active'
                                endif
                            
                                "XXX Changing a global variable.  Tsk, tsk...
                                if !exists('g:syntastic_mode_map')
                                    let g:syntastic_mode_map = {}
                                endif
                                let g:syntastic_mode_map['mode'] = self._mode
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.echoMode() abort " {{{2
                                echo 'Syntastic: ' . self._mode . ' mode enabled'
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.modeInfo(filetypes) abort " {{{2
                                echomsg 'Syntastic version: ' . g:_SYNTASTIC_VERSION . ' (Vim ' . v:version . ', ' . g:_SYNTASTIC_UNAME . ')'
                                let type = len(a:filetypes) ? a:filetypes[0] : &filetype
                                echomsg 'Info for filetype: ' . type
                            
                                call self.synch()
                                echomsg 'Global mode: ' . self._mode
                                if self._mode ==# 'active'
                                    if len(self._passiveFiletypes)
                                        let plural = len(self._passiveFiletypes) != 1 ? 's' : ''
                                        echomsg 'Passive filetype' . plural . ': ' . join(sort(copy(self._passiveFiletypes)))
                                    endif
                                else
                                    if len(self._activeFiletypes)
                                        let plural = len(self._activeFiletypes) != 1 ? 's' : ''
                                        echomsg 'Active filetype' . plural . ': ' . join(sort(copy(self._activeFiletypes)))
                                    endif
                                endif
                                echomsg 'Filetype ' . type . ' is ' . (self.allowsAutoChecking(type) ? 'active' : 'passive')
                            
                                if !len(a:filetypes)
                                    if exists('b:syntastic_mode') && (b:syntastic_mode ==# 'active' || b:syntastic_mode ==# 'passive')
                                        echomsg 'Local mode: ' . b:syntastic_mode
                                    endif
                            
                                    echomsg 'The current file will ' . (self.doAutoChecking() ? '' : 'not ') . 'be checked automatically'
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticModeMap._isOneFiletypeActive(filetypes) abort " {{{2
                                return !empty(filter(copy(a:filetypes), 'index(self._activeFiletypes, v:val) != -1'))
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap._noFiletypesArePassive(filetypes) abort " {{{2
                                return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
Sourced 2 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifiers') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000002 let g:loaded_syntastic_notifiers = 1
                            
    1              0.000002 let g:SyntasticNotifiers = {}
                            
    1              0.000005 let s:_NOTIFIER_TYPES = ['signs', 'balloons', 'highlighting', 'cursor', 'autoloclist']
    1              0.000002 lockvar! s:_NOTIFIER_TYPES
                            
    1              0.000003 let s:_PERSISTENT_NOTIFIERS = ['signs', 'balloons']
    1              0.000002 lockvar! s:_PERSISTENT_NOTIFIERS
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticNotifiers.Instance() abort " {{{2
                                if !exists('s:SyntasticNotifiersInstance')
                                    let s:SyntasticNotifiersInstance = copy(self)
                                    call s:SyntasticNotifiersInstance._initNotifiers()
                                endif
                            
                                return s:SyntasticNotifiersInstance
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticNotifiers.refresh(loclist) abort " {{{2
                                if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
                                for type in self._enabled_types
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                                    if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
                                        if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
                                            if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
                                            if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
                                                call self._notifier[type].refresh(a:loclist)
                                                let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
                                            endif
                                        else
                                            call self._notifier[type].refresh(a:loclist)
                                        endif
                                    endif
                                endfor
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticNotifiers.reset(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
                                for type in self._enabled_types
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
                                    if has_key(g:{class}, 'reset')
                                        call self._notifier[type].reset(a:loclist)
                                    endif
                            
                                    " also reset stamps
                                    if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                        let b:syntastic_private_{type}_stamp = []
                                    endif
                                endfor
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticNotifiers._initNotifiers() abort " {{{2
                                let self._notifier = {}
                                for type in s:_NOTIFIER_TYPES
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                                    let self._notifier[type] = g:{class}.New()
                                endfor
                            
                                let self._enabled_types = copy(s:_NOTIFIER_TYPES)
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/registry.vim
Sourced 2 times
Total time:   0.000438
 Self time:   0.000438

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_registry') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000003 let g:loaded_syntastic_registry = 1
                            
                            " Initialisation {{{1
                            
    1              0.000130 let s:_DEFAULT_CHECKERS = {
                                    \ 'actionscript':  ['mxmlc'],
                                    \ 'ada':           ['gcc'],
                                    \ 'ansible':       ['ansible_lint'],
                                    \ 'apiblueprint':  ['drafter'],
                                    \ 'applescript':   ['osacompile'],
                                    \ 'asciidoc':      ['asciidoc'],
                                    \ 'asm':           ['gcc'],
                                    \ 'bro':           ['bro'],
                                    \ 'bemhtml':       ['bemhtmllint'],
                                    \ 'c':             ['gcc'],
                                    \ 'cabal':         ['cabal'],
                                    \ 'chef':          ['foodcritic'],
                                    \ 'co':            ['coco'],
                                    \ 'cobol':         ['cobc'],
                                    \ 'coffee':        ['coffee', 'coffeelint'],
                                    \ 'coq':           ['coqtop'],
                                    \ 'cpp':           ['gcc'],
                                    \ 'cs':            ['mcs'],
                                    \ 'css':           ['csslint'],
                                    \ 'cucumber':      ['cucumber'],
                                    \ 'cuda':          ['nvcc'],
                                    \ 'd':             ['dmd'],
                                    \ 'dart':          ['dartanalyzer'],
                                    \ 'docbk':         ['xmllint'],
                                    \ 'dockerfile':    ['dockerfile_lint'],
                                    \ 'dustjs':        ['swiffer'],
                                    \ 'elixir':        [],
                                    \ 'erlang':        ['escript'],
                                    \ 'eruby':         ['ruby'],
                                    \ 'fortran':       ['gfortran'],
                                    \ 'glsl':          ['cgc'],
                                    \ 'go':            [],
                                    \ 'haml':          ['haml'],
                                    \ 'handlebars':    ['handlebars'],
                                    \ 'haskell':       ['hdevtools', 'hlint'],
                                    \ 'haxe':          ['haxe'],
                                    \ 'hss':           ['hss'],
                                    \ 'html':          ['tidy'],
                                    \ 'jade':          ['jade_lint'],
                                    \ 'java':          ['javac'],
                                    \ 'javascript':    ['jshint', 'jslint'],
                                    \ 'json':          ['jsonlint', 'jsonval'],
                                    \ 'less':          ['lessc'],
                                    \ 'lex':           ['flex'],
                                    \ 'limbo':         ['limbo'],
                                    \ 'lisp':          ['clisp'],
                                    \ 'llvm':          ['llvm'],
                                    \ 'lua':           ['luac'],
                                    \ 'markdown':      ['mdl'],
                                    \ 'matlab':        ['mlint'],
                                    \ 'mercury':       ['mmc'],
                                    \ 'nasm':          ['nasm'],
                                    \ 'nix':           ['nix'],
                                    \ 'nroff':         ['mandoc'],
                                    \ 'objc':          ['gcc'],
                                    \ 'objcpp':        ['gcc'],
                                    \ 'ocaml':         ['camlp4o'],
                                    \ 'perl':          ['perlcritic'],
                                    \ 'php':           ['php', 'phpcs', 'phpmd'],
                                    \ 'po':            ['msgfmt'],
                                    \ 'pod':           ['podchecker'],
                                    \ 'puppet':        ['puppet', 'puppetlint'],
                                    \ 'pug':           ['pug_lint'],
                                    \ 'python':        ['python', 'flake8', 'pylint'],
                                    \ 'qml':           ['qmllint'],
                                    \ 'r':             [],
                                    \ 'rmd':           [],
                                    \ 'racket':        ['racket'],
                                    \ 'rnc':           ['rnv'],
                                    \ 'rst':           ['rst2pseudoxml'],
                                    \ 'ruby':          ['mri'],
                                    \ 'sass':          ['sass'],
                                    \ 'scala':         ['fsc', 'scalac'],
                                    \ 'scss':          ['sass', 'scss_lint'],
                                    \ 'sh':            ['sh', 'shellcheck'],
                                    \ 'slim':          ['slimrb'],
                                    \ 'sml':           ['smlnj'],
                                    \ 'spec':          ['rpmlint'],
                                    \ 'sql':           ['sqlint'],
                                    \ 'stylus':        ['stylint'],
                                    \ 'tcl':           ['nagelfar'],
                                    \ 'tex':           ['lacheck', 'chktex'],
                                    \ 'texinfo':       ['makeinfo'],
                                    \ 'text':          [],
                                    \ 'trig':          ['rapper'],
                                    \ 'turtle':        ['rapper'],
                                    \ 'twig':          ['twiglint'],
                                    \ 'typescript':    ['tsc'],
                                    \ 'vala':          ['valac'],
                                    \ 'verilog':       ['verilator'],
                                    \ 'vhdl':          ['ghdl'],
                                    \ 'vim':           ['vimlint'],
                                    \ 'xhtml':         ['tidy'],
                                    \ 'xml':           ['xmllint'],
                                    \ 'xslt':          ['xmllint'],
                                    \ 'xquery':        ['basex'],
                                    \ 'yacc':          ['bison'],
                                    \ 'yaml':          ['jsyaml'],
                                    \ 'yang':          ['pyang'],
                                    \ 'z80':           ['z80syntaxchecker'],
                                    \ 'zpt':           ['zptlint'],
                                    \ 'zsh':           ['zsh'],
                                \ }
    1              0.000005 lockvar! s:_DEFAULT_CHECKERS
                            
    1              0.000011 let s:_DEFAULT_FILETYPE_MAP = {
                                    \ 'gentoo-metadata': 'xml',
                                    \ 'groff': 'nroff',
                                    \ 'lhaskell': 'haskell',
                                    \ 'litcoffee': 'coffee',
                                    \ 'mail': 'text',
                                    \ 'mkd': 'markdown',
                                    \ 'pe-puppet': 'puppet',
                                    \ 'sgml': 'docbk',
                                    \ 'sgmllnx': 'docbk',
                                \ }
    1              0.000002 lockvar! s:_DEFAULT_FILETYPE_MAP
                            
    1              0.000006 let s:_ECLIM_TYPES = [
                                    \ 'c',
                                    \ 'cpp',
                                    \ 'html',
                                    \ 'java',
                                    \ 'php',
                                    \ 'python',
                                    \ 'ruby',
                                \ ]
    1              0.000002 lockvar! s:_ECLIM_TYPES
                            
    1              0.000004 let s:_YCM_TYPES = [
                                    \ 'c',
                                    \ 'cpp',
                                    \ 'objc',
                                    \ 'objcpp',
                                \ ]
    1              0.000002 lockvar! s:_YCM_TYPES
                            
    1              0.000002 let g:SyntasticRegistry = {}
                            
                            " }}}1
                            
                            " Public methods {{{1
                            
                            " Note: Handling of filetype aliases: all public methods take aliases as
                            " parameters, all private methods take normalized filetypes.  Public methods
                            " are thus supposed to normalize filetypes before calling private methods.
                            
    1              0.000001 function! g:SyntasticRegistry.Instance() abort " {{{2
                                if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
                                return s:SyntasticRegistryInstance
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry.CreateAndRegisterChecker(args) abort " {{{2
                                let registry = g:SyntasticRegistry.Instance()
                            
                                if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft, 1)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
                                else
                                    let checker = g:SyntasticChecker.New(a:args)
                                endif
                                call registry._registerChecker(checker)
                            endfunction " }}}2
                            
                            " Given a list of checker names hints_list, return a map name --> checker.
                            " If hints_list is empty, user settings are are used instead. Checkers are
                            " not checked for availability (that is, the corresponding IsAvailable() are
                            " not run).
    1              0.000002 function! g:SyntasticRegistry.getCheckers(ftalias, hints_list) abort " {{{2
                                let ft = s:_normalise_filetype(a:ftalias)
                                call self._loadCheckersFor(ft, 0)
                            
                                let checkers_map = self._checkerMap[ft]
                                if empty(checkers_map)
                                    return []
                                endif
                            
                                call self._checkDeprecation(ft)
                            
                                let names =
                                    \ !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) :
                                    \ exists('b:syntastic_checkers') ? b:syntastic_checkers :
                                    \ exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers :
                                    \ get(s:_DEFAULT_CHECKERS, ft, 0)
                            
                                return type(names) == type([]) ?
                                    \ self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]
                            endfunction " }}}2
                            
                            " Same as getCheckers(), but keep only the available checkers.  This runs the
                            " corresponding IsAvailable() functions for all checkers.
    1              0.000002 function! g:SyntasticRegistry.getCheckersAvailable(ftalias, hints_list) abort " {{{2
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isAvailable()')
                            endfunction " }}}2
                            
                            " Same as getCheckers(), but keep only the checkers that are available and
                            " disabled.  This runs the corresponding IsAvailable() functions for all checkers.
    1              0.000002 function! g:SyntasticRegistry.getCheckersDisabled(ftalias, hints_list) abort " {{{2
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isDisabled() && v:val.isAvailable()')
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticRegistry.getKnownFiletypes() abort " {{{2
                                let types = keys(s:_DEFAULT_CHECKERS)
                            
                                call extend(types, keys(s:_DEFAULT_FILETYPE_MAP))
                            
                                if exists('g:syntastic_filetype_map')
                                    call extend(types, keys(g:syntastic_filetype_map))
                                endif
                            
                                if exists('g:syntastic_extra_filetypes') && type(g:syntastic_extra_filetypes) == type([])
                                    call extend(types, g:syntastic_extra_filetypes)
                                endif
                            
                                return syntastic#util#unique(types)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry.getNamesOfAvailableCheckers(ftalias) abort " {{{2
                                let ft = s:_normalise_filetype(a:ftalias)
                                call self._loadCheckersFor(ft, 0)
                                return keys(filter( copy(self._checkerMap[ft]), 'v:val.isAvailable()' ))
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry.echoInfoFor(ftalias_list) abort " {{{2
                                let ft_list = syntastic#util#unique(map( copy(a:ftalias_list), 's:_normalise_filetype(v:val)' ))
                                if len(ft_list) != 1
                                    let available = []
                                    let active = []
                                    let disabled = []
                            
                                    for ft in ft_list
                                        call extend(available, map( self.getNamesOfAvailableCheckers(ft), 'ft . "/" . v:val' ))
                                        call extend(active, map( self.getCheckersAvailable(ft, []), 'ft . "/" . v:val.getName()' ))
                                        call extend(disabled, map( self.getCheckersDisabled(ft, []), 'ft . "/" . v:val.getName()' ))
                                    endfor
                                else
                                    let ft = ft_list[0]
                                    let available = self.getNamesOfAvailableCheckers(ft)
                                    let active = map(self.getCheckersAvailable(ft, []), 'v:val.getName()')
                                    let disabled = map(self.getCheckersDisabled(ft, []), 'v:val.getName()')
                                endif
                            
                                let cnt = len(available)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(sort(available)) : '-'
                                echomsg 'Available checker' . plural . ': ' . cklist
                            
                                let cnt = len(active)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(active) : '-'
                                echomsg 'Currently enabled checker' . plural . ': ' . cklist
                            
                                let cnt = len(disabled)
                                let plural = cnt != 1 ? 's' : ''
                                if len(disabled)
                                    let cklist = join(sort(disabled))
                                    echomsg 'Checker' . plural . ' disabled for security reasons: ' . cklist
                                endif
                            
                                " Eclim feels entitled to mess with syntastic's variables {{{3
                                if exists(':EclimValidate') && get(g:, 'EclimFileTypeValidate', 1)
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_eclim(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by Eclim'
                                    endif
                                endif
                                " }}}3
                            
                                " So does YouCompleteMe {{{3
                                if exists('g:loaded_youcompleteme') && get(g:, 'ycm_show_diagnostics_ui', get(g:, 'ycm_register_as_syntastic_checker', 1))
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_ycm(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by YouCompleteMe'
                                    endif
                                endif
                                " }}}3
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticRegistry._registerChecker(checker) abort " {{{2
                                let ft = a:checker.getFiletype()
                                if !has_key(self._checkerMap, ft)
                                    let self._checkerMap[ft] = {}
                                endif
                            
                                let name = a:checker.getName()
                                if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
                                let self._checkerMap[ft][name] = a:checker
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry._filterCheckersByName(checkers_map, list) abort " {{{2
                                return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry._loadCheckersFor(filetype, force) abort " {{{2
                                if !a:force && has_key(self._checkerMap, a:filetype)
                                    return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif
                            endfunction " }}}2
                            
                            " Check for obsolete variable g:syntastic_<filetype>_checker
    1              0.000004 function! g:SyntasticRegistry._checkDeprecation(filetype) abort " {{{2
                                if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
                            "resolve filetype aliases, and replace - with _ otherwise we cant name
                            "syntax checker functions legally for filetypes like "gentoo-metadata"
    1              0.000003 function! s:_normalise_filetype(ftalias) abort " {{{2
                                let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
                                let ft = get(g:syntastic_filetype_map, ft, ft)
                                let ft = substitute(ft, '\m-', '_', 'g')
                                return ft
                            endfunction " }}}2
                            
    1              0.000002 function! s:_disabled_by_eclim(filetype) abort " {{{2
                                if index(s:_ECLIM_TYPES, a:filetype) >= 0
                                    let lang = toupper(a:filetype[0]) . a:filetype[1:]
                                    let ft = a:filetype !=# 'cpp' ? lang : 'C'
                                    return get(g:, 'Eclim' . lang . 'Validate', 1) && !get(g:, 'Eclim' . ft . 'SyntasticEnabled', 0)
                                endif
                            
                                return 0
                            endfunction " }}}2
                            
    1              0.000002 function! s:_disabled_by_ycm(filetype) abort " {{{2
                                return index(s:_YCM_TYPES, a:filetype) >= 0
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic/signs.vim
Sourced 2 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_signs') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
                            endif
    1              0.000003 let g:loaded_syntastic_notifier_signs = 1
                            
                            " Initialisation {{{1
                            
                            " start counting sign ids at 5000, start here to hopefully avoid conflicting
                            " with any other code that places signs (not sure if this precaution is
                            " actually needed)
    1              0.000002 let s:first_sign_id = 5000
    1              0.000003 let s:next_sign_id = s:first_sign_id
                            
    1              0.000005 let g:SyntasticSignsNotifier = {}
                            
    1              0.000002 let s:setup_done = 0
                            
                            " }}}1
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticSignsNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticSignsNotifier.enabled() abort " {{{2
                                return has('signs') && syntastic#util#var('enable_signs')
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticSignsNotifier.refresh(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
                                let old_signs = copy(self._bufSignIds())
                                if self.enabled()
                                    if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
                                    call self._signErrors(a:loclist)
                                endif
                                call self._removeSigns(old_signs)
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
                            " One time setup: define our own sign types and highlighting
    1              0.000001 function! g:SyntasticSignsNotifier._setup() abort " {{{2
                                if has('signs')
                                    if !hlexists('SyntasticErrorSign')
                                        highlight link SyntasticErrorSign error
                                    endif
                                    if !hlexists('SyntasticWarningSign')
                                        highlight link SyntasticWarningSign todo
                                    endif
                                    if !hlexists('SyntasticStyleErrorSign')
                                        highlight link SyntasticStyleErrorSign SyntasticErrorSign
                                    endif
                                    if !hlexists('SyntasticStyleWarningSign')
                                        highlight link SyntasticStyleWarningSign SyntasticWarningSign
                                    endif
                                    if !hlexists('SyntasticStyleErrorLine')
                                        highlight link SyntasticStyleErrorLine SyntasticErrorLine
                                    endif
                                    if !hlexists('SyntasticStyleWarningLine')
                                        highlight link SyntasticStyleWarningLine SyntasticWarningLine
                                    endif
                            
                                    " define the signs used to display syntax and style errors/warns
                                    execute 'sign define SyntasticError text=' . g:syntastic_error_symbol .
                                        \ ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
                                    execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol .
                                        \ ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
                                    execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol .
                                        \ ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
                                    execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol .
                                        \ ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
                                endif
                            endfunction " }}}2
                            
                            " Place signs by all syntax errors in the buffer
    1              0.000002 function! g:SyntasticSignsNotifier._signErrors(loclist) abort " {{{2
                                let loclist = a:loclist
                                if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Remove the signs with the given ids from this buffer
    1              0.000002 function! g:SyntasticSignsNotifier._removeSigns(ids) abort " {{{2
                                if has('signs')
                                    for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Get all the ids of the SyntaxError signs in the buffer
    1              0.000001 function! g:SyntasticSignsNotifier._bufSignIds() abort " {{{2
                                if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
                                return b:syntastic_private_sign_ids
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/plugin/syntastic.vim
Sourced 1 time
Total time:   0.030434
 Self time:   0.002235

count  total (s)   self (s)
                            "============================================================================
                            "File:        syntastic.vim
                            "Description: Vim plugin for on the fly syntax checking.
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000005 if exists('g:loaded_syntastic_plugin') || &compatible
                                finish
                            endif
    1              0.000003 let g:loaded_syntastic_plugin = 1
                            
    1              0.000003 if has('reltime')
    1              0.000007     let g:_SYNTASTIC_START = reltime()
    1              0.000002     lockvar! g:_SYNTASTIC_START
    1              0.000001 endif
                            
    1              0.000002 let g:_SYNTASTIC_VERSION = '3.7.0-140'
    1              0.000002 lockvar g:_SYNTASTIC_VERSION
                            
                            " Sanity checks {{{1
                            
    1              0.000003 if v:version < 700 || (v:version == 700 && !has('patch175'))
                                call syntastic#log#error('need Vim version 7.0.175 or later')
                                finish
                            endif
                            
    1              0.000008 for s:feature in [
                                        \ 'autocmd',
                                        \ 'eval',
                                        \ 'file_in_path',
                                        \ 'modify_fname',
                                        \ 'quickfix',
                                        \ 'reltime',
                                        \ 'user_commands'
    7              0.000009         \ ]
    7              0.000016     if !has(s:feature)
                                    call syntastic#log#error('need Vim compiled with feature ' . s:feature)
                                    finish
                                endif
    7              0.000003 endfor
                            
    1              0.000056 let s:_running_windows = syntastic#util#isRunningWindows()
    1              0.000002 lockvar s:_running_windows
                            
    1              0.000003 if !exists('g:syntastic_shell')
    1              0.000003     let g:syntastic_shell = &shell
    1              0.000001 endif
                            
    1              0.000002 if s:_running_windows
                                let g:_SYNTASTIC_UNAME = 'Windows'
                            elseif executable('uname')
    1              0.000002     try
    1   0.025437   0.000031         let g:_SYNTASTIC_UNAME = split(syntastic#util#system('uname'), "\n")[0]
    1              0.000006     catch /\m^Vim\%((\a\+)\)\=:E484/
                                    call syntastic#log#error("your shell " .  syntastic#util#var('shell') . " can't handle traditional UNIX syntax for redirections")
                                    finish
                                catch /\m^Vim\%((\a\+)\)\=:E684/
                                    let g:_SYNTASTIC_UNAME = 'Unknown'
                                endtry
    1              0.000001 else
                                let g:_SYNTASTIC_UNAME = 'Unknown'
                            endif
    1              0.000003 lockvar g:_SYNTASTIC_UNAME
                            
                            " }}}1
                            
                            " Defaults {{{1
                            
    1              0.000047 let g:_SYNTASTIC_DEFAULTS = {
                                    \ 'aggregate_errors':         0,
                                    \ 'always_populate_loc_list': 0,
                                    \ 'auto_jump':                0,
                                    \ 'auto_loc_list':            2,
                                    \ 'check_on_open':            0,
                                    \ 'check_on_wq':              1,
                                    \ 'cursor_columns':           1,
                                    \ 'debug':                    0,
                                    \ 'echo_current_error':       1,
                                    \ 'enable_balloons':          1,
                                    \ 'enable_highlighting':      1,
                                    \ 'enable_signs':             1,
                                    \ 'error_symbol':             '>>',
                                    \ 'exit_checks':              !(s:_running_windows && syntastic#util#var('shell', &shell) =~? '\m\<cmd\.exe$'),
                                    \ 'filetype_map':             {},
                                    \ 'full_redraws':             !(has('gui_running') || has('gui_macvim')),
                                    \ 'id_checkers':              1,
                                    \ 'ignore_extensions':        '\c\v^([gx]?z|lzma|bz2)$',
                                    \ 'ignore_files':             [],
                                    \ 'loc_list_height':          10,
                                    \ 'nested_autocommands':      0,
                                    \ 'quiet_messages':           {},
                                    \ 'reuse_loc_lists':          1,
                                    \ 'shell':                    &shell,
                                    \ 'sort_aggregated_errors':   1,
                                    \ 'stl_format':               '[Syntax: line:%F (%t)]',
                                    \ 'style_error_symbol':       'S>',
                                    \ 'style_warning_symbol':     'S>',
                                    \ 'warning_symbol':           '>>'
                                \ }
    1              0.000006 lockvar! g:_SYNTASTIC_DEFAULTS
                            
   30              0.000050 for s:key in keys(g:_SYNTASTIC_DEFAULTS)
   29              0.000084     if !exists('g:syntastic_' . s:key)
   23              0.000120         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
   23              0.000019     endif
   29              0.000015 endfor
                            
    1              0.000003 if exists('g:syntastic_quiet_warnings')
                                call syntastic#log#oneTimeWarn("variable g:syntastic_quiet_warnings is deprecated, please use let g:syntastic_quiet_messages = {'level': 'warnings'} instead")
                                if g:syntastic_quiet_warnings
                                    let s:quiet_warnings = get(g:syntastic_quiet_messages, 'type', [])
                                    if type(s:quiet_warnings) != type([])
                                        let s:quiet_warnings = [s:quiet_warnings]
                                    endif
                                    call add(s:quiet_warnings, 'warnings')
                                    let g:syntastic_quiet_messages['type'] = s:quiet_warnings
                                endif
                            endif
                            
                            " }}}1
                            
                            " Debug {{{1
                            
    1              0.000008 let s:_DEBUG_DUMP_OPTIONS = [
                                    \ 'shell',
                                    \ 'shellcmdflag',
                                    \ 'shellpipe',
                                    \ 'shellquote',
                                    \ 'shellredir',
                                    \ 'shellslash',
                                    \ 'shelltemp',
                                    \ 'shellxquote'
                                \ ]
    1              0.000004 if exists('+shellxescape')
    1              0.000004     call add(s:_DEBUG_DUMP_OPTIONS, 'shellxescape')
    1              0.000001 endif
    1              0.000002 lockvar! s:_DEBUG_DUMP_OPTIONS
                            
                            " debug constants
    1              0.000003 let     g:_SYNTASTIC_DEBUG_TRACE         = 1
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_TRACE
    1              0.000002 let     g:_SYNTASTIC_DEBUG_LOCLIST       = 2
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_LOCLIST
    1              0.000002 let     g:_SYNTASTIC_DEBUG_NOTIFICATIONS = 4
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_NOTIFICATIONS
    1              0.000002 let     g:_SYNTASTIC_DEBUG_AUTOCOMMANDS  = 8
    1              0.000001 lockvar g:_SYNTASTIC_DEBUG_AUTOCOMMANDS
    1              0.000002 let     g:_SYNTASTIC_DEBUG_VARIABLES     = 16
    1              0.000007 lockvar g:_SYNTASTIC_DEBUG_VARIABLES
    1              0.000002 let     g:_SYNTASTIC_DEBUG_CHECKERS      = 32
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_CHECKERS
                            
                            " }}}1
                            
    1              0.000323 runtime! plugin/syntastic/*.vim
                            
    1   0.000029   0.000011 let s:registry = g:SyntasticRegistry.Instance()
    1   0.000230   0.000006 let s:notifiers = g:SyntasticNotifiers.Instance()
    1   0.000043   0.000007 let s:modemap = g:SyntasticModeMap.Instance()
                            
    1              0.000002 let s:_quit_pre = []
                            
                            " Commands {{{1
                            
                            " @vimlint(EVL103, 1, a:cursorPos)
                            " @vimlint(EVL103, 1, a:cmdLine)
                            " @vimlint(EVL103, 1, a:argLead)
    1              0.000003 function! s:CompleteCheckerName(argLead, cmdLine, cursorPos) abort " {{{2
                                let checker_names = []
                                for ft in s:_resolve_filetypes([])
                                    call extend(checker_names, s:registry.getNamesOfAvailableCheckers(ft))
                                endfor
                                return join(checker_names, "\n")
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:cursorPos)
                            " @vimlint(EVL103, 0, a:cmdLine)
                            " @vimlint(EVL103, 0, a:argLead)
                            
                            
                            " @vimlint(EVL103, 1, a:cursorPos)
                            " @vimlint(EVL103, 1, a:cmdLine)
                            " @vimlint(EVL103, 1, a:argLead)
    1              0.000003 function! s:CompleteFiletypes(argLead, cmdLine, cursorPos) abort " {{{2
                                return join(s:registry.getKnownFiletypes(), "\n")
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:cursorPos)
                            " @vimlint(EVL103, 0, a:cmdLine)
                            " @vimlint(EVL103, 0, a:argLead)
                            
    1              0.000011 command! -bar -nargs=* -complete=custom,s:CompleteCheckerName SyntasticCheck call SyntasticCheck(<f-args>)
    1              0.000006 command! -bar -nargs=? -complete=custom,s:CompleteFiletypes   SyntasticInfo  call SyntasticInfo(<f-args>)
    1              0.000008 command! -bar Errors              call SyntasticErrors()
    1              0.000005 command! -bar SyntasticReset      call SyntasticReset()
    1              0.000006 command! -bar SyntasticToggleMode call SyntasticToggleMode()
    1              0.000005 command! -bar SyntasticSetLoclist call SyntasticSetLoclist()
                            
    1              0.000010 command! SyntasticJavacEditClasspath runtime! syntax_checkers/java/*.vim | SyntasticJavacEditClasspath
    1              0.000010 command! SyntasticJavacEditConfig    runtime! syntax_checkers/java/*.vim | SyntasticJavacEditConfig
                            
                            " }}}1
                            
                            " Public API {{{1
                            
    1              0.000002 function! SyntasticCheck(...) abort " {{{2
                                call s:UpdateErrors(0, a:000)
                                call syntastic#util#redraw(g:syntastic_full_redraws)
                            endfunction " }}}2
                            
    1              0.000001 function! SyntasticInfo(...) abort " {{{2
                                call s:modemap.modeInfo(a:000)
                                call s:registry.echoInfoFor(s:_resolve_filetypes(a:000))
                                call s:_explain_skip(a:000)
                            endfunction " }}}2
                            
    1              0.000001 function! SyntasticErrors() abort " {{{2
                                call g:SyntasticLoclist.current().show()
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticReset() abort " {{{2
                                call s:ClearCache()
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticToggleMode() abort " {{{2
                                call s:modemap.toggleMode()
                                call s:ClearCache()
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                                call s:modemap.echoMode()
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticSetLoclist() abort " {{{2
                                call g:SyntasticLoclist.current().setloclist()
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Autocommands {{{1
                            
    1              0.000002 augroup syntastic
    1              0.000160     autocmd!
    1              0.000008     autocmd BufEnter * call s:BufEnterHook()
    1              0.000001 augroup END
                            
    1              0.000002 if g:syntastic_nested_autocommands
                                augroup syntastic
                                    autocmd BufReadPost  * nested call s:BufReadPostHook()
                                    autocmd BufWritePost * nested call s:BufWritePostHook()
                                augroup END
                            else
    1              0.000006     augroup syntastic
    1              0.000020         autocmd BufReadPost  * call s:BufReadPostHook()
    1              0.000004         autocmd BufWritePost * call s:BufWritePostHook()
    1              0.000001     augroup END
    1              0.000001 endif
                            
    1              0.000003 if exists('##QuitPre')
                                " QuitPre was added in Vim 7.3.544
    1              0.000002     augroup syntastic
    1              0.000006         autocmd QuitPre * call s:QuitPreHook(expand('<amatch>', 1))
    1              0.000002     augroup END
    1              0.000001 endif
                            
    1              0.000003 function! s:BufReadPostHook() abort " {{{2
                                if g:syntastic_check_on_open
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                        \ 'autocmd: BufReadPost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
                                    call s:UpdateErrors(1, [])
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:BufWritePostHook() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: BufWritePost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
                                call s:UpdateErrors(1, [])
                            endfunction " }}}2
                            
    1              0.000002 function! s:BufEnterHook() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: BufEnter, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))) .
                                    \ ', &buftype = ' . string(&buftype))
                                if &buftype ==# ''
                                    call s:notifiers.refresh(g:SyntasticLoclist.current())
                                elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
                                    let owner = str2nr(getbufvar(bufnr(''), 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! s:QuitPreHook(fname) abort " {{{2
                                let buf = bufnr(fnameescape(a:fname))
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
                                if !syntastic#util#var('check_on_wq')
                                    call syntastic#util#setWids()
                                    call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
                                endif
                            
                                if !empty(get(w:, 'syntastic_loclist_set', []))
                                    call SyntasticLoclistHide()
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Main {{{1
                            
                            "refresh and redraw all the error info for this buf when saving or reading
    1              0.000002 function! s:UpdateErrors(auto_invoked, checker_names) abort " {{{2
                                call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
                                call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
                                call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') .
                                    \ ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
                                call s:modemap.synch()
                            
                                if s:_skip_file()
                                    return
                                endif
                            
                                let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
                                if run_checks
                                    call s:CacheErrors(a:checker_names)
                                    call syntastic#util#setChangedtick()
                                else
                                    if a:auto_invoked
                                        return
                                    endif
                                endif
                            
                                let loclist = g:SyntasticLoclist.current()
                            
                                if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
                                let do_jump = syntastic#util#var('auto_jump') + 0
                                if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
                                let w:syntastic_loclist_set = []
                                if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
                                    call setloclist(0, loclist.getRaw())
                                    if !exists('b:syntastic_changedtick')
                                        call syntastic#util#setChangedtick()
                                    endif
                                    let w:syntastic_loclist_set = [bufnr(''), b:syntastic_changedtick]
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
                                call s:notifiers.refresh(loclist)
                            endfunction " }}}2
                            
                            "clear the loc list for the buffer
    1              0.000002 function! s:ClearCache() abort " {{{2
                                call s:notifiers.reset(g:SyntasticLoclist.current())
                                call b:syntastic_loclist.destroy()
                            endfunction " }}}2
                            
                            "detect and cache all syntax errors in this buffer
    1              0.000003 function! s:CacheErrors(checker_names) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' .
                                    \ (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                                call s:ClearCache()
                                let newLoclist = g:SyntasticLoclist.New([])
                            
                                if !s:_skip_file()
                                    " debug logging {{{3
                                    call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
                                    let filetypes = s:_resolve_filetypes([])
                                    let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
                                    let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
                                    let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
                                    let clist = []
                                    for type in filetypes
                                        call extend(clist, s:registry.getCheckers(type, a:checker_names))
                                    endfor
                            
                                    let names = []
                                    let unavailable_checkers = 0
                                    for checker in clist
                                        let cname = checker.getFiletype() . '/' . checker.getName()
                                        if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
                                    if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
                                    if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
                                    if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
                                endif
                            
                                call newLoclist.deploy()
                            endfunction " }}}2
                            
                            "Emulates the :lmake command. Sets up the make environment according to the
                            "options given, runs make, resets the environment, returns the location list
                            "
                            "a:options can contain the following keys:
                            "    'makeprg'
                            "    'errorformat'
                            "
                            "The corresponding options are set for the duration of the function call. They
                            "are set with :let, so dont escape spaces.
                            "
                            "a:options may also contain:
                            "   'defaults' - a dict containing default values for the returned errors
                            "   'subtype' - all errors will be assigned the given subtype
                            "   'preprocess' - a function to be applied to the error file before parsing errors
                            "   'postprocess' - a list of functions to be applied to the error list
                            "   'cwd' - change directory to the given path before running the checker
                            "   'env' - environment variables to set before running the checker
                            "   'returns' - a list of valid exit codes for the checker
                            " @vimlint(EVL102, 1, l:env_save)
    1              0.000002 function! SyntasticMake(options) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
                                let old_local_errorformat = &l:errorformat
                                let old_errorformat = &errorformat
                                let old_cwd = getcwd()
                                " }}}3
                            
                                if has_key(a:options, 'errorformat')
                                    let &errorformat = a:options['errorformat']
                                    set errorformat<
                                endif
                            
                                if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
                                let env_save = {}
                                if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_]\+$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
                                let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
                                if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
                                let bailout =
                                    \ syntastic#util#var('exit_checks') &&
                                    \ has_key(a:options, 'returns') &&
                                    \ index(a:options['returns'], v:shell_error) == -1
                            
                                if !bailout
                                    if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
                                    lgetexpr err_lines
                            
                                    let errors = deepcopy(getloclist(0))
                            
                                    if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
                                    try
                                        silent lolder
                                    catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
                                else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
                                let &errorformat = old_errorformat
                                let &l:errorformat = old_local_errorformat
                                " }}}3
                            
                                if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
                                if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
                                if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
                                if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
                                if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
                                return errors
                            endfunction " }}}2
                            " @vimlint(EVL102, 0, l:env_save)
                            
                            "return a string representing the state of buffer according to
                            "g:syntastic_stl_format
                            "
                            "return '' if no errors are cached for the buffer
    1              0.000002 function! SyntasticStatuslineFlag() abort " {{{2
                                return g:SyntasticLoclist.current().getStatuslineFlag()
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000003 function! s:_resolve_filetypes(filetypes) abort " {{{2
                                let type = len(a:filetypes) ? a:filetypes[0] : &filetype
                                return split( get(g:syntastic_filetype_map, type, type), '\m\.' )
                            endfunction " }}}2
                            
    1              0.000002 function! s:_ignore_file(filename) abort " {{{2
                                let fname = fnamemodify(a:filename, ':p')
                                for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
                                return 0
                            endfunction " }}}2
                            
    1              0.000012 function! s:_is_quitting(buf) abort " {{{2
                                let quitting = 0
                                if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
                                return quitting
                            endfunction " }}}2
                            
                            " Skip running in special buffers
    1              0.000002 function! s:_skip_file() abort " {{{2
                                let fname = expand('%', 1)
                                let skip = s:_is_quitting(bufnr('%')) || get(b:, 'syntastic_skip_checks', 0) ||
                                    \ (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') ||
                                    \ getwinvar(0, '&previewwindow') || s:_ignore_file(fname) ||
                                    \ fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
                                return skip
                            endfunction " }}}2
                            
                            " Explain why checks will be skipped for the current file
    1              0.000003 function! s:_explain_skip(filetypes) abort " {{{2
                                if empty(a:filetypes) && s:_skip_file()
                                    let why = []
                                    let fname = expand('%', 1)
                            
                                    if s:_is_quitting(bufnr('%'))
                                        call add(why, 'quitting buffer')
                                    endif
                                    if get(b:, 'syntastic_skip_checks', 0)
                                        call add(why, 'b:syntastic_skip_checks set')
                                    endif
                                    if &buftype !=# ''
                                        call add(why, 'buftype = ' . string(&buftype))
                                    endif
                                    if !filereadable(fname)
                                        call add(why, 'file not readable / not local')
                                    endif
                                    if getwinvar(0, '&diff')
                                        call add(why, 'diff mode')
                                    endif
                                    if getwinvar(0, '&previewwindow')
                                        call add(why, 'preview window')
                                    endif
                                    if s:_ignore_file(fname)
                                        call add(why, 'filename matching g:syntastic_ignore_files')
                                    endif
                                    if fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                        call add(why, 'extension matching g:syntastic_ignore_extensions')
                                    endif
                            
                                    echomsg 'The current file will not be checked (' . join(why, ', ') . ')'
                                endif
                            endfunction " }}}2
                            
                            " Take a list of errors and add default values to them from a:options
    1              0.000002 function! s:_add_to_errors(errors, options) abort " {{{2
                                for err in a:errors
                                    for key in keys(a:options)
                                        if !has_key(err, key) || empty(err[key])
                                            let err[key] = a:options[key]
                                        endif
                                    endfor
                                endfor
                            
                                return a:errors
                            endfunction " }}}2
                            
    1              0.000002 function! s:_os_name() abort " {{{2
                                return g:_SYNTASTIC_UNAME
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/syntastic/autoload/syntastic/util.vim
Sourced 1 time
Total time:   0.000558
 Self time:   0.000558

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_util_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
                            endif
    1              0.000003 let g:loaded_syntastic_util_autoload = 1
                            
    1              0.000004 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
                            " Public functions {{{1
                            
    1              0.000004 function! syntastic#util#isRunningWindows() abort " {{{2
                                return has('win16') || has('win32') || has('win64')
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#util#DevNull() abort " {{{2
                                if syntastic#util#isRunningWindows()
                                    return 'NUL'
                                endif
                                return '/dev/null'
                            endfunction " }}}2
                            
                            " Get directory separator
    1              0.000003 function! syntastic#util#Slash() abort " {{{2
                                return (!exists('+shellslash') || &shellslash) ? '/' : '\'
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#CygwinPath(path) abort " {{{2
                                return substitute(syntastic#util#system('cygpath -m ' . syntastic#util#shescape(a:path)), "\n", '', 'g')
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#system(command) abort " {{{2
                                let old_shell = &shell
                                let old_lc_messages = $LC_MESSAGES
                                let old_lc_all = $LC_ALL
                            
                                let &shell = syntastic#util#var('shell')
                                let $LC_MESSAGES = 'C'
                                let $LC_ALL = ''
                            
                                let cmd_start = reltime()
                                let out = system(a:command)
                                let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
                                let $LC_ALL = old_lc_all
                                let $LC_MESSAGES = old_lc_messages
                            
                                let &shell = old_shell
                            
                                if exists('g:_SYNTASTIC_DEBUG_TRACE')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
                                endif
                            
                                return out
                            endfunction " }}}2
                            
                            " Create a temporary directory
    1              0.000002 function! syntastic#util#tmpdir() abort " {{{2
                                let tempdir = ''
                            
                                if (has('unix') || has('mac')) && executable('mktemp') && !has('win32unix')
                                    " TODO: option "-t" to mktemp(1) is not portable
                                    let tmp = $TMPDIR !=# '' ? $TMPDIR : $TMP !=# '' ? $TMP : '/tmp'
                                    let out = split(syntastic#util#system('mktemp -q -d ' . tmp . '/vim-syntastic-' . getpid() . '-XXXXXXXX'), "\n")
                                    if v:shell_error == 0 && len(out) == 1
                                        let tempdir = out[0]
                                    endif
                                endif
                            
                                if tempdir ==# ''
                                    if has('win32') || has('win64')
                                        let tempdir = $TEMP . syntastic#util#Slash() . 'vim-syntastic-' . getpid()
                                    elseif has('win32unix')
                                        let tempdir = syntastic#util#CygwinPath('/tmp/vim-syntastic-'  . getpid())
                                    elseif $TMPDIR !=# ''
                                        let tempdir = $TMPDIR . '/vim-syntastic-' . getpid()
                                    else
                                        let tempdir = '/tmp/vim-syntastic-' . getpid()
                                    endif
                            
                                    try
                                        call mkdir(tempdir, 'p', 0700)
                                    catch /\m^Vim\%((\a\+)\)\=:E739/
                                        call syntastic#log#error(v:exception)
                                        let tempdir = '.'
                                    endtry
                                endif
                            
                                return tempdir
                            endfunction " }}}2
                            
                            " Recursively remove a directory
    1              0.000002 function! syntastic#util#rmrf(what) abort " {{{2
                                " try to make sure we don't delete directories we didn't create
                                if a:what !~? 'vim-syntastic-'
                                    return
                                endif
                            
                                if  getftype(a:what) ==# 'dir'
                                    call s:_delete(a:what, 'rf')
                                else
                                    silent! call delete(a:what)
                                endif
                            endfunction " }}}2
                            
                            " Search the first 5 lines of the file for a magic number and return a map
                            " containing the args and the executable
                            "
                            " e.g.
                            "
                            " #!/usr/bin/perl -f -bar
                            "
                            " returns
                            "
                            " {'exe': '/usr/bin/perl', 'args': ['-f', '-bar']}
    1              0.000003 function! syntastic#util#parseShebang() abort " {{{2
                                for lnum in range(1, 5)
                                    let line = getline(lnum)
                                    if line =~# '^#!'
                                        let line = substitute(line, '\v^#!\s*(\S+/env(\s+-\S+)*\s+)?', '', '')
                                        let exe = matchstr(line, '\m^\S*\ze')
                                        let args = split(matchstr(line, '\m^\S*\zs.*'))
                                        return { 'exe': exe, 'args': args }
                                    endif
                                endfor
                            
                                return { 'exe': '', 'args': [] }
                            endfunction " }}}2
                            
                            " Get the value of a Vim variable.  Allow local variables to override global ones.
    1              0.000002 function! syntastic#util#rawVar(name, ...) abort " {{{2
                                return get(b:, a:name, get(g:, a:name, a:0 > 0 ? a:1 : ''))
                            endfunction " }}}2
                            
                            " Get the value of a syntastic variable.  Allow local variables to override global ones.
    1              0.000003 function! syntastic#util#var(name, ...) abort " {{{2
                                return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)
                            endfunction " }}}2
                            
                            " Parse a version string.  Return an array of version components.
    1              0.000003 function! syntastic#util#parseVersion(version, ...) abort " {{{2
                                return map(split(matchstr( a:version, a:0 ? a:1 : '\v^\D*\zs\d+(\.\d+)+\ze' ), '\m\.'), 'str2nr(v:val)')
                            endfunction " }}}2
                            
                            " Verify that the 'installed' version is at least the 'required' version.
                            "
                            " 'installed' and 'required' must be arrays. If they have different lengths,
                            " the "missing" elements will be assumed to be 0 for the purposes of checking.
                            "
                            " See http://semver.org for info about version numbers.
    1              0.000003 function! syntastic#util#versionIsAtLeast(installed, required) abort " {{{2
                                return syntastic#util#compareLexi(a:installed, a:required) >= 0
                            endfunction " }}}2
                            
                            " Almost lexicographic comparison of two lists of integers. :) If lists
                            " have different lengths, the "missing" elements are assumed to be 0.
    1              0.000002 function! syntastic#util#compareLexi(a, b) abort " {{{2
                                for idx in range(max([len(a:a), len(a:b)]))
                                    let a_element = str2nr(get(a:a, idx, 0))
                                    let b_element = str2nr(get(a:b, idx, 0))
                                    if a_element != b_element
                                        return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0
                            endfunction " }}}2
                            
                            " strwidth() was added in Vim 7.3; if it doesn't exist, we use strlen()
                            " and hope for the best :)
    1              0.000009 let s:_width = function(exists('*strwidth') ? 'strwidth' : 'strlen')
    1              0.000002 lockvar s:_width
                            
    1              0.000003 function! syntastic#util#screenWidth(str, tabstop) abort " {{{2
                                let chunks = split(a:str, "\t", 1)
                                let width = s:_width(chunks[-1])
                                for c in chunks[:-2]
                                    let cwidth = s:_width(c)
                                    let width += cwidth + a:tabstop - cwidth % a:tabstop
                                endfor
                                return width
                            endfunction " }}}2
                            
                            " Print as much of a:msg as possible without "Press Enter" prompt appearing
    1              0.000003 function! syntastic#util#wideMsg(msg) abort " {{{2
                                let old_ruler = &ruler
                                let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
                                let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
                                let chunks = split(msg, "\t", 1)
                                let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
                                let msg = strpart(msg, 0, &columns - 1)
                            
                                set noruler noshowcmd
                                call syntastic#util#redraw(0)
                            
                                echo msg
                            
                                let &ruler = old_ruler
                                let &showcmd = old_showcmd
                            endfunction " }}}2
                            
                            " Check whether a buffer is loaded, listed, and not hidden
    1              0.000003 function! syntastic#util#bufIsActive(buffer) abort " {{{2
                                " convert to number, or hell breaks loose
                                let buf = str2nr(a:buffer)
                            
                                if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
                                for tab in range(1, tabpagenr('$'))
                                    if index(tabpagebuflist(tab), buf) >= 0
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction " }}}2
                            
                            " Start in directory a:where and walk up the parent folders until it finds a
                            " file named a:what; return path to that file
    1              0.000002 function! syntastic#util#findFileInParent(what, where) abort " {{{2
                                let old_suffixesadd = &suffixesadd
                                let &suffixesadd = ''
                                let file = findfile(a:what, escape(a:where, ' ') . ';')
                                let &suffixesadd = old_suffixesadd
                                return file
                            endfunction " }}}2
                            
                            " Start in directory a:where and walk up the parent folders until it finds a
                            " file matching a:what; return path to that file
    1              0.000003 function! syntastic#util#findGlobInParent(what, where) abort " {{{2
                                let here = fnamemodify(a:where, ':p')
                            
                                let root = syntastic#util#Slash()
                                if syntastic#util#isRunningWindows() && here[1] ==# ':'
                                    " The drive letter is an ever-green source of fun.  That's because
                                    " we don't care about running syntastic on Amiga these days. ;)
                                    let root = fnamemodify(root, ':p')
                                    let root = here[0] . root[1:]
                                endif
                            
                                let old = ''
                                while here !=# ''
                                    try
                                        " Vim 7.4.279 and later
                                        let p = globpath(here, a:what, 1, 1)
                                    catch /\m^Vim\%((\a\+)\)\=:E118/
                                        let p = split(globpath(here, a:what, 1), "\n")
                                    endtry
                            
                                    if !empty(p)
                                        return fnamemodify(p[0], ':p')
                                    elseif here ==? root || here ==? old
                                        break
                                    endif
                            
                                    let old = here
                            
                                    " we use ':h:h' rather than ':h' since ':p' adds a trailing '/'
                                    " if 'here' is a directory
                                    let here = fnamemodify(here, ':p:h:h')
                                endwhile
                            
                                return ''
                            endfunction " }}}2
                            
                            " Returns unique elements in a list
    1              0.000002 function! syntastic#util#unique(list) abort " {{{2
                                let seen = {}
                                let uniques = []
                                for e in a:list
                                    let k = string(e)
                                    if !has_key(seen, k)
                                        let seen[k] = 1
                                        call add(uniques, e)
                                    endif
                                endfor
                                return uniques
                            endfunction " }}}2
                            
                            " A less noisy shellescape()
    1              0.000002 function! syntastic#util#shescape(string) abort " {{{2
                                return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)
                            endfunction " }}}2
                            
                            " A less noisy shellescape(expand())
    1              0.000003 function! syntastic#util#shexpand(string, ...) abort " {{{2
                                return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))
                            endfunction " }}}2
                            
                            " Escape arguments
    1              0.000002 function! syntastic#util#argsescape(opt) abort " {{{2
                                if type(a:opt) == type('') && a:opt !=# ''
                                    return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
                                return []
                            endfunction " }}}2
                            
                            " Decode XML entities
    1              0.000002 function! syntastic#util#decodeXMLEntities(string) abort " {{{2
                                let str = a:string
                                let str = substitute(str, '\m&lt;', '<', 'g')
                                let str = substitute(str, '\m&gt;', '>', 'g')
                                let str = substitute(str, '\m&quot;', '"', 'g')
                                let str = substitute(str, '\m&apos;', "'", 'g')
                                let str = substitute(str, '\m&amp;', '\&', 'g')
                                return str
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#redraw(full) abort " {{{2
                                if a:full
                                    redraw!
                                else
                                    redraw
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#util#dictFilter(errors, filter) abort " {{{2
                                let rules = s:_translateFilter(a:filter)
                                " call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, "applying filter:", rules)
                                try
                                    call filter(a:errors, rules)
                                catch /\m^Vim\%((\a\+)\)\=:E/
                                    let msg = matchstr(v:exception, '\m^Vim\%((\a\+)\)\=:\zs.*')
                                    call syntastic#log#error('quiet_messages: ' . msg)
                                endtry
                            endfunction " }}}2
                            
                            " Return a [seconds, fractions] list of strings, representing the
                            " (hopefully high resolution) time since program start
    1              0.000002 function! syntastic#util#stamp() abort " {{{2
                                return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#setChangedtick() abort " {{{2
                                unlockvar! b:syntastic_changedtick
                                let b:syntastic_changedtick = b:changedtick
                                lockvar! b:syntastic_changedtick
                            endfunction " }}}2
                            
    1              0.000021 let s:_wid_base = 'syntastic_' . getpid() . '_' . reltimestr(g:_SYNTASTIC_START) . '_'
    1              0.000002 let s:_wid_pool = 0
                            
                            " Add unique IDs to windows
    1              0.000003 function! syntastic#util#setWids() abort " {{{2
                                for tab in range(1, tabpagenr('$'))
                                    for win in range(1, tabpagewinnr(tab, '$'))
                                        if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
                                            call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
                                            let s:_wid_pool += 1
                                        endif
                                    endfor
                                endfor
                            endfunction " }}}2
                            
    1              0.000008 let s:_str2float = function(exists('*str2float') ? 'str2float' : 'str2nr')
    1              0.000001 lockvar s:_str2float
                            
    1              0.000002 function! syntastic#util#str2float(val) abort " {{{2
                                return s:_str2float(a:val)
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#float2str(val) abort " {{{2
                                return s:_float2str(a:val)
                            endfunction " }}}2
                            
                            " Crude printf()-like width formatter.  Handles wide characters.
    1              0.000003 function! syntastic#util#wformat(format, str) abort " {{{2
                                if a:format ==# ''
                                    return a:str
                                endif
                            
                             echomsg string(a:format) . ', ' . string(a:str)
                                let specs = matchlist(a:format, '\v^(-?)(0?)(%([1-9]\d*))?%(\.(\d+))?$')
                                if len(specs) < 5
                                    return a:str
                                endif
                            
                                let flushleft = specs[1] ==# '-'
                                let lpad = specs[2] ==# '0' ? '0' : ' '
                                let minlen = str2nr(specs[3])
                                let maxlen = str2nr(specs[4])
                                let out = substitute(a:str, "\t", ' ', 'g')
                            
                                if maxlen && s:_width(out) > maxlen
                                    let chars = filter(split(out, '\zs\ze', 1), 'v:val !=# ""')
                                    let out = ''
                            
                                    if flushleft
                                        for c in chars
                                            if s:_width(out . c) < maxlen
                                                let out .= c
                                            else
                                                let out .= &encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '>'
                                                break
                                            endif
                                        endfor
                                    else
                                        call reverse(chars)
                                        for c in chars
                                            if s:_width(c . out) < maxlen
                                                let out = c . out
                                            else
                                                let out = (&encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '<') . out
                                                break
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if minlen && s:_width(out) < minlen
                                    if flushleft
                                        let out .= repeat(' ', minlen - s:_width(out))
                                    else
                                        let out = repeat(lpad, minlen - s:_width(out)) . out
                                    endif
                                endif
                            
                                return out
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000002 function! s:_translateFilter(filters) abort " {{{2
                                let conditions = []
                                for k in keys(a:filters)
                                    if type(a:filters[k]) == type([])
                                        call extend(conditions, map(copy(a:filters[k]), 's:_translateElement(k, v:val)'))
                                    else
                                        call add(conditions, s:_translateElement(k, a:filters[k]))
                                    endif
                                endfor
                            
                                if conditions == []
                                    let conditions = ['1']
                                endif
                                return len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                            endfunction " }}}2
                            
    1              0.000002 function! s:_translateElement(key, term) abort " {{{2
                                let fkey = a:key
                                if fkey[0] ==# '!'
                                    let fkey = fkey[1:]
                                    let not = 1
                                else
                                    let not = 0
                                endif
                            
                                if fkey ==? 'level'
                                    let op = not ? ' ==? ' : ' !=? '
                                    let ret = 'v:val["type"]' . op . string(a:term[0])
                                elseif fkey ==? 'type'
                                    if a:term ==? 'style'
                                        let op = not ? ' ==? ' : ' !=? '
                                        let ret = 'get(v:val, "subtype", "")' . op . '"style"'
                                    else
                                        let op = not ? '!' : ''
                                        let ret = op . 'has_key(v:val, "subtype")'
                                    endif
                                elseif fkey ==? 'regex'
                                    let op = not ? ' =~? ' : ' !~? '
                                    let ret = 'v:val["text"]' . op . string(a:term)
                                elseif fkey ==? 'file' || fkey[:4] ==? 'file:'
                                    let op = not ? ' =~# ' : ' !~# '
                                    let ret = 'bufname(str2nr(v:val["bufnr"]))'
                                    let mod = fkey[4:]
                                    if mod !=# ''
                                        let ret = 'fnamemodify(' . ret . ', ' . string(mod) . ')'
                                    endif
                                    let ret .= op . string(a:term)
                                else
                                    call syntastic#log#warn('quiet_messages: ignoring invalid key ' . strtrans(string(fkey)))
                                    let ret = '1'
                                endif
                                return ret
                            endfunction " }}}2
                            
                            " @vimlint(EVL103, 1, a:flags)
    1              0.000002 function! s:_delete_dumb(what, flags) abort " {{{2
                                if !exists('s:rmrf')
                                    let s:rmrf =
                                        \ has('unix') || has('mac') ? 'rm -rf' :
                                        \ has('win32') || has('win64') ? 'rmdir /S /Q' :
                                        \ has('win16') || has('win95') || has('dos16') || has('dos32') ? 'deltree /Y' : ''
                                endif
                            
                                if s:rmrf !=# ''
                                    silent! call syntastic#util#system(s:rmrf . ' ' . syntastic#util#shescape(a:what))
                                else
                                    call s:_rmrf(a:what)
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:flags)
                            
                            " delete(dir, 'rf') was added in Vim 7.4.1107, but it didn't become usable until 7.4.1128
    1              0.000015 let s:_delete = function(v:version > 704 || (v:version == 704 && has('patch1128')) ? 'delete' : 's:_delete_dumb')
    1              0.000002 lockvar s:_delete
                            
    1              0.000002 function! s:_rmrf(what) abort " {{{2
                                if !exists('s:rmdir')
                                    let s:rmdir = syntastic#util#shescape(get(g:, 'netrw_localrmdir', 'rmdir'))
                                endif
                            
                                if getftype(a:what) ==# 'dir'
                                    if filewritable(a:what) != 2
                                        return
                                    endif
                            
                                    try
                                        " Vim 7.4.279 and later
                                        let entries = globpath(a:what, '*', 1, 1)
                                    catch /\m^Vim\%((\a\+)\)\=:E118/
                                        let entries = split(globpath(a:what, '*', 1), "\n")
                                    endtry
                                    for f in entries
                                        call s:_rmrf(f)
                                    endfor
                                    silent! call syntastic#util#system(s:rmdir . ' ' . syntastic#util#shescape(a:what))
                                else
                                    silent! call delete(a:what)
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:_float2str_smart(val) abort " {{{2
                                return printf('%.1f', a:val)
                            endfunction " }}}2
                            
    1              0.000002 function! s:_float2str_dumb(val) abort " {{{2
                                return a:val
                            endfunction " }}}2
                            
    1              0.000008 let s:_float2str = function(has('float') ? 's:_float2str_smart' : 's:_float2str_dumb')
    1              0.000002 lockvar s:_float2str
                            
                            " }}}1
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/manny/.vim/bundle/vim-airline/plugin/airline.vim
Sourced 1 time
Total time:   0.001940
 Self time:   0.000323

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000010 if &cp || v:version < 702 || (exists('g:loaded_airline') && g:loaded_airline)
                              finish
                            endif
    1              0.000002 let g:loaded_airline = 1
                            
    1              0.000002 let s:airline_initialized = 0
    1              0.000003 function! s:init()
                              if s:airline_initialized
                                return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit
                            endfunction
                            
    1              0.000002 function! s:on_window_changed()
                              if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
                              let l:key = [bufnr('%'), winnr(), winnr('$')]
                              if get(t:, 'airline_last_window_changed', []) == l:key
                                    \ && &stl is# '%!airline#statusline('.winnr().')'
                                return
                              endif
                              let t:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()
                            endfunction
                            
    1              0.000002 function! s:on_colorscheme_changed()
                              call s:init()
                              let g:airline_gui_mode = airline#init#gui_mode()
                              if !s:theme_in_vimrc
                                call airline#switch_matching_theme()
                              endif
                            
                              " couldn't find a match, or theme was defined, just refresh
                              call airline#load_theme()
                            endfunction
                            
    1              0.000075 function! airline#cmdwinenter(...)
                              call airline#extensions#apply_left_override('Command Line', '')
                            endfunction
                            
    1              0.000002 function! s:airline_toggle()
                              if exists("#airline")
                                augroup airline
                                  au!
                                augroup END
                                augroup! airline
                            
                                if exists("s:stl")
                                  let &stl = s:stl
                                endif
                            
                                silent doautocmd User AirlineToggledOff
                              else
                                let s:stl = &statusline
                                augroup airline
                                  autocmd!
                            
                                  autocmd CmdwinEnter *
                                        \ call airline#add_statusline_func('airline#cmdwinenter')
                                        \ | call <sid>on_window_changed()
                                  autocmd CmdwinLeave * call airline#remove_statusline_func('airline#cmdwinenter')
                            
                                  autocmd GUIEnter,ColorScheme * call <sid>on_colorscheme_changed()
                                  autocmd SessionLoadPost,VimEnter,WinEnter,BufWinEnter,FileType,BufUnload *
                                        \ call <sid>on_window_changed()
                            
                                  autocmd VimResized * unlet! w:airline_lastmode | :call <sid>airline_refresh()
                                  autocmd TabEnter * :unlet! w:airline_lastmode w:airline_active
                                  autocmd BufWritePost */autoload/airline/themes/*.vim
                                        \ exec 'source '.split(globpath(&rtp, 'autoload/airline/themes/'.g:airline_theme.'.vim', 1), "\n")[0]
                                        \ | call airline#load_theme()
                                augroup END
                            
                                if s:airline_initialized
                                  call s:on_window_changed()
                                endif
                            
                                silent doautocmd User AirlineToggledOn
                              endif
                            endfunction
                            
    1              0.000003 function! s:get_airline_themes(a, l, p)
                              let files = split(globpath(&rtp, 'autoload/airline/themes/'.a:a.'*'), "\n")
                              return map(files, 'fnamemodify(v:val, ":t:r")')
                            endfunction
                            
    1              0.000002 function! s:airline_theme(...)
                              if a:0
                                call airline#switch_theme(a:1)
                              else
                                echo g:airline_theme
                              endif
                            endfunction
                            
    1              0.000001 function! s:airline_refresh()
                              let nomodeline=''
                              if v:version > 703 || v:version == 703 && has("patch438")
                                let nomodeline = '<nomodeline>'
                              endif
                              exe printf("silent doautocmd %s User AirlineBeforeRefresh", nomodeline)
                              call airline#load_theme()
                              call airline#update_statusline()
                            endfunction
                            
    1              0.000011 command! -bar -nargs=? -complete=customlist,<sid>get_airline_themes AirlineTheme call <sid>airline_theme(<f-args>)
    1              0.000008 command! -bar AirlineToggleWhitespace call airline#extensions#whitespace#toggle()
    1              0.000005 command! -bar AirlineToggle call s:airline_toggle()
    1              0.000005 command! -bar AirlineRefresh call s:airline_refresh()
                            
    1              0.000064 call airline#init#bootstrap()
    1   0.000166   0.000010 call s:airline_toggle()

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline.vim
Sourced 1 time
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000006 let g:airline_statusline_funcrefs = get(g:, 'airline_statusline_funcrefs', [])
                            
    1              0.000005 let s:sections = ['a','b','c','gutter','x','y','z', 'error', 'warning']
    1              0.000002 let s:inactive_funcrefs = []
                            
    1              0.000003 function! airline#add_statusline_func(name)
                              call airline#add_statusline_funcref(function(a:name))
                            endfunction
                            
    1              0.000003 function! airline#add_statusline_funcref(function)
                              if index(g:airline_statusline_funcrefs, a:function) >= 0
                                echohl WarningMsg
                                echo 'The airline statusline funcref '.string(a:function).' has already been added.'
                                echohl NONE
                                return
                              endif
                              call add(g:airline_statusline_funcrefs, a:function)
                            endfunction
                            
    1              0.000002 function! airline#remove_statusline_func(name)
                              let i = index(g:airline_statusline_funcrefs, function(a:name))
                              if i > -1
                                call remove(g:airline_statusline_funcrefs, i)
                              endif
                            endfunction
                            
    1              0.000003 function! airline#add_inactive_statusline_func(name)
                              call add(s:inactive_funcrefs, function(a:name))
                            endfunction
                            
    1              0.000002 function! airline#load_theme()
                              if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
                              let palette = g:airline#themes#{g:airline_theme}#palette
                              call airline#themes#patch(palette)
                            
                              if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
                              call airline#highlighter#load_theme()
                              call airline#extensions#load_theme()
                              call airline#update_statusline()
                            endfunction
                            
    1              0.000002 function! airline#switch_theme(name)
                              try
                                let palette = g:airline#themes#{a:name}#palette "also lazy loads the theme
                                let g:airline_theme = a:name
                              catch
                                echohl WarningMsg | echo 'The specified theme cannot be found.' | echohl NONE
                                if exists('g:airline_theme')
                                  return
                                else
                                  let g:airline_theme = 'dark'
                                endif
                              endtry
                            
                              let w:airline_lastmode = ''
                              call airline#load_theme()
                            
                              " this is required to prevent clobbering the startup info message, i don't know why...
                              call airline#check_mode(winnr())
                            endfunction
                            
    1              0.000002 function! airline#switch_matching_theme()
                              if exists('g:colors_name')
                                let existing = g:airline_theme
                                let theme = substitute(g:colors_name, '-', '_', 'g')
                                try
                                  let palette = g:airline#themes#{theme}#palette
                                  call airline#switch_theme(theme)
                                  return 1
                                catch
                                  for map in items(g:airline_theme_map)
                                    if match(g:colors_name, map[0]) > -1
                                      try
                                        let palette = g:airline#themes#{map[1]}#palette
                                        call airline#switch_theme(map[1])
                                      catch
                                        call airline#switch_theme(existing)
                                      endtry
                                      return 1
                                    endif
                                  endfor
                                endtry
                              endif
                              return 0
                            endfunction
                            
    1              0.000002 function! airline#update_statusline()
                              if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
                              for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            
                              unlet! w:airline_render_left
                              unlet! w:airline_render_right
                              for section in s:sections
                                unlet! w:airline_section_{section}
                              endfor
                            
                              let w:airline_active = 1
                              let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
                              call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)
                            endfunction
                            
    1              0.000002 let s:contexts = {}
    1              0.000007 let s:core_funcrefs = [
                                  \ function('airline#extensions#apply'),
                                  \ function('airline#extensions#default#apply') ]
    1              0.000004 function! s:invoke_funcrefs(context, funcrefs)
                              let builder = airline#builder#new(a:context)
                              let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
                              if err == 1
                                let a:context.line = builder.build()
                                let s:contexts[a:context.winnr] = a:context
                                call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
                              endif
                            endfunction
                            
    1              0.000005 function! airline#statusline(winnr)
                              if has_key(s:contexts, a:winnr)
                                return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''
                            endfunction
                            
    1              0.000002 function! airline#check_mode(winnr)
                              let context = s:contexts[a:winnr]
                            
                              if get(w:, 'airline_active', 1)
                                let l:m = mode()
                                if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
                                  let l:mode = ['normal']
                                endif
                                let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
                              else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
                              if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
                              if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
                              if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
                              if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
                              if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
                              let mode_string = join(l:mode)
                              if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode)
                                let w:airline_lastmode = mode_string
                              endif
                            
                              return ''
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/init.vim
Sourced 1 time
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 function! s:check_defined(variable, default)
                              if !exists(a:variable)
                                let {a:variable} = a:default
                              endif
                            endfunction
                            
    1              0.000003 let s:loaded = 0
    1              0.000003 function! airline#init#bootstrap()
                              if s:loaded
                                return
                              endif
                              let s:loaded = 1
                            
                              let g:airline#init#bootstrapping = 1
                              call s:check_defined('g:airline_left_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b0":">")
                              call s:check_defined('g:airline_left_alt_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b1":">")
                              call s:check_defined('g:airline_right_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b2":"<")
                              call s:check_defined('g:airline_right_alt_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b3":"<")
                              call s:check_defined('g:airline_detect_modified', 1)
                              call s:check_defined('g:airline_detect_paste', 1)
                              call s:check_defined('g:airline_detect_crypt', 1)
                              call s:check_defined('g:airline_detect_spell', 1)
                              call s:check_defined('g:airline_detect_iminsert', 0)
                              call s:check_defined('g:airline_inactive_collapse', 1)
                              call s:check_defined('g:airline_exclude_filenames', ['DebuggerWatch','DebuggerStack','DebuggerStatus'])
                              call s:check_defined('g:airline_exclude_filetypes', [])
                              call s:check_defined('g:airline_exclude_preview', 0)
                              call s:check_defined('g:airline_gui_mode', airline#init#gui_mode())
                            
                              call s:check_defined('g:airline_mode_map', {})
                              call extend(g:airline_mode_map, {
                                    \ '__' : '------',
                                    \ 'n'  : 'NORMAL',
                                    \ 'i'  : 'INSERT',
                                    \ 'R'  : 'REPLACE',
                                    \ 'v'  : 'VISUAL',
                                    \ 'V'  : 'V-LINE',
                                    \ 'c'  : 'COMMAND',
                                    \ '' : 'V-BLOCK',
                                    \ 's'  : 'SELECT',
                                    \ 'S'  : 'S-LINE',
                                    \ '' : 'S-BLOCK',
                                    \ 't'  : 'TERMINAL',
                                    \ }, 'keep')
                            
                              call s:check_defined('g:airline_theme_map', {})
                              call extend(g:airline_theme_map, {
                                    \ '\CTomorrow': 'tomorrow',
                                    \ 'base16': 'base16',
                                    \ 'mo[l|n]okai': 'molokai',
                                    \ 'wombat': 'wombat',
                                    \ 'zenburn': 'zenburn',
                                    \ 'solarized': 'solarized',
                                    \ }, 'keep')
                            
                              call s:check_defined('g:airline_symbols', {})
                              call extend(g:airline_symbols, {
                                    \ 'paste': 'PASTE',
                                    \ 'spell': 'SPELL',
                                    \ 'readonly': get(g:, 'airline_powerline_fonts', 0) ? "\ue0a2" : 'RO',
                                    \ 'whitespace': get(g:, 'airline_powerline_fonts', 0) ? "\u2739" : '!',
                                    \ 'linenr': get(g:, 'airline_powerline_fonts', 0) ? "\ue0a1" : ':',
                                    \ 'maxlinenr': get(g:, 'airline_powerline_fonts', 0) ? "\u2630" : '',
                                    \ 'branch': get(g:, 'airline_powerline_fonts', 0) ? "\ue0a0" : '',
                                    \ 'notexists': "\u2204",
                                    \ 'modified': '+',
                                    \ 'space': ' ',
                                    \ 'crypt': get(g:, 'airline_crypt_symbol', nr2char(0x1F512)),
                                    \ }, 'keep')
                            
                              call airline#parts#define('mode', {
                                    \ 'function': 'airline#parts#mode',
                                    \ 'accent': 'bold',
                                    \ })
                              call airline#parts#define_function('iminsert', 'airline#parts#iminsert')
                              call airline#parts#define_function('paste', 'airline#parts#paste')
                              call airline#parts#define_function('crypt', 'airline#parts#crypt')
                              call airline#parts#define_function('spell', 'airline#parts#spell')
                              call airline#parts#define_function('filetype', 'airline#parts#filetype')
                              call airline#parts#define('readonly', {
                                    \ 'function': 'airline#parts#readonly',
                                    \ 'accent': 'red',
                                    \ })
                              call airline#parts#define_raw('file', '%f%m')
                              call airline#parts#define_raw('path', '%F%m')
                              call airline#parts#define('linenr', {
                                    \ 'raw': '%{g:airline_symbols.linenr}%#__accent_bold#%4l%#__restore__#',
                                    \ 'accent': 'bold'})
                              call airline#parts#define('maxlinenr', {
                                    \ 'raw': '%#__accent_bold#/%L%{g:airline_symbols.maxlinenr}%#__restore__#',
                                    \ 'accent': 'bold'})
                              call airline#parts#define_function('ffenc', 'airline#parts#ffenc')
                              call airline#parts#define_empty(['hunks', 'branch', 'obsession', 'tagbar', 'syntastic',
                                    \ 'eclim', 'whitespace','windowswap', 'ycm_error_count', 'ycm_warning_count'])
                              call airline#parts#define_text('capslock', '')
                            
                              unlet g:airline#init#bootstrapping
                            endfunction
                            
    1              0.000002 function! airline#init#gui_mode()
                              return ((has('nvim') && exists('$NVIM_TUI_ENABLE_TRUE_COLOR') && !exists("+termguicolors"))
                                    \ || has('gui_running') || (has("termtruecolor") && &guicolors == 1) || (has("termguicolors") && &termguicolors == 1)) ?
                                    \ 'gui' : 'cterm'
                            endfunction
                            
    1              0.000003 function! airline#init#sections()
                              let spc = g:airline_symbols.space
                              if !exists('g:airline_section_a')
                                let g:airline_section_a = airline#section#create_left(['mode', 'crypt', 'paste', 'spell', 'capslock', 'iminsert'])
                              endif
                              if !exists('g:airline_section_b')
                                let g:airline_section_b = airline#section#create(['hunks', 'branch'])
                              endif
                              if !exists('g:airline_section_c')
                                if exists("+autochdir") && &autochdir == 1
                                  let g:airline_section_c = airline#section#create(['%<', 'path', spc, 'readonly'])
                                else
                                  let g:airline_section_c = airline#section#create(['%<', 'file', spc, 'readonly'])
                                endif
                              endif
                              if !exists('g:airline_section_gutter')
                                let g:airline_section_gutter = airline#section#create(['%='])
                              endif
                              if !exists('g:airline_section_x')
                                let g:airline_section_x = airline#section#create_right(['tagbar', 'filetype'])
                              endif
                              if !exists('g:airline_section_y')
                                let g:airline_section_y = airline#section#create_right(['ffenc'])
                              endif
                              if !exists('g:airline_section_z')
                                let g:airline_section_z = airline#section#create(['windowswap', 'obsession', '%3p%%'.spc, 'linenr', 'maxlinenr', spc.':%3v'])
                              endif
                              if !exists('g:airline_section_error')
                                let g:airline_section_error = airline#section#create(['ycm_error_count', 'syntastic', 'eclim'])
                              endif
                              if !exists('g:airline_section_warning')
                                let g:airline_section_warning = airline#section#create(['ycm_warning_count', 'whitespace'])
                              endif
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/parts.vim
Sourced 1 time
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 let s:parts = {}
                            
                            " PUBLIC API {{{
                            
    1              0.000003 function! airline#parts#define(key, config)
                              let s:parts[a:key] = get(s:parts, a:key, {})
                              if exists('g:airline#init#bootstrapping')
                                call extend(s:parts[a:key], a:config, 'keep')
                              else
                                call extend(s:parts[a:key], a:config, 'force')
                              endif
                            endfunction
                            
    1              0.000003 function! airline#parts#define_function(key, name)
                              call airline#parts#define(a:key, { 'function': a:name })
                            endfunction
                            
    1              0.000003 function! airline#parts#define_text(key, text)
                              call airline#parts#define(a:key, { 'text': a:text })
                            endfunction
                            
    1              0.000003 function! airline#parts#define_raw(key, raw)
                              call airline#parts#define(a:key, { 'raw': a:raw })
                            endfunction
                            
    1              0.000003 function! airline#parts#define_minwidth(key, width)
                              call airline#parts#define(a:key, { 'minwidth': a:width })
                            endfunction
                            
    1              0.000002 function! airline#parts#define_condition(key, predicate)
                              call airline#parts#define(a:key, { 'condition': a:predicate })
                            endfunction
                            
    1              0.000003 function! airline#parts#define_accent(key, accent)
                              call airline#parts#define(a:key, { 'accent': a:accent })
                            endfunction
                            
    1              0.000002 function! airline#parts#define_empty(keys)
                              for key in a:keys
                                call airline#parts#define_raw(key, '')
                              endfor
                            endfunction
                            
    1              0.000003 function! airline#parts#get(key)
                              return get(s:parts, a:key, {})
                            endfunction
                            
                            " }}}
                            
    1              0.000002 function! airline#parts#mode()
                              return get(w:, 'airline_current_mode', '')
                            endfunction
                            
    1              0.000002 function! airline#parts#crypt()
                              return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''
                            endfunction
                            
    1              0.000002 function! airline#parts#paste()
                              return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''
                            endfunction
                            
    1              0.000003 function! airline#parts#spell()
                              return g:airline_detect_spell && &spell ? g:airline_symbols.spell : ''
                            endfunction
                            
    1              0.000002 function! airline#parts#iminsert()
                              if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! airline#parts#readonly()
                              if &readonly && &modifiable && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
                                return &readonly ? g:airline_symbols.readonly : ''
                              endif
                            endfunction
                            
    1              0.000002 function! airline#parts#filetype()
                              return &filetype
                            endfunction
                            
    1              0.000002 function! airline#parts#ffenc()
                              return printf('%s%s%s', &fenc, &l:bomb ? '[BOM]' : '', strlen(&ff) > 0 ? '['.&ff.']' : '')
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline-themes/plugin/airline-themes.vim
Sourced 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling & Contributors.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000006 if (exists('g:loaded_airline_themes') && g:loaded_airline_themes)
                              finish
                            endif
    1              0.000005 let g:loaded_airline_themes = 1

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/getscriptPlugin.vim
Sourced 1 time
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
                            " ---------------------------------------------------------------------
                            " getscriptPlugin.vim
                            "  Author:	Charles E. Campbell
                            "  Date:	Nov 29, 2013
                            "  Installing:	:help glvs-install
                            "  Usage:	:help glvs
                            "
                            " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
                            "
                            " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
                            " all the peoples praise Him."
                            " ---------------------------------------------------------------------
                            " Initialization:	{{{1
                            " if you're sourcing this file, surely you can't be
                            " expecting vim to be in its vi-compatible mode
    1              0.000005 if exists("g:loaded_getscriptPlugin")
                             finish
                            endif
    1              0.000004 if &cp
                             if &verbose
                              echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
                             endif
                             finish
                            endif
    1              0.000003 let g:loaded_getscriptPlugin = "v36"
    1              0.000005 let s:keepcpo                = &cpo
    1              0.000011 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000008 com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
    1              0.000007 com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
    1              0.000007 silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
                            
                            " ---------------------------------------------------------------------
                            " Restore Options: {{{1
    1              0.000006 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            " vim: ts=8 sts=2 fdm=marker nowrap

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/gzip.vim
Sourced 1 time
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2010 Mar 10
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000008 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
                            endif
    1              0.000002 let loaded_gzip = 1
                            
    1              0.000002 augroup gzip
                              " Remove all gzip autocommands
    1              0.000032   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000029   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin
    1              0.000018   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000016   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000015   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000020   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000017   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000009   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000009   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000004   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000004   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000006   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000005   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000004   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000004   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000004   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000003   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000003   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000003   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000004 augroup END

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/logiPat.vim
Sourced 1 time
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
                            " LogiPat: Boolean logical pattern matcher
                            "   Author:  Charles E. Campbell
                            "   Date:    Apr 04, 2016
                            "   Version: 4
                            "   Purpose: to do Boolean-logic based regular expression pattern matching
                            " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like most anything else that's free,
                            "               LogiPat.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            "   Usage: {{{1
                            "       :LogiPat ...
                            "
                            "         Boolean logic supported:
                            "            () grouping operators
                            "            !  not the following pattern
                            "            |  logical or
                            "            &  logical and
                            "            "..pattern.."
                            "	Example: {{{1
                            "		:LogiPat !("january"|"february")
                            "		  would match all strings not containing the strings january
                            "		  or february
                            "	GetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
                            "
                            "  Behold, you will conceive in your womb, and bring forth a son, {{{1
                            "  and will call his name Jesus. He will be great, and will be
                            "  called the Son of the Most High. The Lord God will give him the
                            "  throne of his father, David, and he will reign over the house of
                            "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
                            
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000006 if &cp || exists("loaded_logiPat")
                             finish
                            endif
    1              0.000003 let g:loaded_logiPat = "v4"
    1              0.000004 let s:keepcpo        = &cpo
    1              0.000005 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000008 com!     -nargs=* LogiPat		call   LogiPat(<q-args>,1)
    1              0.000006 sil! com -nargs=* LP			call   LogiPat(<q-args>,1)
    1              0.000006 sil! com -nargs=* LPR			call   LogiPat(<q-args>,1,"r")
    1              0.000006 com!     -nargs=+ LPE			echomsg LogiPat(<q-args>)
    1              0.000007 com!     -nargs=+ LogiPatFlags	let  s:LogiPatFlags="<args>"
    1              0.000007 sil! com -nargs=+ LPF			let  s:LogiPatFlags="<args>"
                            
                            " =====================================================================
                            " Functions: {{{1
                            
                            " ---------------------------------------------------------------------
                            " LogiPat: this function interprets the boolean-logic pattern {{{2
    1              0.000002 fun! LogiPat(pat,...)
                            "  call Dfunc("LogiPat(pat<".a:pat.">)")
                            
                              " LogiPat(pat,dosearch)
                              if a:0 > 0
                               let dosearch= a:1
                              else
                               let dosearch= 0
                              endif
                              if a:0 >= 3
                               let s:LogiPatFlags= a:3
                              endif
                            
                              let s:npatstack = 0
                              let s:nopstack  = 0
                              let s:preclvl   = 0
                              let expr        = a:pat
                            
                              " Lexer/Parser
                              while expr != ""
                            "   call Decho("expr<".expr.">")
                            
                               if expr =~ '^"'
                            	" push a Pattern; accept "" as a single " in the pattern
                                let expr = substitute(expr,'^\s*"','','')
                                let pat  = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\1','')
                            	let pat  = substitute(pat,'""','"','g')
                                let expr = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\2','')
                                let expr = substitute(expr,'^\s*','','')
                            "    call Decho("pat<".pat."> expr<".expr.">")
                            
                                call s:LP_PatPush('.*'.pat.'.*')
                            
                               elseif expr =~ '^[!()|&]'
                                " push an operator
                                let op   = strpart(expr,0,1)
                                let expr = strpart(expr,strlen(op))
                            	" allow for those who can't resist doubling their and/or operators
                            	if op =~ '[|&]' && expr[0] == op
                                 let expr = strpart(expr,strlen(op))
                            	endif
                                call s:LP_OpPush(op)
                            
                               elseif expr =~ '^\s'
                                " skip whitespace
                                let expr= strpart(expr,1)
                            
                               else
                                echoerr "operator<".strpart(expr,0,1)."> not supported (yet)"
                                let expr= strpart(expr,1)
                               endif
                            
                              endwhile
                            
                              " Final Execution
                              call s:LP_OpPush('Z')
                            
                              let result= s:LP_PatPop(1)
                            "  call Decho("result=".result)
                            
                              " sanity checks and cleanup
                              if s:npatstack > 0
                               echoerr s:npatstack." patterns left on stack!"
                               let s:npatstack= 0
                              endif
                              if s:nopstack > 0
                               echoerr s:nopstack." operators left on stack!"
                               let s:nopstack= 0
                              endif
                            
                              " perform the indicated search
                              if dosearch
                               if exists("s:LogiPatFlags") && s:LogiPatFlags != ""
                            "  call Decho("search(result<".result."> LogiPatFlags<".s:LogiPatFlags.">)")
                                call search(result,s:LogiPatFlags)
                               else
                            "  call Decho("search(result<".result.">)")
                                call search(result)
                               endif
                               let @/= result
                              endif
                            
                            "  call Dret("LogiPat ".result)
                              return result
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:String: Vim6.4 doesn't have string() {{{2
    1              0.000004 func! s:String(str)
                              return "'".escape(a:str, '"')."'"
                            endfunc
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPush: {{{2
    1              0.000003 fun! s:LP_PatPush(pat)
                            "  call Dfunc("LP_PatPush(pat<".a:pat.">)")
                              let s:npatstack              = s:npatstack + 1
                              let s:patstack_{s:npatstack} = a:pat
                            "  call s:StackLook("patpush") "Decho
                            "  call Dret("LP_PatPush : npatstack=".s:npatstack)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
    1              0.000002 fun! s:LP_PatPop(lookup)
                            "  call Dfunc("LP_PatPop(lookup=".a:lookup.")")
                              if s:npatstack > 0
                               let ret         = s:patstack_{s:npatstack}
                               let s:npatstack = s:npatstack - 1
                              else
                               let ret= "---error---"
                               echoerr "(LogiPat) invalid expression"
                              endif
                            "  call s:StackLook("patpop") "Decho
                            "  call Dret("LP_PatPop ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_OpPush: {{{2
    1              0.000002 fun! s:LP_OpPush(op)
                            "  call Dfunc("LP_OpPush(op<".a:op.">)")
                            
                              " determine new operator's precedence level
                              if a:op == '('
                              	let s:preclvl= s:preclvl + 10
                            	let preclvl  = s:preclvl
                              elseif a:op == ')'
                              	let s:preclvl= s:preclvl - 10
                               if s:preclvl < 0
                                let s:preclvl= 0
                                echoerr "too many )s"
                               endif
                               let preclvl= s:preclvl
                              elseif a:op =~ '|'
                               let preclvl= s:preclvl + 2
                              elseif a:op =~ '&'
                               let preclvl= s:preclvl + 4
                              elseif a:op == '!'
                               let preclvl= s:preclvl + 6
                              elseif a:op == 'Z'
                               let preclvl= -1
                              else
                               echoerr "expr<".expr."> not supported (yet)"
                               let preclvl= s:preclvl
                              endif
                            "  call Decho("new operator<".a:op."> preclvl=".preclvl)
                            
                              " execute higher-precdence operators
                            "  call Decho("execute higher-precedence operators")
                              call s:LP_Execute(preclvl)
                            
                              " push new operator onto operator-stack
                            "  call Decho("push new operator<".a:op."> onto stack with preclvl=".preclvl." at nopstack=".(s:nopstack+1))
                              if a:op =~ '!'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op =~ '|'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op == '&'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              endif
                            
                            "  call s:StackLook("oppush") "Decho
                            "  call Dret("LP_OpPush : s:preclvl=".s:preclvl)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Execute: execute operators from opstack using pattern stack {{{2
    1              0.000003 fun! s:LP_Execute(preclvl)
                            "  call Dfunc("LP_Execute(preclvl=".a:preclvl.") npatstack=".s:npatstack." nopstack=".s:nopstack)
                            
                              " execute all higher precedence operators
                              while s:nopstack > 0 && a:preclvl < s:opprec_{s:nopstack}
                               let op= s:opstack_{s:nopstack}
                            "   call Decho("op<".op."> nop=".s:nopstack." [preclvl=".a:preclvl."] < [opprec_".s:nopstack."=".s:opprec_{s:nopstack}."]")
                            
                               let s:nopstack = s:nopstack - 1
                             
                               if     op == '!'
                                let n1= s:LP_PatPop(1)
                            	call s:LP_PatPush(s:LP_Not(n1))
                             
                               elseif op == '|'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_Or(n2,n1))
                             
                               elseif op =~ '&'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_And(n2,n1))
                               endif
                             
                            "   call s:StackLook("execute") "Decho
                              endwhile
                            
                            "  call Dret("LP_Execute")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Not: writes a logical-not for a pattern {{{2
    1              0.000002 fun! s:LP_Not(pat)
                            "  call Dfunc("LP_Not(pat<".a:pat.">)")
                              if a:pat =~ '^\.\*' && a:pat =~ '\.\*$'
                               let pat= substitute(a:pat,'^\.\*\(.*\)\.\*$','\1','')
                               let ret= '^\%(\%('.pat.'\)\@!.\)*$'
                              else
                               let ret= '^\%(\%('.a:pat.'\)\@!.\)*$'
                              endif
                            "  call Dret("LP_Not ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Or: writes a logical-or branch using two patterns {{{2
    1              0.000002 fun! s:LP_Or(pat1,pat2)
                            "  call Dfunc("LP_Or(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\|'.a:pat2.'\)'
                            "  call Dret("LP_Or ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_And: writes a logical-and concat using two patterns {{{2
    1              0.000002 fun! s:LP_And(pat1,pat2)
                            "  call Dfunc("LP_And(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\&'.a:pat2.'\)'
                            "  call Dret("LP_And ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " StackLook: {{{2
    1              0.000002 fun! s:StackLook(description)
                            "  call Dfunc("StackLook(description<".a:description.">)")
                              let iop = 1
                              let ifp = 1
                            "  call Decho("Pattern                       Operator")
                            
                              " print both pattern and operator
                              while ifp <= s:npatstack && iop <= s:nopstack
                               let fp = s:patstack_{ifp}
                               let op = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                               let fplen= strlen(fp)
                               if fplen < 30
                               	let fp= fp.strpart("                              ",1,30-fplen)
                               endif
                            "   call Decho(fp.op)
                               let ifp = ifp + 1
                               let iop = iop + 1
                              endwhile
                            
                              " print just pattern
                              while ifp <= s:npatstack
                               let fp  = s:patstack_{ifp}
                            "   call Decho(fp)
                               let ifp = ifp + 1
                              endwhile
                            
                              " print just operator
                              while iop <= s:nopstack
                               let op  = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                            "   call Decho("                              ".op)
                               let iop = iop + 1
                              endwhile
                            "  call Dret("StackLook")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Cleanup And Modeline: {{{1
    1              0.000006 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " vim: ts=4 fdm=marker

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/manpager.vim
Sourced 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
                            " Vim plugin for using Vim as manpager.
                            " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
                            " Last Change: 2016 May 20
                            
                            " $MAN_PN is supposed to be set by MANPAGER, see ":help manpager.vim".
    1              0.000005 if empty($MAN_PN)
    1              0.000002   finish

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Feb 16
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000008 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
                            endif
    1              0.000002 let g:loaded_matchparen = 1
                            
    1              0.000003 if !exists("g:matchparen_timeout")
    1              0.000002   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000003 if !exists("g:matchparen_insert_timeout")
    1              0.000011   let g:matchparen_insert_timeout = 60
    1              0.000002 endif
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000011   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000003   if exists('##TextChanged')
    1              0.000011     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000002   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000004 if exists("*s:Highlight_Matching_Pair")
                              finish
                            endif
                            
    1              0.000004 let s:cpo_save = &cpo
    1              0.000005 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000003 function! s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000012 command! NoMatchParen windo silent! call matchdelete(3) | unlet! g:loaded_matchparen |
                            	  \ au! matchparen
    1              0.000009 command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000634
 Self time:   0.000634

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 08, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000006 if &cp || exists("g:loaded_netrwPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_netrwPlugin = "v156"
    1              0.000003 let s:keepcpo = &cpo
    1              0.000005 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000001 augroup FileExplorer
    1              0.000030  au!
    1              0.000005  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000003  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000005  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000010  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
                             endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000025  au!
    1              0.000010  au BufReadCmd   file://*											call netrw#FileUrlRead(expand("<amatch>"))
    1              0.000026  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000024  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000022  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000019  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000001  try                                                       
    1              0.000023   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000003  catch /^Vim\%((\a\+)\)\=:E216/                            
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000026 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000019 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000006 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000013 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000007 com! -nargs=?		Ntree		call netrw#SetTreetop(<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000013 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000012 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000011 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000012 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000010 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000006 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000006 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000012 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000006 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000007 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000003 if !exists("g:netrw_nogx")
    1              0.000007  if maparg('gx','n') == ""
    1              0.000013   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000009    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000023   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
    1              0.000001  endif
    1              0.000005  if maparg('gx','v') == ""
    1              0.000009   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000007    vmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000001   endif
    1              0.000010   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000001  endif
    1              0.000001 endif
    1              0.000004 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
                            endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000004 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000003 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000002 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000006 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000007 if exists("loaded_rrhelper") || !has("clientserver")
    1              0.000001   finish

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2006 Feb 01
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of spell files
    1              0.000010 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
                            endif
    1              0.000003 let loaded_spellfile_plugin = 1
                            
                            " The function is in the autoload directory.
    1              0.000008 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000006 if &cp || exists("g:loaded_tarPlugin")
                             finish
                            endif
    1              0.000003 let g:loaded_tarPlugin = "v29"
    1              0.000004 let s:keepcpo          = &cpo
    1              0.000005 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000005 augroup tar
    1              0.000033   au!
    1              0.000011   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000006   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000004   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000006   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000003   if has("unix")
    1              0.000008    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000008    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000006    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000005    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001   endif
                            
    1              0.000005   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000007   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000001 augroup END
    1              0.000007 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000006 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2015 Sep 08
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
                            " TODO: {{{
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
    1              0.000005 if exists('g:loaded_2html_plugin')
                              finish
                            endif
    1              0.000003 let g:loaded_2html_plugin = 'vim7.4_v2'
                            
                            "
                            " Changelog: {{{
                            "   7.4_v2  (this version): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evalutated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin was not already loaded
                            " - user commands are available. {{{
    1              0.000009 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000012   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/vimballPlugin.vim
Sourced 1 time
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
                            " vimballPlugin : construct a file containing both paths and files
                            " Author: Charles E. Campbell
                            " Copyright: (c) 2004-2014 by Charles E. Campbell
                            "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
                            "            (see |copyright|) except use "Vimball" instead of "Vim".
                            "            No warranty, express or implied.
                            "  *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
                            "      judge. For in that which you judge another, you condemn yourself. For
                            "      you who judge practice the same things.
                            " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
                            
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000007 if &cp || exists("g:loaded_vimballPlugin")
                             finish
                            endif
    1              0.000003 let g:loaded_vimballPlugin = "v37"
    1              0.000004 let s:keepcpo              = &cpo
    1              0.000005 set cpo&vim
                            
                            " ------------------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000015 com! -range   -complete=file -nargs=+ -bang MkVimball		call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
    1              0.000007 com! -nargs=? -complete=dir  UseVimball						call vimball#Vimball(1,<f-args>)
    1              0.000005 com! -nargs=0                VimballList					call vimball#Vimball(0)
    1              0.000018 com! -nargs=* -complete=dir  RmVimball						call vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
    1              0.000002 augroup Vimball
    1              0.000032  au!
    1              0.000019  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
    1              0.000016  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000006  au SourceCmd *.vba											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000015  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
    1              0.000015  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000005  au SourceCmd *.vmb											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000002 augroup END
                            
                            " =====================================================================
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000005 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /usr/local/Cellar/vim/7.4.1952/share/vim/vim74/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Jun 07, 2013
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2013 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000008 if &cp || exists("g:loaded_zipPlugin")
                             finish
                            endif
    1              0.000003 let g:loaded_zipPlugin = "v27"
    1              0.000004 let s:keepcpo          = &cpo
    1              0.000005 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000004 if !exists("g:zipPlugin_ext")
    1              0.000006  let g:zipPlugin_ext= '*.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx'
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000001 augroup zip
    1              0.000033  au!
    1              0.000011  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000006  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000008  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000005  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000003  if has("unix")
    1              0.000005   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000006   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000004   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000007   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001  endif
                            
    1              0.000077  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000002 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000006 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions.vim
Sourced 1 time
Total time:   0.000337
 Self time:   0.000337

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000007 let s:ext = {}
    1              0.000003 let s:ext._theme_funcrefs = []
                            
    1              0.000003 function! s:ext.add_statusline_func(name) dict
                              call airline#add_statusline_func(a:name)
                            endfunction
    1              0.000002 function! s:ext.add_statusline_funcref(function) dict
                              call airline#add_statusline_funcref(a:function)
                            endfunction
    1              0.000002 function! s:ext.add_inactive_statusline_func(name) dict
                              call airline#add_inactive_statusline_func(a:name)
                            endfunction
    1              0.000002 function! s:ext.add_theme_func(name) dict
                              call add(self._theme_funcrefs, function(a:name))
                            endfunction
                            
    1              0.000048 let s:script_path = tolower(resolve(expand('<sfile>:p:h')))
                            
    1              0.000013 let s:filetype_overrides = {
                                  \ 'nerdtree': [ 'NERD', '' ],
                                  \ 'gundo': [ 'Gundo', '' ],
                                  \ 'vimfiler': [ 'vimfiler', '%{vimfiler#get_status_string()}' ],
                                  \ 'minibufexpl': [ 'MiniBufExplorer', '' ],
                                  \ 'startify': [ 'startify', '' ],
                                  \ 'vim-plug': [ 'Plugins', '' ],
                                  \ }
                            
    1              0.000003 let s:filetype_regex_overrides = {}
                            
    1              0.000003 function! s:check_defined_section(name)
                              if !exists('w:airline_section_{a:name}')
                                let w:airline_section_{a:name} = g:airline_section_{a:name}
                              endif
                            endfunction
                            
    1              0.000004 function! airline#extensions#append_to_section(name, value)
                              call <sid>check_defined_section(a:name)
                              let w:airline_section_{a:name} .= a:value
                            endfunction
                            
    1              0.000003 function! airline#extensions#prepend_to_section(name, value)
                              call <sid>check_defined_section(a:name)
                              let w:airline_section_{a:name} = a:value . w:airline_section_{a:name}
                            endfunction
                            
    1              0.000003 function! airline#extensions#apply_left_override(section1, section2)
                              let w:airline_section_a = a:section1
                              let w:airline_section_b = a:section2
                              let w:airline_section_c = airline#section#create(['readonly'])
                              let w:airline_render_left = 1
                              let w:airline_render_right = 0
                            endfunction
                            
    1              0.000003 let s:active_winnr = -1
    1              0.000002 function! airline#extensions#apply(...)
                              let s:active_winnr = winnr()
                            
                              if s:is_excluded_window()
                                return -1
                              endif
                            
                              if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
                              if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
                              if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
                              for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! s:is_excluded_window()
                              for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
                              for matchw in g:airline_exclude_filenames
                                if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
                              endfor
                            
                              if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
    1              0.000003 function! airline#extensions#load_theme()
                              call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)
                            endfunction
                            
    1              0.000002 function! s:sync_active_winnr()
                              if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#load()
                              " non-trivial number of external plugins use eventignore=all, so we need to account for that
                              autocmd CursorMoved * call <sid>sync_active_winnr()
                            
                              if exists('g:airline_extensions')
                                for ext in g:airline_extensions
                                  try
                                    call airline#extensions#{ext}#init(s:ext)
                                  catch /^Vim\%((\a\+)\)\=:E117/	" E117, function does not exist
                                    call airline#util#warning("Extension '".ext."' not installed, ignoring!")
                                  endtry
                                endfor
                                return
                              endif
                            
                              call airline#extensions#quickfix#init(s:ext)
                            
                              if get(g:, 'loaded_unite', 0)
                                call airline#extensions#unite#init(s:ext)
                              endif
                            
                              if exists(':NetrwSettings')
                                call airline#extensions#netrw#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#ycm#enabled', 0)
                                call airline#extensions#ycm#init(s:ext)
                              endif
                            
                              if get(g:, 'loaded_vimfiler', 0)
                                let g:vimfiler_force_overwrite_statusline = 0
                              endif
                            
                              if get(g:, 'loaded_ctrlp', 0)
                                call airline#extensions#ctrlp#init(s:ext)
                              endif
                            
                              if get(g:, 'CtrlSpaceLoaded', 0)
                                call airline#extensions#ctrlspace#init(s:ext)
                              endif
                            
                              if get(g:, 'command_t_loaded', 0)
                                call airline#extensions#commandt#init(s:ext)
                              endif
                            
                              if exists(':UndotreeToggle')
                                call airline#extensions#undotree#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#hunks#enabled', 1)
                                    \ && (exists('g:loaded_signify') || exists('g:loaded_gitgutter') || exists('g:loaded_changes') || exists('g:loaded_quickfixsigns'))
                                call airline#extensions#hunks#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#tagbar#enabled', 1)
                                    \ && exists(':TagbarToggle')
                                call airline#extensions#tagbar#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#csv#enabled', 1)
                                    \ && (get(g:, 'loaded_csv', 0) || exists(':Table'))
                                call airline#extensions#csv#init(s:ext)
                              endif
                            
                              if exists(':VimShell')
                                let s:filetype_overrides['vimshell'] = ['vimshell','%{vimshell#get_status_string()}']
                                let s:filetype_regex_overrides['^int-'] = ['vimshell','%{substitute(&ft, "int-", "", "")}']
                              endif
                            
                              if get(g:, 'airline#extensions#branch#enabled', 1)
                                    \ && (exists('*fugitive#head') || exists('*lawrencium#statusline') ||
                                    \     (get(g:, 'airline#extensions#branch#use_vcscommand', 0) && exists('*VCSCommandGetStatusLine')))
                                call airline#extensions#branch#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#bufferline#enabled', 1)
                                    \ && exists('*bufferline#get_status_string')
                                call airline#extensions#bufferline#init(s:ext)
                              endif
                            
                              if (get(g:, 'airline#extensions#virtualenv#enabled', 1) && (exists(':VirtualEnvList') || isdirectory($VIRTUAL_ENV)))
                                call airline#extensions#virtualenv#init(s:ext)
                              endif
                            
                              if (get(g:, 'airline#extensions#eclim#enabled', 1) && exists(':ProjectCreate'))
                                call airline#extensions#eclim#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#syntastic#enabled', 1)
                                    \ && exists(':SyntasticCheck')
                                call airline#extensions#syntastic#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#whitespace#enabled', 1)
                                call airline#extensions#whitespace#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#po#enabled', 1) && executable('msgfmt')
                                call airline#extensions#po#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#wordcount#enabled', 1)
                                call airline#extensions#wordcount#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#tabline#enabled', 0)
                                call airline#extensions#tabline#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#tmuxline#enabled', 1) && exists(':Tmuxline')
                                call airline#extensions#tmuxline#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#promptline#enabled', 1) && exists(':PromptlineSnapshot') && len(get(g:, 'airline#extensions#promptline#snapshot_file', ''))
                                call airline#extensions#promptline#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#nrrwrgn#enabled', 1) && exists(':NR') == 2
                                  call airline#extensions#nrrwrgn#init(s:ext)
                              endif
                            
                              if get(g:, 'airline#extensions#unicode#enabled', 1) && exists(':UnicodeTable') == 2
                                  call airline#extensions#unicode#init(s:ext)
                              endif
                            
                              if (get(g:, 'airline#extensions#capslock#enabled', 1) && exists('*CapsLockStatusline'))
                                call airline#extensions#capslock#init(s:ext)
                              endif
                            
                              if (get(g:, 'airline#extensions#windowswap#enabled', 1) && get(g:, 'loaded_windowswap', 0))
                                call airline#extensions#windowswap#init(s:ext)
                              endif
                            
                              if (get(g:, 'airline#extensions#obsession#enabled', 1) && exists('*ObsessionStatus'))
                                call airline#extensions#obsession#init(s:ext)
                              endif
                            
                              if !get(g:, 'airline#extensions#disable_rtp_load', 0)
                                " load all other extensions, which are not part of the default distribution.
                                " (autoload/airline/extensions/*.vim outside of our s:script_path).
                                for file in split(globpath(&rtp, "autoload/airline/extensions/*.vim"), "\n")
                                  " we have to check both resolved and unresolved paths, since it's possible
                                  " that they might not get resolved properly (see #187)
                                  if stridx(tolower(resolve(fnamemodify(file, ':p'))), s:script_path) < 0
                                        \ && stridx(tolower(fnamemodify(file, ':p')), s:script_path) < 0
                                    let name = fnamemodify(file, ':t:r')
                                    if !get(g:, 'airline#extensions#'.name.'#enabled', 1)
                                      continue
                                    endif
                                    try
                                      call airline#extensions#{name}#init(s:ext)
                                    catch
                                    endtry
                                  endif
                                endfor
                              endif
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/quickfix.vim
Sourced 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000005 let g:airline#extensions#quickfix#quickfix_text = 'Quickfix'
    1              0.000003 let g:airline#extensions#quickfix#location_text = 'Location'
                            
    1              0.000004 function! airline#extensions#quickfix#apply(...)
                              if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif
                            endfunction
                            
    1              0.000004 function! airline#extensions#quickfix#init(ext)
                              call a:ext.add_statusline_func('airline#extensions#quickfix#apply')
                              call a:ext.add_inactive_statusline_func('airline#extensions#quickfix#inactive_qf_window')
                            endfunction
                            
    1              0.000003 function! airline#extensions#quickfix#inactive_qf_window(...)
                              if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif
                            endfunction
                            
    1              0.000008 function! s:get_text()
                              redir => buffers
                              silent ls
                              redir END
                            
                              let nr = bufnr('%')
                              for buf in split(buffers, '\n')
                                if match(buf, '\v^\s*'.nr) > -1
                                  if match(buf, '\cQuickfix') > -1
                                    return g:airline#extensions#quickfix#quickfix_text
                                  else
                                    return g:airline#extensions#quickfix#location_text
                                  endif
                                endif
                              endfor
                              return ''
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/netrw.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000005 if !exists(':NetrwSettings')
                              finish
                            endif
                            
    1              0.000003 function! airline#extensions#netrw#apply(...)
                              if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif
                            endfunction
                            
    1              0.000003 function! airline#extensions#netrw#init(ext)
                              let g:netrw_force_overwrite_statusline = 0
                              call a:ext.add_statusline_func('airline#extensions#netrw#apply')
                            endfunction
                            
                            
    1              0.000003 function! airline#extensions#netrw#sortstring()
                              let order = (g:netrw_sort_direction =~ 'n') ? '+' : '-'
                              return g:netrw_sort_by . (g:airline_symbols.space) . '[' . order . ']'
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/syntastic.vim
Sourced 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000005 if !exists(':SyntasticCheck')
                              finish
                            endif
                            
    1              0.000003 function! airline#extensions#syntastic#get_warnings()
                              let errors = SyntasticStatuslineFlag()
                              if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
                              return ''
                            endfunction
                            
    1              0.000003 function! airline#extensions#syntastic#init(ext)
                              call airline#parts#define_function('syntastic', 'airline#extensions#syntastic#get_warnings')
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/whitespace.vim
Sourced 1 time
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
                            " http://got-ravings.blogspot.com/2008/10/vim-pr0n-statusline-whitespace-flags.html
                            
    1              0.000007 let s:show_message = get(g:, 'airline#extensions#whitespace#show_message', 1)
    1              0.000005 let s:symbol = get(g:, 'airline#extensions#whitespace#symbol', g:airline_symbols.whitespace)
    1              0.000004 let s:default_checks = ['indent', 'trailing', 'mixed-indent-file']
                            
    1              0.000004 let s:trailing_format = get(g:, 'airline#extensions#whitespace#trailing_format', 'trailing[%s]')
    1              0.000005 let s:mixed_indent_format = get(g:, 'airline#extensions#whitespace#mixed_indent_format', 'mixed-indent[%s]')
    1              0.000004 let s:long_format = get(g:, 'airline#extensions#whitespace#long_format', 'long[%s]')
    1              0.000005 let s:mixed_indent_file_format = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', 'mix-indent-file[%s]')
    1              0.000004 let s:indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000004 let s:skip_check_ft = {'make': ['indent', 'mixed-indent-file'] }
    1              0.000004 let s:max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    1              0.000003 let s:enabled = get(g:, 'airline#extensions#whitespace#enabled', 1)
    1              0.000006 let s:c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'javascript', 'ld', 'php' ])
                            
    1              0.000004 function! s:check_mixed_indent()
                              if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif s:indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
                                return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif
                            endfunction
                            
    1              0.000003 function! s:check_mixed_indent_file()
                              if index(s:c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
                                let head_spc = '\v(^ +)'
                              endif
                              let indent_tabs = search('\v(^\t+)', 'nw')
                              let indent_spc  = search(head_spc, 'nw')
                              if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000004 function! airline#extensions#whitespace#check()
                              if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                      \ || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
                              if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
                                let trailing = 0
                                if index(checks, 'trailing') > -1
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                    if long != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:long_format, long)
                                    endif
                                    if !empty(mixed_file)
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_file_format, mixed_file)
                                    endif
                                  endif
                                endif
                              endif
                              return b:airline_whitespace_check
                            endfunction
                            
    1              0.000004 function! airline#extensions#whitespace#toggle()
                              if s:enabled
                                augroup airline_whitespace
                                  autocmd!
                                augroup END
                                augroup! airline_whitespace
                                let s:enabled = 0
                              else
                                call airline#extensions#whitespace#init()
                                let s:enabled = 1
                              endif
                            
                              if exists("g:airline#extensions#whitespace#enabled")
                                let g:airline#extensions#whitespace#enabled = s:enabled
                                if s:enabled && match(g:airline_section_warning, '#whitespace#check') < 0
                                  let g:airline_section_warning .= airline#section#create(['whitespace'])
                                  call airline#update_statusline()
                                endif
                              endif
                              echo 'Whitespace checking: '.(s:enabled ? 'Enabled' : 'Disabled')
                            endfunction
                            
    1              0.000003 function! airline#extensions#whitespace#init(...)
                              call airline#parts#define_function('whitespace', 'airline#extensions#whitespace#check')
                            
                              unlet! b:airline_whitespace_check
                              augroup airline_whitespace
                                autocmd!
                                autocmd CursorHold,BufWritePost * call <sid>ws_refresh()
                              augroup END
                            endfunction
                            
    1              0.000002 function! s:ws_refresh()
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/po.vim
Sourced 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000004 function! airline#extensions#po#apply(...)
                              if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif
                            endfunction
                            
    1              0.000003 function! airline#extensions#po#stats()
                              if exists('b:airline_po_stats') && !empty(b:airline_po_stats)
                                return b:airline_po_stats
                              endif
                            
                              let airline_po_stats = system('msgfmt --statistics -o /dev/null -- '. expand('%:p'))
                              if v:shell_error
                                return ''
                              endif
                              try
                                let b:airline_po_stats = '['. split(airline_po_stats, '\n')[0]. ']'
                              catch
                                let b:airline_po_stats = ''
                              endtry
                              if exists("g:airline#extensions#po#displayed_limit")
                                let w:displayed_po_limit = g:airline#extensions#po#displayed_limit
                                if len(b:airline_po_stats) > w:displayed_po_limit - 1
                                  let b:airline_po_stats = b:airline_po_stats[0:(w:displayed_po_limit - 1)].(&encoding==?'utf-8' ? '…' : '.')
                                endif
                              endif
                              return b:airline_po_stats
                            endfunction
                            
    1              0.000003 function! airline#extensions#po#init(ext)
                                call a:ext.add_statusline_func('airline#extensions#po#apply')
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/wordcount.vim
Sourced 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000007 let s:filetypes = get(g:, 'airline#extensions#wordcount#filetypes', '\vhelp|markdown|rst|org|text|asciidoc')
    1              0.000005 let s:format = get(g:, 'airline#extensions#wordcount#format', '%d words')
    1              0.000004 let s:formatter = get(g:, 'airline#extensions#wordcount#formatter', 'default')
                            
    1              0.000003 function! s:update()
                              if match(&ft, s:filetypes) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' ||
                                        \ b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') ||
                                        \ get(b:, 'airline_change_tick', 0) != b:changedtick
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! airline#extensions#wordcount#apply(...)
                              if &ft =~ s:filetypes
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif
                            endfunction
                            
    1              0.000003 function! airline#extensions#wordcount#init(ext)
                              call a:ext.add_statusline_func('airline#extensions#wordcount#apply')
                              autocmd BufReadPost,CursorMoved,CursorMovedI * call s:update()
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim
Sourced 1 time
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000006 let s:formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    1              0.000004 let s:show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    1              0.000004 let s:show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
    1              0.000005 let s:ignore_bufadd_pat = get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '\c\vgundo|undotree|vimfiler|tagbar|nerd_tree')
                            
    1              0.000005 let s:taboo = get(g:, 'airline#extensions#taboo#enabled', 1) && get(g:, 'loaded_taboo', 0)
    1              0.000001 if s:taboo
                              let g:taboo_tabline = 0
                            endif
                            
    1              0.000003 let s:ctrlspace = get(g:, 'CtrlSpaceLoaded', 0)
                            
    1              0.000004 function! airline#extensions#tabline#init(ext)
                              if has('gui_running')
                                set guioptions-=e
                              endif
                            
                              autocmd User AirlineToggledOn call s:toggle_on()
                              autocmd User AirlineToggledOff call s:toggle_off()
                            
                              call s:toggle_on()
                              call a:ext.add_theme_func('airline#extensions#tabline#load_theme')
                            endfunction
                            
    1              0.000003 function! s:toggle_off()
                              call airline#extensions#tabline#autoshow#off()
                              call airline#extensions#tabline#tabs#off()
                              call airline#extensions#tabline#buffers#off()
                              call airline#extensions#tabline#ctrlspace#off()
                            endfunction
                            
    1              0.000002 function! s:toggle_on()
                              call airline#extensions#tabline#autoshow#on()
                              call airline#extensions#tabline#tabs#on()
                              call airline#extensions#tabline#buffers#on()
                              call airline#extensions#tabline#ctrlspace#on()
                            
                              set tabline=%!airline#extensions#tabline#get()
                            endfunction
                            
    1              0.000002 function! s:update_tabline()
                              if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
                              let match = expand('<afile>')
                              if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match)
                                    \ || match(match, s:ignore_bufadd_pat) > -1
                                    \ || isdirectory(expand("<afile>"))
                                return
                              endif
                              doautocmd User BufMRUChange
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#load_theme(palette)
                              if pumvisible()
                                return
                              endif
                              let colors    = get(a:palette, 'tabline', {})
                              " Theme for tabs on the left
                              let l:tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
                              let l:tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
                              let l:tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
                              let l:tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
                              let l:tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
                              let l:tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
                              if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
                              endif
                              call airline#highlighter#exec('airline_tab', l:tab)
                              call airline#highlighter#exec('airline_tabsel', l:tabsel)
                              call airline#highlighter#exec('airline_tabtype', l:tabtype)
                              call airline#highlighter#exec('airline_tabfill', l:tabfill)
                              call airline#highlighter#exec('airline_tabmod', l:tabmod)
                              call airline#highlighter#exec('airline_tabmod_unsel', l:tabmodu)
                              call airline#highlighter#exec('airline_tabhid', l:tabhid)
                            
                              " Theme for tabs on the right
                              let l:tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
                              let l:tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
                              let l:tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
                              let l:tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
                              if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
                              endif
                              call airline#highlighter#exec('airline_tab_right',    l:tab_right)
                              call airline#highlighter#exec('airline_tabsel_right', l:tabsel_right)
                              call airline#highlighter#exec('airline_tabmod_right', l:tabmod_right)
                              call airline#highlighter#exec('airline_tabhid_right', l:tabhid_right)
                              call airline#highlighter#exec('airline_tabmod_unsel_right', l:tabmodu_right)
                            endfunction
                            
    1              0.000003 let s:current_tabcnt = -1
    1              0.000003 function! airline#extensions#tabline#get()
                              let curtabcnt = tabpagenr('$')
                              if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
                              if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
                              if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif s:show_buffers && curtabcnt == 1 || !s:show_tabs
                                return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif
                            endfunction
                            
    1              0.000004 function! airline#extensions#tabline#title(n)
                              let title = ''
                              if s:taboo
                                let title = TabooTabTitle(a:n)
                              endif
                            
                              if empty(title) && exists('*gettabvar')
                                let title = gettabvar(a:n, 'title')
                              endif
                            
                              if empty(title)
                                let buflist = tabpagebuflist(a:n)
                                let winnr = tabpagewinnr(a:n)
                                return airline#extensions#tabline#get_buffer_name(buflist[winnr - 1])
                              endif
                            
                              return title
                            endfunction
                            
    1              0.000004 function! airline#extensions#tabline#get_buffer_name(nr)
                              return airline#extensions#tabline#formatters#{s:formatter}#format(a:nr, airline#extensions#tabline#buflist#list())
                            endfunction
                            
    1              0.000004 function! airline#extensions#tabline#new_builder()
                              let builder_context = {
                                    \ 'active'        : 1,
                                    \ 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep),
                                    \ 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep),
                                    \ }
                              if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
                              endif
                            
                              return airline#builder#new(builder_context)
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#group_of_bufnr(tab_bufs, bufnr)
                              let cur = bufnr('%')
                              if cur == a:bufnr
                                if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod'
                                else
                                  let group = 'airline_tabsel'
                                endif
                              else
                                if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
                                  let group = 'airline_tabhid'
                                endif
                              endif
                              return group
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/autoshow.vim
Sourced 1 time
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000006 let s:show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    1              0.000005 let s:buf_min_count = get(g:, 'airline#extensions#tabline#buffer_min_count', 0)
    1              0.000003 let s:tab_min_count = get(g:, 'airline#extensions#tabline#tab_min_count', 0)
                            
    1              0.000003 function! airline#extensions#tabline#autoshow#off()
                              if exists('s:original_tabline')
                                let &tabline = s:original_tabline
                                let &showtabline = s:original_showtabline
                              endif
                            
                              augroup airline_tabline_autoshow
                                autocmd!
                              augroup END
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#autoshow#on()
                              let [ s:original_tabline, s:original_showtabline ] = [ &tabline, &showtabline ]
                            
                              augroup airline_tabline_autoshow
                                autocmd!
                                if s:buf_min_count <= 0 && s:tab_min_count <= 1
                                  if &lines > 3
                                    set showtabline=2
                                  endif
                                else
                                  if s:show_buffers == 1
                                    autocmd BufEnter  * call <sid>show_tabline(s:buf_min_count, len(airline#extensions#tabline#buflist#list()))
                                    autocmd BufUnload * call <sid>show_tabline(s:buf_min_count, len(airline#extensions#tabline#buflist#list()) - 1)
                                  else
                                    autocmd TabEnter  * call <sid>show_tabline(s:tab_min_count, tabpagenr('$'))
                                  endif
                                endif
                            
                                " Invalidate cache.  This has to come after the BufUnload for
                                " s:show_buffers, to invalidate the cache for BufEnter.
                                autocmd BufLeave,BufAdd,BufUnload * call airline#extensions#tabline#buflist#invalidate()
                              augroup END
                            endfunction
                            
    1              0.000003 function! s:show_tabline(min_count, total_count)
                              if a:total_count >= a:min_count
                                if &showtabline != 2 && &lines > 3
                                  set showtabline=2
                                endif
                              else
                                if &showtabline != 0
                                  set showtabline=0
                                endif
                              endif
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/tabs.vim
Sourced 1 time
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000007 let s:show_close_button = get(g:, 'airline#extensions#tabline#show_close_button', 1)
    1              0.000004 let s:show_tab_type = get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    1              0.000004 let s:show_tab_nr = get(g:, 'airline#extensions#tabline#show_tab_nr', 1)
    1              0.000004 let s:tab_nr_type = get(g:, 'airline#extensions#tabline#tab_nr_type', 0)
    1              0.000004 let s:close_symbol = get(g:, 'airline#extensions#tabline#close_symbol', 'X')
    1              0.000004 let s:tabs_label = get(g:, 'airline#extensions#tabline#tabs_label', 'tabs')
    1              0.000004 let s:show_splits = get(g:, 'airline#extensions#tabline#show_splits', 1)
    1              0.000002 let s:spc = g:airline_symbols.space
                            
    1              0.000002 let s:current_bufnr = -1
    1              0.000003 let s:current_tabnr = -1
    1              0.000002 let s:current_modified = 0
                            
    1              0.000004 function! airline#extensions#tabline#tabs#off()
                              augroup airline_tabline_tabs
                                autocmd!
                              augroup END
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#tabs#on()
                              augroup airline_tabline_tabs
                                autocmd!
                                autocmd BufDelete * call airline#extensions#tabline#tabs#invalidate()
                              augroup END
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#tabs#invalidate()
                              let s:current_bufnr = -1
                            endfunction
                            
    1              0.000002 function! airline#extensions#tabline#tabs#get()
                              let curbuf = bufnr('%')
                              let curtab = tabpagenr()
                              call s:map_keys()
                              if curbuf == s:current_bufnr && curtab == s:current_tabnr
                                if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
                                  return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                            
                              for i in range(1, tabpagenr('$'))
                                if i == curtab
                                  let group = 'airline_tabsel'
                                  if g:airline_detect_modified
                                    for bi in tabpagebuflist(i)
                                      if getbufvar(bi, '&modified')
                                        let group = 'airline_tabmod'
                                      endif
                                    endfor
                                  endif
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                else
                                  let group = 'airline_tab'
                                endif
                                let val = '%('
                                if s:show_tab_nr
                                  if s:tab_nr_type == 0
                                    let val .= (g:airline_symbols.space).'%{len(tabpagebuflist('.i.'))}'
                                  elseif s:tab_nr_type == 1
                                    let val .= (g:airline_symbols.space).i
                                  else "== 2
                                    let val .= (g:airline_symbols.space).i.'.%{len(tabpagebuflist('.i.'))}'
                                  endif
                                endif
                                call b.add_section(group, val.'%'.i.'T %{airline#extensions#tabline#title('.i.')} %)')
                              endfor
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                            
                              if s:show_close_button
                                call b.add_section('airline_tab_right', ' %999X'.s:close_symbol.' ')
                              endif
                            
                              if s:show_splits == 1
                                let buffers = tabpagebuflist(curtab)
                                for nr in buffers
                                  let group = airline#extensions#tabline#group_of_bufnr(buffers, nr) . "_right"
                                  call b.add_section_spaced(group, '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)')
                                endfor
                              elseif s:show_tab_type == 1
                                call b.add_section_spaced('airline_tabtype', s:tabs_label)
                              endif
                            
                              let s:current_bufnr = curbuf
                              let s:current_tabnr = curtab
                              let s:current_tabline = b.build()
                              return s:current_tabline
                            endfunction
                            
    1              0.000003 function! s:map_keys()
                              noremap <silent> <Plug>AirlineSelectTab1 :1tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab2 :2tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab3 :3tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab4 :4tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab5 :5tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab6 :6tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab7 :7tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab8 :8tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab9 :9tabn<CR>
                              noremap <silent> <Plug>AirlineSelectPrevTab gT
                              " tabn {count} goes to count tab does not go {count} tab pages forward!
                              noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buffers.vim
Sourced 1 time
Total time:   0.000239
 Self time:   0.000239

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 scriptencoding utf-8
                            
    1              0.000005 let s:buffer_idx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
    1              0.000004 let s:show_tab_type = get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    1              0.000005 let s:buffers_label = get(g:, 'airline#extensions#tabline#buffers_label', 'buffers')
    1              0.000003 let s:spc = g:airline_symbols.space
                            
    1              0.000002 let s:current_bufnr = -1
    1              0.000002 let s:current_modified = 0
    1              0.000002 let s:current_tabline = ''
    1              0.000006 let s:current_visible_buffers = []
                            
    1              0.000012 let s:number_map = &encoding == 'utf-8'
                                  \ ? {
                                  \ '0': '⁰',
                                  \ '1': '¹',
                                  \ '2': '²',
                                  \ '3': '³',
                                  \ '4': '⁴',
                                  \ '5': '⁵',
                                  \ '6': '⁶',
                                  \ '7': '⁷',
                                  \ '8': '⁸',
                                  \ '9': '⁹'
                                  \ }
                                  \ : {}
                            
    1              0.000003 function! airline#extensions#tabline#buffers#off()
                              augroup airline_tabline_buffers
                                autocmd!
                              augroup END
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#buffers#on()
                              augroup airline_tabline_buffers
                                autocmd!
                                autocmd BufDelete * call airline#extensions#tabline#buffers#invalidate()
                                autocmd User BufMRUChange call airline#extensions#tabline#buflist#invalidate()
                                autocmd User BufMRUChange call airline#extensions#tabline#buffers#invalidate()
                              augroup END
                            endfunction
                            
    1              0.000007 function! airline#extensions#tabline#buffers#invalidate()
                              let s:current_bufnr = -1
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#buffers#get()
                              call <sid>map_keys()
                              let cur = bufnr('%')
                              if cur == s:current_bufnr
                                if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
                                  return s:current_tabline
                                endif
                              endif
                            
                              let l:index = 1
                              let b = airline#extensions#tabline#new_builder()
                              let tab_bufs = tabpagebuflist(tabpagenr())
                              for nr in s:get_visible_buffers()
                                if nr < 0
                                  call b.add_raw('%#airline_tabhid#...')
                                  continue
                                endif
                            
                                let group = airline#extensions#tabline#group_of_bufnr(tab_bufs, nr)
                            
                                if nr == cur
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                            
                                " Neovim feature: Have clickable buffers
                                if has("tablineat")
                                  call b.add_raw('%'.nr.'@airline#extensions#tabline#buffers#clickbuf@')
                                endif
                                if s:buffer_idx_mode
                                  if len(s:number_map) > 0
                                    call b.add_section(group, s:spc . get(s:number_map, l:index, '') . '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)' . s:spc)
                                  else
                                    call b.add_section(group, '['.l:index.s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.']')
                                  endif
                                  let l:index = l:index + 1
                                else
                                  call b.add_section(group, s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.s:spc)
                                endif
                                if has("tablineat")
                                  call b.add_raw('%X')
                                endif
                              endfor
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                              if s:show_tab_type
                                call b.add_section_spaced('airline_tabtype', s:buffers_label)
                              endif
                            
                              let s:current_bufnr = cur
                              let s:current_tabline = b.build()
                              return s:current_tabline
                            endfunction
                            
    1              0.000003 function! s:get_visible_buffers()
                              let buffers = airline#extensions#tabline#buflist#list()
                              let cur = bufnr('%')
                            
                              let total_width = 0
                              let max_width = 0
                            
                              for nr in buffers
                                let width = len(airline#extensions#tabline#get_buffer_name(nr)) + 4
                                let total_width += width
                                let max_width = max([max_width, width])
                              endfor
                            
                              " only show current and surrounding buffers if there are too many buffers
                              let position  = index(buffers, cur)
                              let vimwidth = &columns
                              if total_width > vimwidth && position > -1
                                let buf_count = len(buffers)
                            
                                " determine how many buffers to show based on the longest buffer width,
                                " use one on the right side and put the rest on the left
                                let buf_max   = vimwidth / max_width
                                let buf_right = 1
                                let buf_left  = max([0, buf_max - buf_right])
                            
                                let start = max([0, position - buf_left])
                                let end   = min([buf_count, position + buf_right])
                            
                                " fill up available space on the right
                                if position < buf_left
                                  let end += (buf_left - position)
                                endif
                            
                                " fill up available space on the left
                                if end > buf_count - 1 - buf_right
                                  let start -= max([0, buf_right - (buf_count - 1 - position)])
                                endif
                            
                                let buffers = eval('buffers[' . start . ':' . end . ']')
                            
                                if start > 0
                                  call insert(buffers, -1, 0)
                                endif
                            
                                if end < buf_count - 1
                                  call add(buffers, -1)
                                endif
                              endif
                            
                              let s:current_visible_buffers = buffers
                              return buffers
                            endfunction
                            
    1              0.000002 function! s:select_tab(buf_index)
                              " no-op when called in the NERDTree buffer
                              if exists('t:NERDTreeBufName') && bufname('%') == t:NERDTreeBufName
                                return
                              endif
                            
                              let idx = a:buf_index
                              if s:current_visible_buffers[0] == -1
                                let idx = idx + 1
                              endif
                            
                              let buf = get(s:current_visible_buffers, idx, 0)
                              if buf != 0
                                exec 'b!' . buf
                              endif
                            endfunction
                            
    1              0.000002 function! s:jump_to_tab(offset)
                                let l = s:current_visible_buffers
                                let i = index(l, bufnr('%'))
                                if i > -1
                                    exec 'b!' . l[float2nr(fmod(i + a:offset, len(l)))]
                                endif
                            endfunction
                            
    1              0.000002 function! s:map_keys()
                              if s:buffer_idx_mode
                                noremap <silent> <Plug>AirlineSelectTab1 :call <SID>select_tab(0)<CR>
                                noremap <silent> <Plug>AirlineSelectTab2 :call <SID>select_tab(1)<CR>
                                noremap <silent> <Plug>AirlineSelectTab3 :call <SID>select_tab(2)<CR>
                                noremap <silent> <Plug>AirlineSelectTab4 :call <SID>select_tab(3)<CR>
                                noremap <silent> <Plug>AirlineSelectTab5 :call <SID>select_tab(4)<CR>
                                noremap <silent> <Plug>AirlineSelectTab6 :call <SID>select_tab(5)<CR>
                                noremap <silent> <Plug>AirlineSelectTab7 :call <SID>select_tab(6)<CR>
                                noremap <silent> <Plug>AirlineSelectTab8 :call <SID>select_tab(7)<CR>
                                noremap <silent> <Plug>AirlineSelectTab9 :call <SID>select_tab(8)<CR>
                                noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
                                noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                              endif
                            endfunction
                            
    1              0.000004 function! airline#extensions#tabline#buffers#clickbuf(minwid, clicks, button, modifiers) abort
                                " Clickable buffers
                                " works only in recent NeoVim with has('tablineat')
                            
                                " single mouse button click without modifiers pressed
                                if a:clicks == 1 && a:modifiers !~# '[^ ]'
                                  if a:button is# 'l'
                                    " left button - switch to buffer
                                    silent execute 'buffer' a:minwid
                                  elseif a:button is# 'm'
                                    " middle button - delete buffer
                                    silent execute 'bdelete' a:minwid
                                  endif
                                endif
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/ctrlspace.vim
Sourced 1 time
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2016 Kevin Sapper
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000003 let s:current_bufnr = -1
    1              0.000002 let s:current_tabnr = -1
    1              0.000002 let s:current_tabline = ''
                            
    1              0.000005 let s:buffers_label = get(g:, 'airline#extensions#tabline#buffers_label', 'buffers')
    1              0.000005 let s:tabs_label = get(g:, 'airline#extensions#tabline#tabs_label', 'tabs')
    1              0.000004 let s:switch_buffers_and_tabs = get(g:, 'airline#extensions#tabline#switch_buffers_and_tabs', 0)
    1              0.000004 let s:show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    1              0.000004 let s:show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    1              0.000004 function! airline#extensions#tabline#ctrlspace#off()
                              augroup airline_tabline_ctrlspace
                                autocmd!
                              augroup END
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#ctrlspace#on()
                              augroup airline_tabline_ctrlspace
                                autocmd!
                                autocmd BufDelete * call airline#extensions#tabline#ctrlspace#invalidate()
                              augroup END
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#ctrlspace#invalidate()
                              let s:current_bufnr = -1
                              let s:current_tabnr = -1
                            endfunction
                            
    1              0.000005 function! airline#extensions#tabline#ctrlspace#add_buffer_section(builder, cur_tab, cur_buf, pos)
                              if a:pos == 0
                                let pos_extension = ''
                              else
                                let pos_extension = '_right'
                              endif
                            
                              let s:buffer_list = ctrlspace#api#BufferList(a:cur_tab)
                              for buffer in s:buffer_list
                                  if a:cur_buf == buffer.index
                                    if buffer.modified
                                      let group = 'airline_tabmod'.pos_extension
                                    else
                                      let group = 'airline_tabsel'.pos_extension
                                    endif
                                  else
                                    if buffer.modified
                                      let group = 'airline_tabmod_unsel'.pos_extension
                                    elseif buffer.visible
                                      let group = 'airline_tab'.pos_extension
                                    else
                                      let group = 'airline_tabhid'.pos_extension
                                    endif
                                  endif
                            
                                  let buf_name = '%(%{airline#extensions#tabline#get_buffer_name('.buffer.index.')}%)'
                            
                                  if has("tablineat")
                                    let buf_name = '%'.buffer.index.'@airline#extensions#tabline#buffers#switchbuf@'.buf_name.'%X'
                                  endif
                            
                                  call a:builder.add_section_spaced(group, buf_name)
                              endfor
                            endfunction
                            
    1              0.000004 function! airline#extensions#tabline#ctrlspace#add_tab_section(builder, pos)
                              if a:pos == 0
                                let pos_extension = ''
                              else
                                let pos_extension = '_right'
                              endif
                            
                              for tab in s:tab_list
                                if tab.current
                                  if tab.modified
                                    let group = 'airline_tabmod'.pos_extension
                                  else
                                    let group = 'airline_tabsel'.pos_extension
                                  endif
                                else
                                  if tab.modified
                                    let group = 'airline_tabmod_unsel'.pos_extension
                                  else
                                    let group = 'airline_tabhid'.pos_extension
                                  endif
                                endif
                            
                                call a:builder.add_section_spaced(group, '%'.tab.index.'T'.tab.title.ctrlspace#api#TabBuffersNumber(tab.index).'%T')
                              endfor
                            endfunction
                            
    1              0.000003 function! airline#extensions#tabline#ctrlspace#get()
                              let cur_buf = bufnr('%')
                            
                              let s:tab_list = ctrlspace#api#TabList()
                              for tab in s:tab_list
                                if tab.current
                                  let cur_tab = tab.index
                                endif
                              endfor
                            
                              if cur_buf == s:current_bufnr && cur_tab == s:current_tabnr
                                return s:current_tabline
                              endif
                            
                              let builder = airline#extensions#tabline#new_builder()
                            
                              " Add left tabline content
                              if s:show_buffers == 0
                                  call airline#extensions#tabline#ctrlspace#add_tab_section(builder, 0)
                              elseif s:show_tabs == 0
                                  call airline#extensions#tabline#ctrlspace#add_buffer_section(builder, cur_tab, cur_buf, 0)
                              else
                                if s:switch_buffers_and_tabs == 0
                                  call builder.add_section_spaced('airline_tabtype', s:buffers_label)
                                  call airline#extensions#tabline#ctrlspace#add_buffer_section(builder, cur_tab, cur_buf, 0)
                                else
                                  call builder.add_section_spaced('airline_tabtype', s:tabs_label)
                                  call airline#extensions#tabline#ctrlspace#add_tab_section(builder, 0)
                                endif
                              endif
                            
                              call builder.add_section('airline_tabfill', '')
                              call builder.split()
                              call builder.add_section('airline_tabfill', '')
                            
                              " Add right tabline content
                              if s:show_buffers == 0
                                  call builder.add_section_spaced('airline_tabtype', s:tabs_label)
                              elseif s:show_tabs == 0
                                  call builder.add_section_spaced('airline_tabtype', s:buffers_label)
                              else
                                if s:switch_buffers_and_tabs == 0
                                  call airline#extensions#tabline#ctrlspace#add_tab_section(builder, 1)
                                  call builder.add_section_spaced('airline_tabtype', s:tabs_label)
                                else
                                  call airline#extensions#tabline#ctrlspace#add_buffer_section(builder, cur_tab, cur_buf, 1)
                                  call builder.add_section_spaced('airline_tabtype', s:buffers_label)
                                endif
                              endif
                            
                              let s:current_bufnr = cur_buf
                              let s:current_tabnr = cur_tab
                              let s:current_tabline = builder.build()
                              return s:current_tabline
                            endfunction

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/section.vim
Sourced 1 time
Total time:   0.000085
 Self time:   0.000081

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1   0.000011   0.000007 call airline#init#bootstrap()
    1              0.000003 let s:spc = g:airline_symbols.space
                            
    1              0.000003 function! s:wrap_accent(part, value)
                              if exists('a:part.accent')
                                call airline#highlighter#add_accent(a:part.accent)
                                return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value
                            endfunction
                            
    1              0.000003 function! s:create(parts, append)
                              let _ = ''
                              for idx in range(len(a:parts))
                                let part = airline#parts#get(a:parts[idx])
                                let val = ''
                            
                                if exists('part.function')
                                  let func = (part.function).'()'
                                elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let val = s:spc.g:airline_right_alt_sep.s:spc.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
                                let minwidth = get(part, 'minwidth', 0)
                            
                                if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                else
                                  let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
                                endif
                            
                                if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
                                let val .= s:wrap_accent(part, partval)
                                let _ .= val
                              endfor
                              return _
                            endfunction
                            
    1              0.000003 function! airline#section#create(parts)
                              return s:create(a:parts, 0)
                            endfunction
                            
    1              0.000003 function! airline#section#create_left(parts)
                              return s:create(a:parts, 1)
                            endfunction
                            
    1              0.000003 function! airline#section#create_right(parts)
                              return s:create(a:parts, -1)
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/highlighter.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000014 let s:is_win32term = (has('win32') || has('win64')) && !has('gui_running') && (empty($CONEMUBUILD) || &term !=? 'xterm')
                            
    1              0.000003 let s:separators = {}
    1              0.000002 let s:accents = {}
                            
    1              0.000003 function! s:gui2cui(rgb, fallback)
                              if a:rgb == ''
                                return a:fallback
                              elseif match(a:rgb, '^\%(NONE\|[fb]g\)$') > -1
                                return a:rgb
                              endif
                              let rgb = map(split(a:rgb[1:], '..\zs'), '0 + ("0x".v:val)')
                              return airline#msdos#round_msdos_colors(rgb)
                            endfunction
                            
    1              0.000003 function! s:get_syn(group, what)
                              if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
                              let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
                              if empty(color) || color == -1
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                              endif
                              if empty(color) || color == -1
                                let color = 'NONE'
                              endif
                              return color
                            endfunction
                            
    1              0.000003 function! s:get_array(fg, bg, opts)
                              let fg = a:fg
                              let bg = a:bg
                              return g:airline_gui_mode ==# 'gui'
                                    \ ? [ fg, bg, '', '', join(a:opts, ',') ]
                                    \ : [ '', '', fg, bg, join(a:opts, ',') ]
                            endfunction
                            
    1              0.000003 function! airline#highlighter#get_highlight(group, ...)
                              let fg = s:get_syn(a:group, 'fg')
                              let bg = s:get_syn(a:group, 'bg')
                              let reverse = g:airline_gui_mode ==# 'gui'
                                    \ ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui')
                                    \ : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
                                    \|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
                              return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)
                            endfunction
                            
    1              0.000003 function! airline#highlighter#get_highlight2(fg, bg, ...)
                              let fg = s:get_syn(a:fg[0], a:fg[1])
                              let bg = s:get_syn(a:bg[0], a:bg[1])
                              return s:get_array(fg, bg, a:000)
                            endfunction
                            
    1              0.000003 function! airline#highlighter#exec(group, colors)
                              if pumvisible()
                                return
                              endif
                              let colors = a:colors
                              if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
                              let cmd= printf('hi %s %s %s %s %s %s %s %s',
                                    \ a:group, s:Get(colors, 0, 'guifg=', ''), s:Get(colors, 1, 'guibg=', ''),
                                    \ s:Get(colors, 2, 'ctermfg=', ''), s:Get(colors, 3, 'ctermbg=', ''),
                                    \ s:Get(colors, 4, 'gui=', ''), s:Get(colors, 4, 'cterm=', ''),
                                    \ s:Get(colors, 4, 'term=', ''))
                              let old_hi = airline#highlighter#get_highlight(a:group)
                              if len(colors) == 4
                                call add(colors, '')
                              endif
                              if old_hi != colors
                                exe cmd
                              endif
                            endfunction
                            
    1              0.000003 function! s:Get(dict, key, prefix, default)
                              if get(a:dict, a:key, a:default) isnot# a:default
                                return a:prefix. get(a:dict, a:key)
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000003 function! s:exec_separator(dict, from, to, inverse, suffix)
                              if pumvisible()
                                return
                              endif
                              let l:from = airline#themes#get_highlight(a:from.a:suffix)
                              let l:to = airline#themes#get_highlight(a:to.a:suffix)
                              let group = a:from.'_to_'.a:to.a:suffix
                              if a:inverse
                                let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
                              else
                                let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
                              endif
                              let a:dict[group] = colors
                              call airline#highlighter#exec(group, colors)
                            endfunction
                            
    1              0.000003 function! airline#highlighter#load_theme()
                              if pumvisible()
                                return
                              endif
                              for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
                              call airline#highlighter#highlight(['inactive'])
                              call airline#highlighter#highlight(['normal'])
                            endfunction
                            
    1              0.000003 function! airline#highlighter#add_separator(from, to, inverse)
                              let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
                              call <sid>exec_separator({}, a:from, a:to, a:inverse, '')
                            endfunction
                            
    1              0.000003 function! airline#highlighter#add_accent(accent)
                              let s:accents[a:accent] = 1
                            endfunction
                            
    1              0.000003 function! airline#highlighter#highlight_modified_inactive(bufnr)
                              if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c')
                                      \ ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c')
                                      \ ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
                              endif
                            
                              if !empty(colors)
                                call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
                              endif
                            endfunction
                            
    1              0.000002 function! airline#highlighter#highlight(modes)
                              let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
                              let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
                              let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
                              for mode in mapped
                                if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
                                  let dict = g:airline#themes#{g:airline_theme}#palette[mode]
                                  for kvp in items(dict)
                                    let mode_colors = kvp[1]
                                    call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
                                    for accent in keys(s:accents)
                                      if !has_key(p.accents, accent)
                                        continue
                                      endif
                                      let colors = copy(mode_colors)
                                      if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
                                      endif
                                      if p.accents[accent][2] != ''
                                        let colors[2] = p.accents[accent][2]
                                      endif
                                      if len(colors) >= 5
                                        let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
                                      call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
                                    endfor
                                  endfor
                            
                                  " TODO: optimize this
                                  for sep in items(s:separators)
                                    call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
                                  endfor
                                endif
                              endfor
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline-themes/autoload/airline/themes/base16.vim
Sourced 1 time
Total time:   0.002097
 Self time:   0.000206

count  total (s)   self (s)
                            if get(g:, 'airline#themes#base16#constant', 0)
                              let g:airline#themes#base16#palette = {}
                            
                              " Color palette
                              let s:gui_dark_gray = '#202020'
                              let s:cterm_dark_gray = 234
                              let s:gui_med_gray_hi = '#303030'
                              let s:cterm_med_gray_hi = 236
                              let s:gui_med_gray_lo = '#3a3a3a'
                              let s:cterm_med_gray_lo = 237
                              let s:gui_light_gray = '#505050'
                              let s:cterm_light_gray = 239
                              let s:gui_green = '#99cc99'
                              let s:cterm_green = 151
                              let s:gui_blue = '#6a9fb5'
                              let s:cterm_blue = 67
                              let s:gui_purple = '#aa759f'
                              let s:cterm_purple = 139
                              let s:gui_orange = '#d28445'
                              let s:cterm_orange = 173
                              let s:gui_red = '#ac4142'
                              let s:cterm_red = 131
                              let s:gui_pink = '#d7afd7'
                              let s:cterm_pink = 182
                            
                              " Normal mode
                              let s:N1 = [s:gui_dark_gray, s:gui_green, s:cterm_dark_gray, s:cterm_green]
                              let s:N2 = [s:gui_light_gray, s:gui_med_gray_lo, s:cterm_light_gray, s:cterm_med_gray_lo]
                              let s:N3 = [s:gui_green, s:gui_med_gray_hi, s:cterm_green, s:cterm_med_gray_hi]
                              let g:airline#themes#base16#palette.normal = airline#themes#generate_color_map(s:N1, s:N2, s:N3)
                              let g:airline#themes#base16#palette.normal_modified = {
                                    \ 'airline_c': [s:gui_orange, s:gui_med_gray_hi, s:cterm_orange, s:cterm_med_gray_hi, ''],
                                    \ }
                            
                              " Insert mode
                              let s:I1 = [s:gui_med_gray_hi, s:gui_blue, s:cterm_med_gray_hi, s:cterm_blue]
                              let s:I3 = [s:gui_blue, s:gui_med_gray_hi, s:cterm_blue, s:cterm_med_gray_hi]
                              let g:airline#themes#base16#palette.insert = airline#themes#generate_color_map(s:I1, s:N2, s:I3)
                              let g:airline#themes#base16#palette.insert_modified = copy(g:airline#themes#base16#palette.normal_modified)
                              let g:airline#themes#base16#palette.insert_paste = {
                                    \ 'airline_a': [s:gui_dark_gray, s:gui_orange, s:cterm_dark_gray, s:cterm_orange, ''],
                                    \ }
                            
                              " Replace mode
                              let g:airline#themes#base16#palette.replace = {
                                    \ 'airline_a': [s:gui_dark_gray, s:gui_red, s:cterm_dark_gray, s:cterm_red, ''],
                                    \ 'airline_c': [s:gui_red, s:gui_med_gray_hi, s:cterm_red, s:cterm_med_gray_hi, ''],
                                    \ }
                              let g:airline#themes#base16#palette.replace_modified = copy(g:airline#themes#base16#palette.insert_modified)
                            
                              " Visual mode
                              let s:V1 = [s:gui_dark_gray, s:gui_pink, s:cterm_dark_gray, s:cterm_pink]
                              let s:V3 = [s:gui_pink, s:gui_med_gray_hi, s:cterm_pink, s:cterm_med_gray_hi]
                              let g:airline#themes#base16#palette.visual = airline#themes#generate_color_map(s:V1, s:N2, s:V3)
                              let g:airline#themes#base16#palette.visual_modified = copy(g:airline#themes#base16#palette.insert_modified)
                            
                              " Inactive window
                              let s:IA = [s:gui_dark_gray, s:gui_med_gray_hi, s:cterm_dark_gray, s:cterm_med_gray_hi, '']
                              let g:airline#themes#base16#palette.inactive = airline#themes#generate_color_map(s:IA, s:IA, s:IA)
                              let g:airline#themes#base16#palette.inactive_modified = {
                                    \ 'airline_c': [s:gui_orange, '', s:cterm_orange, '', ''],
                                    \ }
                            else
    1              0.000004   function! airline#themes#base16#refresh()
                                let g:airline#themes#base16#palette = {}
                            
                                let g:airline#themes#base16#palette.accents = {
                                      \ 'red': airline#themes#get_highlight('Constant'),
                                      \ }
                            
                                let s:N1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['DiffText', 'fg'], 'bold')
                                let s:N2 = airline#themes#get_highlight2(['Visual', 'fg'], ['Visual', 'bg'])
                                let s:N3 = airline#themes#get_highlight('CursorLine')
                                let g:airline#themes#base16#palette.normal = airline#themes#generate_color_map(s:N1, s:N2, s:N3)
                            
                                let group = airline#themes#get_highlight('vimCommand')
                                let g:airline#themes#base16#palette.normal_modified = {
                                      \ 'statusline': [ group[0], '', group[2], '', '' ]
                                      \ }
                            
                                let s:I1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['DiffAdded', 'fg'], 'bold')
                                let s:I2 = airline#themes#get_highlight2(['DiffAdded', 'fg'], ['Normal', 'bg'])
                                let s:I3 = s:N3
                                let g:airline#themes#base16#palette.insert = airline#themes#generate_color_map(s:I1, s:I2, s:I3)
                                let g:airline#themes#base16#palette.insert_modified = g:airline#themes#base16#palette.normal_modified
                            
                                let s:R1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['WarningMsg', 'fg'], 'bold')
                                let s:R2 = s:N2
                                let s:R3 = s:N3
                                let g:airline#themes#base16#palette.replace = airline#themes#generate_color_map(s:R1, s:R2, s:R3)
                                let g:airline#themes#base16#palette.replace_modified = g:airline#themes#base16#palette.normal_modified
                            
                                let s:V1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['Constant', 'fg'], 'bold')
                                let s:V2 = airline#themes#get_highlight2(['Constant', 'fg'], ['Normal', 'bg'])
                                let s:V3 = s:N3
                                let g:airline#themes#base16#palette.visual = airline#themes#generate_color_map(s:V1, s:V2, s:V3)
                                let g:airline#themes#base16#palette.visual_modified = g:airline#themes#base16#palette.normal_modified
                            
                                " Use VertSplit's bg and default fg (reversed) for inactive statusline.
                                let s:VS = airline#themes#get_highlight('VertSplit')
                                let s:IA = [ s:VS[1], 'NONE', s:VS[2], 'NONE', 'reverse']
                                let g:airline#themes#base16#palette.inactive =
                                      \ airline#themes#generate_color_map(s:IA, s:IA, s:IA, s:IA, s:IA, s:IA)
                                let s:IM = [ s:VS[1], 'NONE', s:VS[2], 'NONE', 'reverse,italic']
                                let g:airline#themes#base16#palette.inactive_modified =
                                      \ airline#themes#generate_color_map(s:IM, s:IM, s:IM, s:IM, s:IM, s:IM)
                            
                                " Warnings
                                let s:WI = airline#themes#get_highlight2(['WarningMsg', 'bg'], ['WarningMsg', 'fg'], 'bold')
                                let g:airline#themes#base16#palette.normal.airline_warning = [
                                     \ s:WI[0], s:WI[1], s:WI[2], s:WI[3]
                                     \ ]
                            
                                let g:airline#themes#base16#palette.normal_modified.airline_warning =
                                    \ g:airline#themes#base16#palette.normal.airline_warning
                            
                                let g:airline#themes#base16#palette.insert.airline_warning =
                                    \ g:airline#themes#base16#palette.normal.airline_warning
                            
                                let g:airline#themes#base16#palette.insert_modified.airline_warning =
                                    \ g:airline#themes#base16#palette.normal.airline_warning
                            
                                let g:airline#themes#base16#palette.visual.airline_warning =
                                    \ g:airline#themes#base16#palette.normal.airline_warning
                            
                                let g:airline#themes#base16#palette.visual_modified.airline_warning =
                                    \ g:airline#themes#base16#palette.normal.airline_warning
                            
                                let g:airline#themes#base16#palette.replace.airline_warning =
                                    \ g:airline#themes#base16#palette.normal.airline_warning
                            
                                let g:airline#themes#base16#palette.replace_modified.airline_warning =
                                    \ g:airline#themes#base16#palette.normal.airline_warning
                            
                                " Errors
                                let s:ER = airline#themes#get_highlight2(['ErrorMsg', 'bg'], ['ErrorMsg', 'fg'], 'bold')
                                let g:airline#themes#base16#palette.normal.airline_error = [
                                     \ s:ER[0], s:ER[1], s:ER[2], s:ER[3]
                                     \ ]
                            
                                let g:airline#themes#base16#palette.normal_modified.airline_error =
                                    \ g:airline#themes#base16#palette.normal.airline_error
                            
                                let g:airline#themes#base16#palette.insert.airline_error =
                                    \ g:airline#themes#base16#palette.normal.airline_error
                            
                                let g:airline#themes#base16#palette.insert_modified.airline_error =
                                    \ g:airline#themes#base16#palette.normal.airline_error
                            
                                let g:airline#themes#base16#palette.visual.airline_error =
                                    \ g:airline#themes#base16#palette.normal.airline_error
                            
                                let g:airline#themes#base16#palette.visual_modified.airline_error =
                                    \ g:airline#themes#base16#palette.normal.airline_error
                            
                                let g:airline#themes#base16#palette.replace.airline_error =
                                    \ g:airline#themes#base16#palette.normal.airline_error
                            
                                let g:airline#themes#base16#palette.replace_modified.airline_error =
                                    \ g:airline#themes#base16#palette.normal.airline_error
                            
                              endfunction
    1              0.000102   call airline#themes#base16#refresh()
    1              0.000004 endif

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/themes.vim
Sourced 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
                            " generates a dictionary which defines the colors for each highlight group
    1              0.000004 function! airline#themes#generate_color_map(sect1, sect2, sect3, ...)
                              let palette = {
                                    \ 'airline_a': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , get(a:sect1 , 4 , '') ] ,
                                    \ 'airline_b': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , get(a:sect2 , 4 , '') ] ,
                                    \ 'airline_c': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , get(a:sect3 , 4 , '') ] ,
                                    \ }
                            
                              if a:0 > 0
                                call extend(palette, {
                                      \ 'airline_x': [ a:1[0] , a:1[1] , a:1[2] , a:1[3] , get(a:1 , 4 , '' ) ] ,
                                      \ 'airline_y': [ a:2[0] , a:2[1] , a:2[2] , a:2[3] , get(a:2 , 4 , '' ) ] ,
                                      \ 'airline_z': [ a:3[0] , a:3[1] , a:3[2] , a:3[3] , get(a:3 , 4 , '' ) ] ,
                                      \ })
                              else
                                call extend(palette, {
                                      \ 'airline_x': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , '' ] ,
                                      \ 'airline_y': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , '' ] ,
                                      \ 'airline_z': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , '' ] ,
                                      \ })
                              endif
                            
                              return palette
                            endfunction
                            
    1              0.000003 function! airline#themes#get_highlight(group, ...)
                              return call('airline#highlighter#get_highlight', [a:group] + a:000)
                            endfunction
                            
    1              0.000003 function! airline#themes#get_highlight2(fg, bg, ...)
                              return call('airline#highlighter#get_highlight2', [a:fg, a:bg] + a:000)
                            endfunction
                            
    1              0.000003 function! airline#themes#patch(palette)
                              for mode in keys(a:palette)
                                if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
                                endif
                                if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
                                endif
                              endfor
                            
                              let a:palette.accents = get(a:palette, 'accents', {})
                              let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
                              let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
                              if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
                              if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
                              if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
                              if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
                              if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
                              if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/util.vim
Sourced 1 time
Total time:   0.000104
 Self time:   0.000099

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1   0.000011   0.000006 call airline#init#bootstrap()
    1              0.000003 let s:spc = g:airline_symbols.space
                            
    1              0.000003 function! airline#util#wrap(text, minwidth)
                              if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
                              return a:text
                            endfunction
                            
    1              0.000003 function! airline#util#append(text, minwidth)
                              if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
                              let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
                              return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text
                            endfunction
                            
    1              0.000003 function! airline#util#warning(msg)
                              echohl WarningMsg
                              echomsg "airline: ".a:msg
                              echohl Normal
                            endfunction
                            
    1              0.000003 function! airline#util#prepend(text, minwidth)
                              if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
                              return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc
                            endfunction
                            
    1              0.000002 if v:version >= 704
    1              0.000003   function! airline#util#getwinvar(winnr, key, def)
                                return getwinvar(a:winnr, a:key, a:def)
                              endfunction
    1              0.000001 else
                              function! airline#util#getwinvar(winnr, key, def)
                                let winvals = getwinvar(a:winnr, '')
                                return get(winvals, a:key, a:def)
                              endfunction
                            endif
                            
    1              0.000001 if v:version >= 704
    1              0.000003   function! airline#util#exec_funcrefs(list, ...)
                                for Fn in a:list
                                  let code = call(Fn, a:000)
                                  if code != 0
                                    return code
                                  endif
                                endfor
                                return 0
                              endfunction
    1              0.000001 else
                              function! airline#util#exec_funcrefs(list, ...)
                                " for 7.2; we cannot iterate the list, hence why we use range()
                                " for 7.3-[97, 328]; we cannot reuse the variable, hence the {}
                                for i in range(0, len(a:list) - 1)
                                  let Fn{i} = a:list[i]
                                  let code = call(Fn{i}, a:000)
                                  if code != 0
                                    return code
                                  endif
                                endfor
                                return 0
                              endfunction
                            endif
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/builder.vim
Sourced 1 time
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000004 let s:prototype = {}
                            
    1              0.000003 function! s:prototype.split(...)
                              call add(self._sections, ['|', a:0 ? a:1 : '%='])
                            endfunction
                            
    1              0.000002 function! s:prototype.add_section_spaced(group, contents)
                              let spc = empty(a:contents) ? '' : g:airline_symbols.space
                              call self.add_section(a:group, spc.a:contents.spc)
                            endfunction
                            
    1              0.000002 function! s:prototype.add_section(group, contents)
                              call add(self._sections, [a:group, a:contents])
                            endfunction
                            
    1              0.000001 function! s:prototype.add_raw(text)
                              call add(self._sections, ['', a:text])
                            endfunction
                            
    1              0.000003 function! s:get_prev_group(sections, i)
                              let x = a:i - 1
                              while x >= 0
                                let group = a:sections[x][0]
                                if group != '' && group != '|'
                                  return group
                                endif
                                let x = x - 1
                              endwhile
                              return ''
                            endfunction
                            
    1              0.000002 function! s:prototype.build()
                              let side = 1
                              let line = ''
                              let i = 0
                              let length = len(self._sections)
                              let split = 0
                              let is_empty = 0
                              let prev_group = ''
                            
                              while i < length
                                let section = self._sections[i]
                                let group = section[0]
                                let contents = section[1]
                                let pgroup = prev_group
                                let prev_group = s:get_prev_group(self._sections, i)
                                if is_empty
                                  let prev_group = pgroup
                                endif
                                let is_empty = s:section_is_empty(self, contents)
                            
                                if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the 
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
                                if group == ''
                                  let line .= contents
                                elseif group == '|'
                                  let side = 0
                                  let line .= contents
                                  let split = 1
                                else
                                  if prev_group == ''
                                    let line .= '%#'.group.'#'
                                  elseif split
                                    if !is_empty
                                      let line .= s:get_transitioned_seperator(self, prev_group, group, side)
                                    endif
                                    let split = 0
                                  else
                                    if !is_empty
                                      let line .= s:get_seperator(self, prev_group, group, side)
                                    endif
                                  endif
                                  let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
                                endif
                            
                                let i = i + 1
                              endwhile
                            
                              if !self._context.active
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
                              return line
                            endfunction
                            
    1              0.000003 function! s:should_change_group(group1, group2)
                              if a:group1 == a:group2
                                return 0
                              endif
                              let color1 = airline#highlighter#get_highlight(a:group1)
                              let color2 = airline#highlighter#get_highlight(a:group2)
                              if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif
                            endfunction
                            
    1              0.000003 function! s:get_transitioned_seperator(self, prev_group, group, side)
                              let line = ''
                              call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
                              let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                              let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
                              let line .= '%#'.a:group.'#'
                              return line
                            endfunction
                            
    1              0.000003 function! s:get_seperator(self, prev_group, group, side)
                              if s:should_change_group(a:prev_group, a:group)
                                return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif
                            endfunction
                            
    1              0.000003 function! s:get_accented_line(self, group, contents)
                              if a:self._context.active
                                let contents = []
                                let content_parts = split(a:contents, '__accent')
                                for cpart in content_parts
                                  let accent = matchstr(cpart, '_\zs[^#]*\ze')
                                  call add(contents, cpart)
                                endfor
                                let line = join(contents, a:group)
                                let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
                              return line
                            endfunction
                            
    1              0.000002 function! s:section_is_empty(self, content)
                              let start=1
                            
                              " do not check for inactive windows
                              if a:self._context.active == 0
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(g:, 'airline_skip_empty_sections', 0) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1
                            endfunction
                            
    1              0.000004 function! airline#builder#new(context)
                              let builder = copy(s:prototype)
                              let builder._context = a:context
                              let builder._sections = []
                            
                              call extend(builder._context, {
                                    \ 'left_sep': g:airline_left_sep,
                                    \ 'left_alt_sep': g:airline_left_alt_sep,
                                    \ 'right_sep': g:airline_right_sep,
                                    \ 'right_alt_sep': g:airline_right_alt_sep,
                                    \ }, 'keep')
                              return builder
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim
Sourced 1 time
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000010 let s:section_use_groups     = get(g:, 'airline#extensions#default#section_use_groupitems', 1)
    1              0.000014 let s:section_truncate_width = get(g:, 'airline#extensions#default#section_truncate_width', {
                                  \ 'b': 79,
                                  \ 'x': 60,
                                  \ 'y': 88,
                                  \ 'z': 45,
                                  \ 'warning': 80,
                                  \ 'error': 80,
                                  \ })
    1              0.000011 let s:layout = get(g:, 'airline#extensions#default#layout', [
                                  \ [ 'a', 'b', 'c' ],
                                  \ [ 'x', 'y', 'z', 'warning', 'error' ]
                                  \ ])
                            
    1              0.000005 function! s:get_section(winnr, key, ...)
                              if has_key(s:section_truncate_width, a:key)
                                if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
                              endif
                              let spc = g:airline_symbols.space
                              if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
                              let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
                              let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
                              return empty(text) ? '' : prefix.text.suffix
                            endfunction
                            
    1              0.000004 function! s:build_sections(builder, context, keys)
                              for key in a:keys
                                if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
                                call s:add_section(a:builder, a:context, key)
                              endfor
                            endfunction
                            
                            " There still is a highlighting bug when using groups %(%) in the statusline,
                            " deactivate it, until this is properly fixed:
                            " https://groups.google.com/d/msg/vim_dev/sb1jmVirXPU/mPhvDnZ-CwAJ
    1              0.000005 if s:section_use_groups && (v:version >= 704 || (v:version >= 703 && has('patch81')))
    1              0.000003   function! s:add_section(builder, context, key)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
                                if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
                                if (a:key == 'warning' || a:key == 'error')
                                  call a:builder.add_raw('%(')
                                endif
                                call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
                                if (a:key == 'warning' || a:key == 'error')
                                  call a:builder.add_raw('%)')
                                endif
                              endfunction
    1              0.000006 else
                              " older version don't like the use of %(%)
                              function! s:add_section(builder, context, key)
                                if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
                                if a:key == 'warning'
                                  call a:builder.add_raw('%#airline_warning#'.s:get_section(a:context.winnr, a:key))
                                elseif a:key == 'error'
                                  call a:builder.add_raw('%#airline_error#'.s:get_section(a:context.winnr, a:key))
                                else
                                  call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
                                endif
                              endfunction
                            endif
                            
    1              0.000005 function! airline#extensions#default#apply(builder, context)
                              let winnr = a:context.winnr
                              let active = a:context.active
                            
                              if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
                                call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
                              call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
                              if airline#util#getwinvar(winnr, 'airline_render_right', 1)
                                call s:build_sections(a:builder, a:context, s:layout[1])
                              endif
                            
                              return 1
                            endfunction
                            

SCRIPT  /Users/manny/.vim/bundle/syntastic/autoload/syntastic/log.vim
Sourced 1 time
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_log_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
                            endif
    1              0.000003 let g:loaded_syntastic_log_autoload = 1
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 let s:one_time_notices_issued = []
                            
                            " Public functions {{{1
                            
    1              0.000004 function! syntastic#log#info(msg) abort " {{{2
                                echomsg 'syntastic: info: ' . a:msg
                            endfunction " }}}2
                            
    1              0.000006 function! syntastic#log#warn(msg) abort " {{{2
                                echohl WarningMsg
                                echomsg 'syntastic: warning: ' . a:msg
                                echohl None
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#log#error(msg) abort " {{{2
                                execute "normal \<Esc>"
                                echohl ErrorMsg
                                echomsg 'syntastic: error: ' . a:msg
                                echohl None
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#log#oneTimeWarn(msg) abort " {{{2
                                if index(s:one_time_notices_issued, a:msg) >= 0
                                    return
                                endif
                            
                                call add(s:one_time_notices_issued, a:msg)
                                call syntastic#log#warn(a:msg)
                            endfunction " }}}2
                            
                            " @vimlint(EVL102, 1, l:OLD_VAR)
    1              0.000003 function! syntastic#log#deprecationWarn(old, new, ...) abort " {{{2
                                if exists('g:syntastic_' . a:old) && !exists('g:syntastic_' . a:new)
                                    let msg = 'variable g:syntastic_' . a:old . ' is deprecated, please use '
                            
                                    if a:0
                                        let OLD_VAR = g:syntastic_{a:old}
                                        try
                                            let NEW_VAR = eval(a:1)
                                            let msg .= 'in its stead: let g:syntastic_' . a:new . ' = ' . string(NEW_VAR)
                                            let g:syntastic_{a:new} = NEW_VAR
                                        catch
                                            let msg .= 'g:syntastic_' . a:new . ' instead'
                                        endtry
                                    else
                                        let msg .= 'g:syntastic_' . a:new . ' instead'
                                        let g:syntastic_{a:new} = g:syntastic_{a:old}
                                    endif
                            
                                    call syntastic#log#oneTimeWarn(msg)
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL102, 0, l:OLD_VAR)
                            
    1              0.000003 function! syntastic#log#debug(level, msg, ...) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' .
                                        \ strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ?
                                        \ filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#log#debugShowOptions(level, names) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#log#debugShowVariables(level, names) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#log#debugDump(level) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#log#ndebug(level, title, messages) abort " {{{2
                                if s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#error(a:title)
                                if type(a:messages) == type([])
                                    for msg in a:messages
                                        echomsg msg
                                    endfor
                                else
                                    echomsg a:messages
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000004 function! s:_isDebugEnabled_smart(level) abort " {{{2
                                return and(g:syntastic_debug, a:level)
                            endfunction " }}}2
                            
    1              0.000003 function! s:_isDebugEnabled_dumb(level) abort " {{{2
                                " poor man's bit test for bit N, assuming a:level == 2**N
                                return (g:syntastic_debug / a:level) % 2
                            endfunction " }}}2
                            
    1              0.000009 let s:_isDebugEnabled = function(exists('*and') ? 's:_isDebugEnabled_smart' : 's:_isDebugEnabled_dumb')
    1              0.000002 lockvar s:_isDebugEnabled
                            
    1              0.000002 function! s:_logRedirect(on) abort " {{{2
                                if exists('g:syntastic_debug_file')
                                    if a:on
                                        try
                                            execute 'redir >> ' . fnameescape(expand(g:syntastic_debug_file, 1))
                                        catch /\m^Vim\%((\a\+)\)\=:/
                                            silent! redir END
                                            unlet g:syntastic_debug_file
                                        endtry
                                    else
                                        silent! redir END
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000003 function! s:_log_timestamp_smart() abort " {{{2
                                return printf('syntastic: %f: ', reltimefloat(reltime(g:_SYNTASTIC_START)))
                            endfunction " }}}2
                            
    1              0.000003 function! s:_log_timestamp_dumb() abort " {{{2
                                return 'syntastic: ' . split(reltimestr(reltime(g:_SYNTASTIC_START)))[0] . ': '
                            endfunction " }}}2
                            
    1              0.000011 let s:_log_timestamp = function(has('float') && exists('*reltimefloat') ? 's:_log_timestamp_smart' : 's:_log_timestamp_dumb')
    1              0.000002 lockvar s:_log_timestamp
                            
    1              0.000002 function! s:_format_variable(name) abort " {{{2
                                let vals = []
                                if exists('g:syntastic_' . a:name)
                                    call add(vals, 'g:syntastic_' . a:name . ' = ' . strtrans(string(g:syntastic_{a:name})))
                                endif
                                if exists('b:syntastic_' . a:name)
                                    call add(vals, 'b:syntastic_' . a:name . ' = ' . strtrans(string(b:syntastic_{a:name})))
                                endif
                            
                                return join(vals, ', ')
                            endfunction " }}}2
                            
    1              0.000012 function! s:_is_modified(name) abort " {{{2
                                if !exists('s:option_defaults')
                                    let s:option_defaults = {}
                                endif
                                if !has_key(s:option_defaults, a:name)
                                    let opt_save = eval('&' . a:name)
                                    execute 'set ' . a:name . '&'
                                    let s:option_defaults[a:name] = eval('&' . a:name)
                                    execute 'let &' . a:name . ' = ' . string(opt_save)
                                endif
                            
                                return s:option_defaults[a:name] !=# eval('&' . a:name)
                            endfunction " }}}2
                            
                            " }}}1
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

FUNCTION  airline#extensions#load()
Called 1 time
Total time:   0.005737
 Self time:   0.002873

count  total (s)   self (s)
                              " non-trivial number of external plugins use eventignore=all, so we need to account for that
    1              0.000009   autocmd CursorMoved * call <sid>sync_active_winnr()
                            
    1              0.000004   if exists('g:airline_extensions')
                                for ext in g:airline_extensions
                                  try
                                    call airline#extensions#{ext}#init(s:ext)
                                  catch /^Vim\%((\a\+)\)\=:E117/	" E117, function does not exist
                                    call airline#util#warning("Extension '".ext."' not installed, ignoring!")
                                  endtry
                                endfor
                                return
                              endif
                            
    1   0.000324   0.000144   call airline#extensions#quickfix#init(s:ext)
                            
    1              0.000004   if get(g:, 'loaded_unite', 0)
                                call airline#extensions#unite#init(s:ext)
                              endif
                            
    1              0.000003   if exists(':NetrwSettings')
    1   0.000232   0.000119     call airline#extensions#netrw#init(s:ext)
    1              0.000001   endif
                            
    1              0.000002   if get(g:, 'airline#extensions#ycm#enabled', 0)
                                call airline#extensions#ycm#init(s:ext)
                              endif
                            
    1              0.000002   if get(g:, 'loaded_vimfiler', 0)
                                let g:vimfiler_force_overwrite_statusline = 0
                              endif
                            
    1              0.000002   if get(g:, 'loaded_ctrlp', 0)
                                call airline#extensions#ctrlp#init(s:ext)
                              endif
                            
    1              0.000002   if get(g:, 'CtrlSpaceLoaded', 0)
                                call airline#extensions#ctrlspace#init(s:ext)
                              endif
                            
    1              0.000002   if get(g:, 'command_t_loaded', 0)
                                call airline#extensions#commandt#init(s:ext)
                              endif
                            
    1              0.000003   if exists(':UndotreeToggle')
                                call airline#extensions#undotree#init(s:ext)
                              endif
                            
    1              0.000008   if get(g:, 'airline#extensions#hunks#enabled', 1) && (exists('g:loaded_signify') || exists('g:loaded_gitgutter') || exists('g:loaded_changes') || exists('g:loaded_quickfixsigns'))
                                call airline#extensions#hunks#init(s:ext)
                              endif
                            
    1              0.000004   if get(g:, 'airline#extensions#tagbar#enabled', 1) && exists(':TagbarToggle')
                                call airline#extensions#tagbar#init(s:ext)
                              endif
                            
    1              0.000005   if get(g:, 'airline#extensions#csv#enabled', 1) && (get(g:, 'loaded_csv', 0) || exists(':Table'))
                                call airline#extensions#csv#init(s:ext)
                              endif
                            
    1              0.000002   if exists(':VimShell')
                                let s:filetype_overrides['vimshell'] = ['vimshell','%{vimshell#get_status_string()}']
                                let s:filetype_regex_overrides['^int-'] = ['vimshell','%{substitute(&ft, "int-", "", "")}']
                              endif
                            
    1              0.000009   if get(g:, 'airline#extensions#branch#enabled', 1) && (exists('*fugitive#head') || exists('*lawrencium#statusline') ||     (get(g:, 'airline#extensions#branch#use_vcscommand', 0) && exists('*VCSCommandGetStatusLine')))
                                call airline#extensions#branch#init(s:ext)
                              endif
                            
    1              0.000004   if get(g:, 'airline#extensions#bufferline#enabled', 1) && exists('*bufferline#get_status_string')
                                call airline#extensions#bufferline#init(s:ext)
                              endif
                            
    1              0.000007   if (get(g:, 'airline#extensions#virtualenv#enabled', 1) && (exists(':VirtualEnvList') || isdirectory($VIRTUAL_ENV)))
                                call airline#extensions#virtualenv#init(s:ext)
                              endif
                            
    1              0.000004   if (get(g:, 'airline#extensions#eclim#enabled', 1) && exists(':ProjectCreate'))
                                call airline#extensions#eclim#init(s:ext)
                              endif
                            
    1              0.000004   if get(g:, 'airline#extensions#syntastic#enabled', 1) && exists(':SyntasticCheck')
    1   0.000220   0.000124     call airline#extensions#syntastic#init(s:ext)
    1              0.000001   endif
                            
    1              0.000002   if get(g:, 'airline#extensions#whitespace#enabled', 1)
    1   0.000469   0.000124     call airline#extensions#whitespace#init(s:ext)
    1              0.000001   endif
                            
    1              0.000032   if get(g:, 'airline#extensions#po#enabled', 1) && executable('msgfmt')
    1   0.000222   0.000113     call airline#extensions#po#init(s:ext)
    1              0.000001   endif
                            
    1              0.000003   if get(g:, 'airline#extensions#wordcount#enabled', 1)
    1   0.000262   0.000114     call airline#extensions#wordcount#init(s:ext)
    1              0.000001   endif
                            
    1              0.000003   if get(g:, 'airline#extensions#tabline#enabled', 0)
    1   0.001989   0.000116     call airline#extensions#tabline#init(s:ext)
    1              0.000001   endif
                            
    1              0.000006   if get(g:, 'airline#extensions#tmuxline#enabled', 1) && exists(':Tmuxline')
                                call airline#extensions#tmuxline#init(s:ext)
                              endif
                            
    1              0.000006   if get(g:, 'airline#extensions#promptline#enabled', 1) && exists(':PromptlineSnapshot') && len(get(g:, 'airline#extensions#promptline#snapshot_file', ''))
                                call airline#extensions#promptline#init(s:ext)
                              endif
                            
    1              0.000004   if get(g:, 'airline#extensions#nrrwrgn#enabled', 1) && exists(':NR') == 2
                                  call airline#extensions#nrrwrgn#init(s:ext)
                              endif
                            
    1              0.000004   if get(g:, 'airline#extensions#unicode#enabled', 1) && exists(':UnicodeTable') == 2
                                  call airline#extensions#unicode#init(s:ext)
                              endif
                            
    1              0.000004   if (get(g:, 'airline#extensions#capslock#enabled', 1) && exists('*CapsLockStatusline'))
                                call airline#extensions#capslock#init(s:ext)
                              endif
                            
    1              0.000003   if (get(g:, 'airline#extensions#windowswap#enabled', 1) && get(g:, 'loaded_windowswap', 0))
                                call airline#extensions#windowswap#init(s:ext)
                              endif
                            
    1              0.000004   if (get(g:, 'airline#extensions#obsession#enabled', 1) && exists('*ObsessionStatus'))
                                call airline#extensions#obsession#init(s:ext)
                              endif
                            
    1              0.000002   if !get(g:, 'airline#extensions#disable_rtp_load', 0)
                                " load all other extensions, which are not part of the default distribution.
                                " (autoload/airline/extensions/*.vim outside of our s:script_path).
   30              0.000772     for file in split(globpath(&rtp, "autoload/airline/extensions/*.vim"), "\n")
                                  " we have to check both resolved and unresolved paths, since it's possible
                                  " that they might not get resolved properly (see #187)
   29              0.000677       if stridx(tolower(resolve(fnamemodify(file, ':p'))), s:script_path) < 0 && stridx(tolower(fnamemodify(file, ':p')), s:script_path) < 0
                                    let name = fnamemodify(file, ':t:r')
                                    if !get(g:, 'airline#extensions#'.name.'#enabled', 1)
                                      continue
                                    endif
                                    try
                                      call airline#extensions#{name}#init(s:ext)
                                    catch
                                    endtry
                                  endif
   29              0.000018     endfor
    1              0.000000   endif

FUNCTION  airline#extensions#load_theme()
Called 1 time
Total time:   0.004050
 Self time:   0.000171

count  total (s)   self (s)
    1   0.004048   0.000169   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  1()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003     let newObj = copy(self)
    1              0.000002     return newObj

FUNCTION  2()
Called 1 time
Total time:   0.000071
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000014   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    1   0.000056   0.000006     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  3()
Called 1 time
Total time:   0.000050
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000013   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    1   0.000017   0.000004     let auto_loc_list = syntastic#util#var('auto_loc_list')
    1   0.000006   0.000004     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
    1              0.000001         if auto_loc_list == 1 || auto_loc_list == 2
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
    1              0.000005             lclose
    1              0.000000         endif
    1              0.000000     endif

FUNCTION  4()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     let newObj = copy(self)
    1              0.000001     return newObj

FUNCTION  5()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  airline#extensions#tabline#init()
Called 1 time
Total time:   0.001616
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000006   if has('gui_running')
                                set guioptions-=e
                              endif
                            
    1              0.000008   autocmd User AirlineToggledOn call s:toggle_on()
    1              0.000005   autocmd User AirlineToggledOff call s:toggle_off()
                            
    1   0.001579   0.000008   call s:toggle_on()
    1   0.000014   0.000008   call a:ext.add_theme_func('airline#extensions#tabline#load_theme')

FUNCTION  99()
Called 1 time
Total time:   0.000018
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000018   0.000012   call airline#add_inactive_statusline_func(a:name)

FUNCTION  31()
Called 1 time
Total time:   0.000057
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000004     let newObj = copy(self)
                            
    1              0.000001     if !s:setup_done
    1   0.000045   0.000005         call self._setup()
    1              0.000002         let s:setup_done = 1
    1              0.000002         lockvar s:setup_done
    1              0.000001     endif
                            
    1              0.000001     return newObj

FUNCTION  32()
Called 2 times
Total time:   0.000037
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000036   0.000009     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  33()
Called 1 time
Total time:   0.000096
 Self time:   0.000056

count  total (s)   self (s)
    1   0.000021   0.000003     if self.enabled()
    1   0.000014   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    1   0.000015   0.000005         call self._reset()
    1              0.000003         let buf = bufnr('')
    1   0.000010   0.000007         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    1              0.000002         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    1              0.000000     endif

FUNCTION  35()
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000002     if s:has_highlighting
    1              0.000006         if !hlexists('SyntasticError')
    1              0.000007             highlight link SyntasticError SpellBad
    1              0.000000         endif
    1              0.000003         if !hlexists('SyntasticWarning')
    1              0.000003             highlight link SyntasticWarning SpellCap
    1              0.000001         endif
    1              0.000002         if !hlexists('SyntasticStyleError')
    1              0.000002             highlight link SyntasticStyleError SyntasticError
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleWarning')
    1              0.000003             highlight link SyntasticStyleWarning SyntasticWarning
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  36()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  37()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000015     let newObj = copy(self)
                            
    1              0.000005     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
    1              0.000002     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    1              0.000002     let newObj._rawLoclist = llist
    1              0.000002     let newObj._name = ''
    1              0.000003     let newObj._owner = bufnr('')
    1              0.000002     let newObj._sorted = 0
    1              0.000003     let newObj._columns = g:syntastic_cursor_columns
                            
    1              0.000002     return newObj

FUNCTION  38()
Called 1 time
Total time:   0.000059
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
    1   0.000052   0.000008         let b:syntastic_loclist = g:SyntasticLoclist.New([])
    1              0.000001     endif
    1              0.000001     return b:syntastic_loclist

FUNCTION  airline#util#exec_funcrefs()
Called 3 times
Total time:   0.006714
 Self time:   0.000382

count  total (s)   self (s)
   14              0.000026     for Fn in a:list
   13   0.006622   0.000290       let code = call(Fn, a:000)
   13              0.000019       if code != 0
    2              0.000002         return code
                                  endif
   11              0.000008     endfor
    1              0.000001     return 0

FUNCTION  <SNR>59_build_sections()
Called 4 times
Total time:   0.001809
 Self time:   0.000280

count  total (s)   self (s)
   20              0.000033   for key in a:keys
   16              0.000058     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
   16   0.001631   0.000102     call s:add_section(a:builder, a:context, key)
   16              0.000015   endfor

FUNCTION  airline#section#create_right()
Called 2 times
Total time:   0.000328
 Self time:   0.000012

count  total (s)   self (s)
    2   0.000327   0.000011   return s:create(a:parts, -1)

FUNCTION  airline#parts#define_raw()
Called 12 times
Total time:   0.000243
 Self time:   0.000068

count  total (s)   self (s)
   12   0.000239   0.000064   call airline#parts#define(a:key, { 'raw': a:raw })

FUNCTION  airline#extensions#quickfix#apply()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000007   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  pathogen#split()
Called 7 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
    7              0.000032   if type(a:path) == type([]) | return a:path | endif
    7              0.000016   if empty(a:path) | return [] | endif
    1              0.000048   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
    1              0.000034   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')

FUNCTION  41()
Called 5 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    5              0.000011     return empty(self._rawLoclist)

FUNCTION  42()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003     if !exists('self._stamp')
    1              0.000003         let self._stamp = []
    1              0.000001         return 0
                                endif
                                return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  43()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003     return copy(self._rawLoclist)

FUNCTION  <SNR>59_add_section()
Called 16 times
Total time:   0.001529
 Self time:   0.000560

count  total (s)   self (s)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   16   0.000287   0.000104     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   16              0.000042     if (a:key == 'warning' || a:key == 'error')
    4   0.000037   0.000018       call a:builder.add_raw('%(')
    4              0.000005     endif
   16   0.000932   0.000182     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   16              0.000052     if (a:key == 'warning' || a:key == 'error')
    4   0.000033   0.000016       call a:builder.add_raw('%)')
    4              0.000004     endif

FUNCTION  airline#parts#define()
Called 25 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
   25              0.000107   let s:parts[a:key] = get(s:parts, a:key, {})
   25              0.000070   if exists('g:airline#init#bootstrapping')
   23              0.000082     call extend(s:parts[a:key], a:config, 'keep')
   23              0.000019   else
    2              0.000008     call extend(s:parts[a:key], a:config, 'force')
    2              0.000002   endif

FUNCTION  pathogen#is_disabled()
Called 6 times
Total time:   0.000212
 Self time:   0.000148

count  total (s)   self (s)
    6              0.000021   if a:path =~# '\~$'
                                return 1
                              endif
    6   0.000039   0.000019   let sep = pathogen#slash()
    6   0.000103   0.000059   let blacklist = map( get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST), 'substitute(v:val, "[\\/]$", "", "")')
    6              0.000033   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1

FUNCTION  airline#parts#define_empty()
Called 1 time
Total time:   0.000272
 Self time:   0.000068

count  total (s)   self (s)
   11              0.000013   for key in a:keys
   10   0.000243   0.000039     call airline#parts#define_raw(key, '')
   10              0.000008   endfor

FUNCTION  airline#highlighter#get_highlight()
Called 171 times
Total time:   0.016018
 Self time:   0.005071

count  total (s)   self (s)
  171   0.005755   0.000928   let fg = s:get_syn(a:group, 'fg')
  171   0.005262   0.000916   let bg = s:get_syn(a:group, 'bg')
  171              0.001927   let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  171   0.002925   0.001151   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  airline#parts#get()
Called 27 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
   27              0.000075   return get(s:parts, a:key, {})

FUNCTION  airline#init#sections()
Called 1 time
Total time:   0.002862
 Self time:   0.000220

count  total (s)   self (s)
    1              0.000003   let spc = g:airline_symbols.space
    1              0.000003   if !exists('g:airline_section_a')
    1   0.001140   0.000114     let g:airline_section_a = airline#section#create_left(['mode', 'crypt', 'paste', 'spell', 'capslock', 'iminsert'])
    1              0.000001   endif
    1              0.000003   if !exists('g:airline_section_b')
    1   0.000166   0.000009     let g:airline_section_b = airline#section#create(['hunks', 'branch'])
    1              0.000000   endif
    1              0.000002   if !exists('g:airline_section_c')
    1              0.000003     if exists("+autochdir") && &autochdir == 1
                                  let g:airline_section_c = airline#section#create(['%<', 'path', spc, 'readonly'])
                                else
    1   0.000287   0.000007       let g:airline_section_c = airline#section#create(['%<', 'file', spc, 'readonly'])
    1              0.000001     endif
    1              0.000001   endif
    1              0.000002   if !exists('g:airline_section_gutter')
    1   0.000117   0.000006     let g:airline_section_gutter = airline#section#create(['%='])
    1              0.000001   endif
    1              0.000002   if !exists('g:airline_section_x')
    1   0.000197   0.000014     let g:airline_section_x = airline#section#create_right(['tagbar', 'filetype'])
    1              0.000001   endif
    1              0.000002   if !exists('g:airline_section_y')
    1   0.000150   0.000005     let g:airline_section_y = airline#section#create_right(['ffenc'])
    1              0.000001   endif
    1              0.000003   if !exists('g:airline_section_z')
    1   0.000343   0.000009     let g:airline_section_z = airline#section#create(['windowswap', 'obsession', '%3p%%'.spc, 'linenr', 'maxlinenr', spc.':%3v'])
    1              0.000000   endif
    1              0.000003   if !exists('g:airline_section_error')
    1   0.000233   0.000006     let g:airline_section_error = airline#section#create(['ycm_error_count', 'syntastic', 'eclim'])
    1              0.000001   endif
    1              0.000002   if !exists('g:airline_section_warning')
    1   0.000184   0.000005     let g:airline_section_warning = airline#section#create(['ycm_warning_count', 'whitespace'])
    1              0.000001   endif

FUNCTION  airline#load_theme()
Called 1 time
Total time:   0.027111
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000006   if exists('*airline#themes#{g:airline_theme}#refresh')
    1   0.001571   0.000006     call airline#themes#{g:airline_theme}#refresh()
    1              0.000001   endif
                            
    1              0.000004   let palette = g:airline#themes#{g:airline_theme}#palette
    1   0.000217   0.000012   call airline#themes#patch(palette)
                            
    1              0.000002   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    1   0.011673   0.000012   call airline#highlighter#load_theme()
    1   0.004065   0.000015   call airline#extensions#load_theme()
    1   0.009565   0.000022   call airline#update_statusline()

FUNCTION  airline#add_inactive_statusline_func()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   call add(s:inactive_funcrefs, function(a:name))

FUNCTION  syntastic#util#rawVar()
Called 9 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    9              0.000047     return get(b:, a:name, get(g:, a:name, a:0 > 0 ? a:1 : ''))

FUNCTION  <SNR>58_get_prev_group()
Called 26 times
Total time:   0.000437
 Self time:   0.000437

count  total (s)   self (s)
   26              0.000062   let x = a:i - 1
   36              0.000051   while x >= 0
   34              0.000096     let group = a:sections[x][0]
   34              0.000083     if group != '' && group != '|'
   24              0.000032       return group
                                endif
   10              0.000017     let x = x - 1
   10              0.000007   endwhile
    2              0.000001   return ''

FUNCTION  airline#extensions#wordcount#apply()
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000031   if &ft =~ s:filetypes
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  <SNR>34_LocalBrowse()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    1              0.000003   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000001    return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  airline#update_statusline()
Called 2 times
Total time:   0.016480
 Self time:   0.000232

count  total (s)   self (s)
    2   0.000031   0.000022   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    2              0.000015   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            
    2              0.000004   unlet! w:airline_render_left
    2              0.000003   unlet! w:airline_render_right
   20              0.000022   for section in s:sections
   18              0.000040     unlet! w:airline_section_{section}
   18              0.000020   endfor
                            
    2              0.000004   let w:airline_active = 1
    2              0.000012   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    2   0.016284   0.000045   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>58_get_accented_line()
Called 16 times
Total time:   0.001056
 Self time:   0.001056

count  total (s)   self (s)
   16              0.000030   if a:self._context.active
   16              0.000030     let contents = []
   16              0.000153     let content_parts = split(a:contents, '__accent')
   40              0.000071     for cpart in content_parts
   24              0.000217       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   24              0.000076       call add(contents, cpart)
   24              0.000027     endfor
   16              0.000071     let line = join(contents, a:group)
   16              0.000138     let line = substitute(line, '__restore__', a:group, 'g')
   16              0.000017   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   16              0.000021   return line

FUNCTION  airline#extensions#tabline#autoshow#on()
Called 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000007   let [ s:original_tabline, s:original_showtabline ] = [ &tabline, &showtabline ]
                            
    1              0.000002   augroup airline_tabline_autoshow
    1              0.000032     autocmd!
    1              0.000003     if s:buf_min_count <= 0 && s:tab_min_count <= 1
    1              0.000001       if &lines > 3
    1              0.000017         set showtabline=2
    1              0.000001       endif
    1              0.000001     else
                                  if s:show_buffers == 1
                                    autocmd BufEnter  * call <sid>show_tabline(s:buf_min_count, len(airline#extensions#tabline#buflist#list()))
                                    autocmd BufUnload * call <sid>show_tabline(s:buf_min_count, len(airline#extensions#tabline#buflist#list()) - 1)
                                  else
                                    autocmd TabEnter  * call <sid>show_tabline(s:tab_min_count, tabpagenr('$'))
                                  endif
                                endif
                            
                                " Invalidate cache.  This has to come after the BufUnload for
                                " s:show_buffers, to invalidate the cache for BufEnter.
    1              0.000009     autocmd BufLeave,BufAdd,BufUnload * call airline#extensions#tabline#buflist#invalidate()
    1              0.000001   augroup END

FUNCTION  <SNR>54_get_array()
Called 189 times
Total time:   0.001940
 Self time:   0.001940

count  total (s)   self (s)
  189              0.000333   let fg = a:fg
  189              0.000311   let bg = a:bg
  189              0.001153   return g:airline_gui_mode ==# 'gui' ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  airline#add_statusline_funcref()
Called 4 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    4              0.000019   if index(g:airline_statusline_funcrefs, a:function) >= 0
                                echohl WarningMsg
                                echo 'The airline statusline funcref '.string(a:function).' has already been added.'
                                echohl NONE
                                return
                              endif
    4              0.000013   call add(g:airline_statusline_funcrefs, a:function)

FUNCTION  <SNR>54_get_syn()
Called 378 times
Total time:   0.010051
 Self time:   0.010051

count  total (s)   self (s)
  378              0.001166   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
  378              0.002348   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  378              0.001126   if empty(color) || color == -1
  146              0.000887     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
  146              0.000129   endif
  378              0.000819   if empty(color) || color == -1
                                let color = 'NONE'
                              endif
  378              0.000400   return color

FUNCTION  <SNR>59_get_section()
Called 22 times
Total time:   0.000938
 Self time:   0.000841

count  total (s)   self (s)
   22              0.000077   if has_key(s:section_truncate_width, a:key)
   16              0.000059     if winwidth(a:winnr) < s:section_truncate_width[a:key]
    2              0.000003       return ''
                                endif
   14              0.000008   endif
   20              0.000045   let spc = g:airline_symbols.space
   20              0.000100   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   20   0.000265   0.000168   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   20              0.000163   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   20              0.000087   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>24_airline_toggle()
Called 1 time
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    1              0.000004   if exists("#airline")
                                augroup airline
                                  au!
                                augroup END
                                augroup! airline
                            
                                if exists("s:stl")
                                  let &stl = s:stl
                                endif
                            
                                silent doautocmd User AirlineToggledOff
                              else
    1              0.000003     let s:stl = &statusline
    1              0.000001     augroup airline
    1              0.000033       autocmd!
                            
    1              0.000007       autocmd CmdwinEnter * call airline#add_statusline_func('airline#cmdwinenter') | call <sid>on_window_changed()
    1              0.000004       autocmd CmdwinLeave * call airline#remove_statusline_func('airline#cmdwinenter')
                            
    1              0.000006       autocmd GUIEnter,ColorScheme * call <sid>on_colorscheme_changed()
    1              0.000020       autocmd SessionLoadPost,VimEnter,WinEnter,BufWinEnter,FileType,BufUnload * call <sid>on_window_changed()
                            
    1              0.000004       autocmd VimResized * unlet! w:airline_lastmode | :call <sid>airline_refresh()
    1              0.000004       autocmd TabEnter * :unlet! w:airline_lastmode w:airline_active
    1              0.000035       autocmd BufWritePost */autoload/airline/themes/*.vim exec 'source '.split(globpath(&rtp, 'autoload/airline/themes/'.g:airline_theme.'.vim', 1), "\n")[0] | call airline#load_theme()
    1              0.000002     augroup END
                            
    1              0.000002     if s:airline_initialized
                                  call s:on_window_changed()
                                endif
                            
    1              0.000010     silent doautocmd User AirlineToggledOn
    1              0.000001   endif

FUNCTION  64()
Called 1 time
Total time:   0.000036
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000003     if !exists('s:SyntasticModeMapInstance')
    1              0.000006         let s:SyntasticModeMapInstance = copy(self)
    1   0.000024   0.000005         call s:SyntasticModeMapInstance.synch()
    1              0.000001     endif
                            
    1              0.000002     return s:SyntasticModeMapInstance

FUNCTION  65()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    1              0.000002         let self._mode = 'active'
    1              0.000002         let self._activeFiletypes = []
    1              0.000002         let self._passiveFiletypes = []
    1              0.000001     endif

FUNCTION  <SNR>26_check_defined()
Called 17 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
   17              0.000047   if !exists(a:variable)
   16              0.000050     let {a:variable} = a:default
   16              0.000010   endif

FUNCTION  airline#section#create()
Called 6 times
Total time:   0.001288
 Self time:   0.000030

count  total (s)   self (s)
    6   0.001286   0.000028   return s:create(a:parts, 0)

FUNCTION  airline#extensions#tabline#load_theme()
Called 1 time
Total time:   0.003696
 Self time:   0.000203

count  total (s)   self (s)
    1              0.000002   if pumvisible()
                                return
                              endif
    1              0.000004   let colors    = get(a:palette, 'tabline', {})
                              " Theme for tabs on the left
    1              0.000003   let l:tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    1              0.000004   let l:tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    1              0.000003   let l:tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    1              0.000004   let l:tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    1              0.000003   let l:tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    1              0.000003   let l:tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    1              0.000004   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
    1              0.000003     let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
    1              0.000000   endif
    1   0.000233   0.000016   call airline#highlighter#exec('airline_tab', l:tab)
    1   0.000649   0.000010   call airline#highlighter#exec('airline_tabsel', l:tabsel)
    1   0.000323   0.000011   call airline#highlighter#exec('airline_tabtype', l:tabtype)
    1   0.000289   0.000011   call airline#highlighter#exec('airline_tabfill', l:tabfill)
    1   0.000294   0.000010   call airline#highlighter#exec('airline_tabmod', l:tabmod)
    1   0.000296   0.000010   call airline#highlighter#exec('airline_tabmod_unsel', l:tabmodu)
    1   0.000283   0.000009   call airline#highlighter#exec('airline_tabhid', l:tabhid)
                            
                              " Theme for tabs on the right
    1              0.000007   let l:tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    1              0.000006   let l:tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    1              0.000005   let l:tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    1              0.000005   let l:tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    1              0.000006   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
    1              0.000005     let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
    1              0.000001   endif
    1   0.000280   0.000009   call airline#highlighter#exec('airline_tab_right',    l:tab_right)
    1   0.000290   0.000009   call airline#highlighter#exec('airline_tabsel_right', l:tabsel_right)
    1   0.000254   0.000008   call airline#highlighter#exec('airline_tabmod_right', l:tabmod_right)
    1   0.000212   0.000006   call airline#highlighter#exec('airline_tabhid_right', l:tabhid_right)
    1   0.000206   0.000007   call airline#highlighter#exec('airline_tabmod_unsel_right', l:tabmodu_right)

FUNCTION  airline#themes#get_highlight()
Called 44 times
Total time:   0.004319
 Self time:   0.000401

count  total (s)   self (s)
   44   0.004303   0.000385   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#extensions#quickfix#init()
Called 1 time
Total time:   0.000083
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000058   0.000009   call a:ext.add_statusline_func('airline#extensions#quickfix#apply')
    1   0.000025   0.000007   call a:ext.add_inactive_statusline_func('airline#extensions#quickfix#inactive_qf_window')

FUNCTION  airline#parts#define_text()
Called 1 time
Total time:   0.000020
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000020   0.000005   call airline#parts#define(a:key, { 'text': a:text })

FUNCTION  airline#section#create_left()
Called 1 time
Total time:   0.000904
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000903   0.000012   return s:create(a:parts, 1)

FUNCTION  airline#util#getwinvar()
Called 26 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   26              0.000110     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#default#apply()
Called 2 times
Total time:   0.002066
 Self time:   0.000140

count  total (s)   self (s)
    2              0.000007   let winnr = a:context.winnr
    2              0.000005   let active = a:context.active
                            
    2   0.000023   0.000013   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    2   0.000677   0.000026     call s:build_sections(a:builder, a:context, s:layout[0])
    2              0.000002   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    2   0.000127   0.000028   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    2   0.000018   0.000010   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    2   0.001173   0.000015     call s:build_sections(a:builder, a:context, s:layout[1])
    2              0.000002   endif
                            
    2              0.000002   return 1

FUNCTION  airline#highlighter#exec()
Called 103 times
Total time:   0.021699
 Self time:   0.006475

count  total (s)   self (s)
  103              0.000179   if pumvisible()
                                return
                              endif
  103              0.000171   let colors = a:colors
  103              0.000122   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  103   0.008149   0.002922   let cmd= printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg=', ''), s:Get(colors, 1, 'guibg=', ''), s:Get(colors, 2, 'ctermfg=', ''), s:Get(colors, 3, 'ctermbg=', ''), s:Get(colors, 4, 'gui=', ''), s:Get(colors, 4, 'cterm=', ''), s:Get(colors, 4, 'term=', ''))
  103   0.010561   0.000564   let old_hi = airline#highlighter#get_highlight(a:group)
  103              0.000219   if len(colors) == 4
   22              0.000059     call add(colors, '')
   22              0.000014   endif
  103              0.000156   if old_hi != colors
   76              0.000605     exe cmd
   76              0.000053   endif

FUNCTION  airline#add_statusline_func()
Called 4 times
Total time:   0.000097
 Self time:   0.000039

count  total (s)   self (s)
    4   0.000097   0.000039   call airline#add_statusline_funcref(function(a:name))

FUNCTION  74()
Called 1 time
Total time:   0.000224
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000004     if !exists('s:SyntasticNotifiersInstance')
    1              0.000004         let s:SyntasticNotifiersInstance = copy(self)
    1   0.000213   0.000008         call s:SyntasticNotifiersInstance._initNotifiers()
    1              0.000001     endif
                            
    1              0.000002     return s:SyntasticNotifiersInstance

FUNCTION  75()
Called 1 time
Total time:   0.000840
 Self time:   0.000304

count  total (s)   self (s)
    1   0.000009   0.000006     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    1   0.000023   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
    6              0.000008     for type in self._enabled_types
    5              0.000049         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000117   0.000051         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    4              0.000012             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    1              0.000004                 if !exists('b:syntastic_private_' . type . '_stamp')
    1              0.000004                     let b:syntastic_private_{type}_stamp = []
    1              0.000001                 endif
    1   0.000023   0.000014                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    1   0.000224   0.000006                     call self._notifier[type].refresh(a:loclist)
    1   0.000034   0.000016                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    1              0.000001                 endif
    1              0.000001             else
    3   0.000230   0.000026                 call self._notifier[type].refresh(a:loclist)
    3              0.000002             endif
    4              0.000001         endif
    5              0.000005     endfor

FUNCTION  77()
Called 1 time
Total time:   0.000205
 Self time:   0.000124

count  total (s)   self (s)
    1              0.000006     let self._notifier = {}
    6              0.000008     for type in s:_NOTIFIER_TYPES
    5              0.000049         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000125   0.000044         let self._notifier[type] = g:{class}.New()
    5              0.000005     endfor
                            
    1              0.000004     let self._enabled_types = copy(s:_NOTIFIER_TYPES)

FUNCTION  pathogen#cycle_filetype()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003   if exists('g:did_load_filetypes')
                                filetype off
                                filetype on
                              endif

FUNCTION  <SNR>53_create()
Called 9 times
Total time:   0.002465
 Self time:   0.001777

count  total (s)   self (s)
    9              0.000017   let _ = ''
   36              0.000059   for idx in range(len(a:parts))
   27   0.000216   0.000132     let part = airline#parts#get(a:parts[idx])
   27              0.000037     let val = ''
                            
   27              0.000068     if exists('part.function')
   10              0.000021       let func = (part.function).'()'
   10              0.000014     elseif exists('part.text')
    1              0.000003       let func = '"'.(part.text).'"'
    1              0.000001     else
   16              0.000021       if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
   16              0.000020       if a:append < 0 && idx != 0
                                    let val = s:spc.g:airline_right_alt_sep.s:spc.val
                                  endif
   16              0.000031       if exists('part.raw')
   11   0.000161   0.000059         let _ .= s:wrap_accent(part, val.(part.raw))
   11              0.000016         continue
                                  else
    5   0.000068   0.000027         let _ .= s:wrap_accent(part, val.a:parts[idx])
    5              0.000007         continue
                                  endif
                                endif
                            
   11              0.000028     let minwidth = get(part, 'minwidth', 0)
                            
   11              0.000016     if a:append > 0 && idx != 0
    5              0.000024       let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
    5              0.000010     elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                else
    6              0.000027       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    6              0.000005     endif
                            
   11              0.000022     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
   11   0.000523   0.000062     let val .= s:wrap_accent(part, partval)
   11              0.000026     let _ .= val
   11              0.000008   endfor
    9              0.000012   return _

FUNCTION  airline#highlighter#get_highlight2()
Called 18 times
Total time:   0.001343
 Self time:   0.000299

count  total (s)   self (s)
   18   0.000570   0.000107   let fg = s:get_syn(a:fg[0], a:fg[1])
   18   0.000506   0.000091   let bg = s:get_syn(a:bg[0], a:bg[1])
   18   0.000253   0.000087   return s:get_array(fg, bg, a:000)

FUNCTION  airline#extensions#tabline#tabs#on()
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000002   augroup airline_tabline_tabs
    1              0.000032     autocmd!
    1              0.000006     autocmd BufDelete * call airline#extensions#tabline#tabs#invalidate()
    1              0.000001   augroup END

FUNCTION  pathogen#expand()
Called 5 times
Total time:   0.000785
 Self time:   0.000768

count  total (s)   self (s)
    5              0.000010   let after = a:0 ? a:1 : ''
    5              0.000027   if a:pattern =~# '{[^{}]\+}'
                                let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
                                let found = map(split(pat, ',', 1), 'pre.v:val.post')
                                let results = []
                                for pattern in found
                                  call extend(results, pathogen#expand(pattern))
                                endfor
                              elseif a:pattern =~# '{}'
    5              0.000055     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
    5              0.000023     let post = a:pattern[strlen(pat) : -1]
    5              0.000354     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
    5              0.000006   else
                                let results = [a:pattern]
                              endif
    5   0.000042   0.000025   let vf = pathogen#slash() . 'vimfiles'
    5              0.000142   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
    5              0.000029   return filter(results, '!empty(v:val)')

FUNCTION  pathogen#interpose()
Called 1 time
Total time:   0.001709
 Self time:   0.000215

count  total (s)   self (s)
    1   0.000012   0.000007   let sep = pathogen#slash()
    1              0.000002   let name = a:name
    1              0.000008   if has_key(s:done_bundles, name)
                                return ""
                              endif
    1              0.000003   let s:done_bundles[name] = 1
    1              0.000002   let list = []
    6   0.000109   0.000016   for dir in pathogen#split(&rtp)
    5              0.000025     if dir =~# '\<after$'
    2   0.000339   0.000027       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
    2              0.000001     else
    3   0.000703   0.000056       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
    3              0.000002     endif
    5              0.000003   endfor
    1   0.000453   0.000016   let &rtp = pathogen#join(pathogen#uniq(list))
    1              0.000001   return 1

FUNCTION  syntastic#util#system()
Called 1 time
Total time:   0.025406
 Self time:   0.000548

count  total (s)   self (s)
    1              0.000002     let old_shell = &shell
    1              0.000004     let old_lc_messages = $LC_MESSAGES
    1              0.000002     let old_lc_all = $LC_ALL
                            
    1   0.000035   0.000012     let &shell = syntastic#util#var('shell')
    1              0.000006     let $LC_MESSAGES = 'C'
    1              0.000003     let $LC_ALL = ''
                            
    1              0.000003     let cmd_start = reltime()
    1   0.025256   0.000421     let out = system(a:command)
    1              0.000054     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
    1              0.000007     let $LC_ALL = old_lc_all
    1              0.000003     let $LC_MESSAGES = old_lc_messages
                            
    1              0.000008     let &shell = old_shell
                            
    1              0.000006     if exists('g:_SYNTASTIC_DEBUG_TRACE')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
                                endif
                            
    1              0.000004     return out

FUNCTION  airline#extensions#po#init()
Called 1 time
Total time:   0.000032
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000032   0.000006     call a:ext.add_statusline_func('airline#extensions#po#apply')

FUNCTION  105()
Called 2 times
Total time:   0.012681
 Self time:   0.002007

count  total (s)   self (s)
    2              0.000004   let side = 1
    2              0.000003   let line = ''
    2              0.000003   let i = 0
    2              0.000007   let length = len(self._sections)
    2              0.000003   let split = 0
    2              0.000003   let is_empty = 0
    2              0.000004   let prev_group = ''
                            
   28              0.000038   while i < length
   26              0.000072     let section = self._sections[i]
   26              0.000067     let group = section[0]
   26              0.000060     let contents = section[1]
   26              0.000047     let pgroup = prev_group
   26   0.000598   0.000161     let prev_group = s:get_prev_group(self._sections, i)
   26              0.000032     if is_empty
                                  let prev_group = pgroup
                                endif
   26   0.000459   0.000141     let is_empty = s:section_is_empty(self, contents)
                            
   26              0.000027     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the 
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   26              0.000041     if group == ''
    8              0.000021       let line .= contents
    8              0.000009     elseif group == '|'
    2              0.000003       let side = 0
    2              0.000005       let line .= contents
    2              0.000002       let split = 1
    2              0.000002     else
   16              0.000024       if prev_group == ''
    2              0.000008         let line .= '%#'.group.'#'
    2              0.000002       elseif split
    2              0.000002         if !is_empty
    2   0.001255   0.000017           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    2              0.000003         endif
    2              0.000003         let split = 0
    2              0.000002       else
   12              0.000013         if !is_empty
   12   0.007724   0.000099           let line .= s:get_seperator(self, prev_group, group, side)
   12              0.000014         endif
   12              0.000008       endif
   16   0.001222   0.000166       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   16              0.000017     endif
                            
   26              0.000061     let i = i + 1
   26              0.000030   endwhile
                            
    2              0.000002   if !self._context.active
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    2              0.000003   return line

FUNCTION  syntastic#log#debug()
Called 7 times
Total time:   0.000081
 Self time:   0.000056

count  total (s)   self (s)
    7   0.000061   0.000036     if !s:_isDebugEnabled(a:level)
    7              0.000016         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>60__isDebugEnabled_smart()
Called 7 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    7              0.000017     return and(g:syntastic_debug, a:level)

FUNCTION  <SNR>24_init()
Called 1 time
Total time:   0.047337
 Self time:   0.000379

count  total (s)   self (s)
    1              0.000003   if s:airline_initialized
                                return
                              endif
    1              0.000002   let s:airline_initialized = 1
                            
    1   0.006249   0.000142   call airline#extensions#load()
    1   0.002875   0.000013   call airline#init#sections()
                            
    1              0.000004   let s:theme_in_vimrc = exists('g:airline_theme')
    1              0.000001   if s:theme_in_vimrc
    1              0.000001     try
    1   0.002264   0.000122       let palette = g:airline#themes#{g:airline_theme}#palette
    1              0.000002     catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
    1   0.035849   0.000015     silent call airline#switch_theme(g:airline_theme)
    1              0.000001   else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
    1   0.000072   0.000059   silent doautocmd User AirlineAfterInit

FUNCTION  airline#check_mode()
Called 1 time
Total time:   0.008675
 Self time:   0.000115

count  total (s)   self (s)
    1              0.000003   let context = s:contexts[a:winnr]
                            
    1              0.000003   if get(w:, 'airline_active', 1)
    1              0.000003     let l:m = mode()
    1              0.000002     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
    1              0.000002       let l:mode = ['normal']
    1              0.000001     endif
    1              0.000005     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    1              0.000000   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
    1              0.000005   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
    1              0.000002   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
    1              0.000004   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
    1              0.000002   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
    1              0.000002   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
    1              0.000003   let mode_string = join(l:mode)
    1              0.000004   if get(w:, 'airline_lastmode', '') != mode_string
    1   0.000260   0.000019     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    1   0.008328   0.000009     call airline#highlighter#highlight(l:mode)
    1              0.000003     let w:airline_lastmode = mode_string
    1              0.000001   endif
                            
    1              0.000001   return ''

FUNCTION  airline#themes#base16#refresh()
Called 2 times
Total time:   0.003456
 Self time:   0.000570

count  total (s)   self (s)
    2              0.000007     let g:airline#themes#base16#palette = {}
                            
    2   0.000444   0.000113     let g:airline#themes#base16#palette.accents = { 'red': airline#themes#get_highlight('Constant'), }
                            
    2   0.000223   0.000023     let s:N1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['DiffText', 'fg'], 'bold')
    2   0.000181   0.000013     let s:N2 = airline#themes#get_highlight2(['Visual', 'fg'], ['Visual', 'bg'])
    2   0.000193   0.000008     let s:N3 = airline#themes#get_highlight('CursorLine')
    2   0.000113   0.000020     let g:airline#themes#base16#palette.normal = airline#themes#generate_color_map(s:N1, s:N2, s:N3)
                            
    2   0.000193   0.000009     let group = airline#themes#get_highlight('vimCommand')
    2              0.000012     let g:airline#themes#base16#palette.normal_modified = { 'statusline': [ group[0], '', group[2], '', '' ] }
                            
    2   0.000187   0.000019     let s:I1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['DiffAdded', 'fg'], 'bold')
    2   0.000164   0.000015     let s:I2 = airline#themes#get_highlight2(['DiffAdded', 'fg'], ['Normal', 'bg'])
    2              0.000003     let s:I3 = s:N3
    2   0.000094   0.000010     let g:airline#themes#base16#palette.insert = airline#themes#generate_color_map(s:I1, s:I2, s:I3)
    2              0.000006     let g:airline#themes#base16#palette.insert_modified = g:airline#themes#base16#palette.normal_modified
                            
    2   0.000170   0.000014     let s:R1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['WarningMsg', 'fg'], 'bold')
    2              0.000005     let s:R2 = s:N2
    2              0.000002     let s:R3 = s:N3
    2   0.000095   0.000011     let g:airline#themes#base16#palette.replace = airline#themes#generate_color_map(s:R1, s:R2, s:R3)
    2              0.000007     let g:airline#themes#base16#palette.replace_modified = g:airline#themes#base16#palette.normal_modified
                            
    2   0.000172   0.000014     let s:V1 = airline#themes#get_highlight2(['DiffText', 'bg'], ['Constant', 'fg'], 'bold')
    2   0.000168   0.000013     let s:V2 = airline#themes#get_highlight2(['Constant', 'fg'], ['Normal', 'bg'])
    2              0.000003     let s:V3 = s:N3
    2   0.000096   0.000011     let g:airline#themes#base16#palette.visual = airline#themes#generate_color_map(s:V1, s:V2, s:V3)
    2              0.000006     let g:airline#themes#base16#palette.visual_modified = g:airline#themes#base16#palette.normal_modified
                            
                                " Use VertSplit's bg and default fg (reversed) for inactive statusline.
    2   0.000190   0.000013     let s:VS = airline#themes#get_highlight('VertSplit')
    2              0.000010     let s:IA = [ s:VS[1], 'NONE', s:VS[2], 'NONE', 'reverse']
    2   0.000104   0.000014     let g:airline#themes#base16#palette.inactive = airline#themes#generate_color_map(s:IA, s:IA, s:IA, s:IA, s:IA, s:IA)
    2              0.000010     let s:IM = [ s:VS[1], 'NONE', s:VS[2], 'NONE', 'reverse,italic']
    2   0.000093   0.000012     let g:airline#themes#base16#palette.inactive_modified = airline#themes#generate_color_map(s:IM, s:IM, s:IM, s:IM, s:IM, s:IM)
                            
                                " Warnings
    2   0.000195   0.000016     let s:WI = airline#themes#get_highlight2(['WarningMsg', 'bg'], ['WarningMsg', 'fg'], 'bold')
    2              0.000012     let g:airline#themes#base16#palette.normal.airline_warning = [ s:WI[0], s:WI[1], s:WI[2], s:WI[3] ]
                            
    2              0.000007     let g:airline#themes#base16#palette.normal_modified.airline_warning = g:airline#themes#base16#palette.normal.airline_warning
                            
    2              0.000006     let g:airline#themes#base16#palette.insert.airline_warning = g:airline#themes#base16#palette.normal.airline_warning
                            
    2              0.000005     let g:airline#themes#base16#palette.insert_modified.airline_warning = g:airline#themes#base16#palette.normal.airline_warning
                            
    2              0.000006     let g:airline#themes#base16#palette.visual.airline_warning = g:airline#themes#base16#palette.normal.airline_warning
                            
    2              0.000006     let g:airline#themes#base16#palette.visual_modified.airline_warning = g:airline#themes#base16#palette.normal.airline_warning
                            
    2              0.000006     let g:airline#themes#base16#palette.replace.airline_warning = g:airline#themes#base16#palette.normal.airline_warning
                            
    2              0.000006     let g:airline#themes#base16#palette.replace_modified.airline_warning = g:airline#themes#base16#palette.normal.airline_warning
                            
                                " Errors
    2   0.000172   0.000013     let s:ER = airline#themes#get_highlight2(['ErrorMsg', 'bg'], ['ErrorMsg', 'fg'], 'bold')
    2              0.000011     let g:airline#themes#base16#palette.normal.airline_error = [ s:ER[0], s:ER[1], s:ER[2], s:ER[3] ]
                            
    2              0.000006     let g:airline#themes#base16#palette.normal_modified.airline_error = g:airline#themes#base16#palette.normal.airline_error
                            
    2              0.000006     let g:airline#themes#base16#palette.insert.airline_error = g:airline#themes#base16#palette.normal.airline_error
                            
    2              0.000006     let g:airline#themes#base16#palette.insert_modified.airline_error = g:airline#themes#base16#palette.normal.airline_error
                            
    2              0.000006     let g:airline#themes#base16#palette.visual.airline_error = g:airline#themes#base16#palette.normal.airline_error
                            
    2              0.000005     let g:airline#themes#base16#palette.visual_modified.airline_error = g:airline#themes#base16#palette.normal.airline_error
                            
    2              0.000004     let g:airline#themes#base16#palette.replace.airline_error = g:airline#themes#base16#palette.normal.airline_error
                            
    2              0.000004     let g:airline#themes#base16#palette.replace_modified.airline_error = g:airline#themes#base16#palette.normal.airline_error
                            

FUNCTION  <SNR>54_exec_separator()
Called 18 times
Total time:   0.008273
 Self time:   0.000772

count  total (s)   self (s)
   18              0.000033   if pumvisible()
                                return
                              endif
   18   0.001942   0.000110   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   18   0.001821   0.000106   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   18              0.000072   let group = a:from.'_to_'.a:to.a:suffix
   18              0.000021   if a:inverse
    6              0.000031     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
    6              0.000003   else
   12              0.000063     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   12              0.000010   endif
   18              0.000052   let a:dict[group] = colors
   18   0.004092   0.000138   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>58_should_change_group()
Called 12 times
Total time:   0.002425
 Self time:   0.000322

count  total (s)   self (s)
   12              0.000033   if a:group1 == a:group2
                                return 0
                              endif
   12   0.001180   0.000070   let color1 = airline#highlighter#get_highlight(a:group1)
   12   0.001059   0.000066   let color2 = airline#highlighter#get_highlight(a:group2)
   12              0.000024   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   12              0.000045     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#extensions#netrw#init()
Called 1 time
Total time:   0.000033
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004   let g:netrw_force_overwrite_statusline = 0
    1   0.000029   0.000005   call a:ext.add_statusline_func('airline#extensions#netrw#apply')

FUNCTION  airline#init#gui_mode()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000014   return ((has('nvim') && exists('$NVIM_TUI_ENABLE_TRUE_COLOR') && !exists("+termguicolors")) || has('gui_running') || (has("termtruecolor") && &guicolors == 1) || (has("termguicolors") && &termguicolors == 1)) ? 'gui' : 'cterm'

FUNCTION  90()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007     let newObj = copy(self)
    1              0.000001     return newObj

FUNCTION  91()
Called 2 times
Total time:   0.000043
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000043   0.000016     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  92()
Called 1 time
Total time:   0.000218
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000013   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    1   0.000015   0.000006     let old_signs = copy(self._bufSignIds())
    1   0.000020   0.000002     if self.enabled()
    1              0.000001         if !s:setup_done
    1   0.000088   0.000005             call self._setup()
    1              0.000002             let s:setup_done = 1
    1              0.000002             lockvar s:setup_done
    1              0.000001         endif
                            
    1   0.000054   0.000006         call self._signErrors(a:loclist)
    1              0.000001     endif
    1   0.000019   0.000006     call self._removeSigns(old_signs)

FUNCTION  93()
Called 1 time
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000003     if has('signs')
    1              0.000005         if !hlexists('SyntasticErrorSign')
    1              0.000004             highlight link SyntasticErrorSign error
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticWarningSign')
    1              0.000003             highlight link SyntasticWarningSign todo
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleErrorSign')
    1              0.000003             highlight link SyntasticStyleErrorSign SyntasticErrorSign
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleWarningSign')
    1              0.000003             highlight link SyntasticStyleWarningSign SyntasticWarningSign
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleErrorLine')
    1              0.000004             highlight link SyntasticStyleErrorLine SyntasticErrorLine
    1              0.000000         endif
    1              0.000002         if !hlexists('SyntasticStyleWarningLine')
    1              0.000003             highlight link SyntasticStyleWarningLine SyntasticWarningLine
    1              0.000000         endif
                            
                                    " define the signs used to display syntax and style errors/warns
    1              0.000011         execute 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
    1              0.000007         execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
    1              0.000006         execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
    1              0.000006         execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
    1              0.000001     endif

FUNCTION  94()
Called 1 time
Total time:   0.000048
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000002     let loclist = a:loclist
    1   0.000006   0.000003     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  95()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     if has('signs')
    1              0.000004         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    1              0.000001     endif

FUNCTION  96()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004     if !exists('b:syntastic_private_sign_ids')
    1              0.000002         let b:syntastic_private_sign_ids = []
    1              0.000001     endif
    1              0.000002     return b:syntastic_private_sign_ids

FUNCTION  97()
Called 4 times
Total time:   0.000127
 Self time:   0.000030

count  total (s)   self (s)
    4   0.000127   0.000030   call airline#add_statusline_func(a:name)

FUNCTION  airline#extensions#netrw#apply()
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000010   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#define_function()
Called 8 times
Total time:   0.000177
 Self time:   0.000050

count  total (s)   self (s)
    8   0.000174   0.000047   call airline#parts#define(a:key, { 'function': a:name })

FUNCTION  <SNR>53_wrap_accent()
Called 27 times
Total time:   0.000604
 Self time:   0.000357

count  total (s)   self (s)
   27              0.000069   if exists('a:part.accent')
    4   0.000381   0.000134     call airline#highlighter#add_accent(a:part.accent)
    4              0.000017     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
   23              0.000028   return a:value

FUNCTION  airline#switch_theme()
Called 1 time
Total time:   0.035834
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000001   try
    1              0.000004     let palette = g:airline#themes#{a:name}#palette "also lazy loads the theme
    1              0.000002     let g:airline_theme = a:name
    1              0.000001   catch
                                echohl WarningMsg | echo 'The specified theme cannot be found.' | echohl NONE
                                if exists('g:airline_theme')
                                  return
                                else
                                  let g:airline_theme = 'dark'
                                endif
                              endtry
                            
    1              0.000002   let w:airline_lastmode = ''
    1   0.027125   0.000014   call airline#load_theme()
                            
                              " this is required to prevent clobbering the startup info message, i don't know why...
    1   0.008686   0.000011   call airline#check_mode(winnr())

FUNCTION  pathogen#uniq()
Called 1 time
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
    1              0.000002   let i = 0
    1              0.000002   let seen = {}
   11              0.000022   while i < len(a:list)
   10              0.000044     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
                                  call remove(a:list,i)
                                elseif a:list[i] ==# ''
                                  let i += 1
                                  let empty = 1
                                else
   10              0.000029       let seen[a:list[i]] = 1
   10              0.000011       let i += 1
   10              0.000009     endif
   10              0.000001   endwhile
    1              0.000001   return a:list

FUNCTION  airline#extensions#whitespace#init()
Called 1 time
Total time:   0.000111
 Self time:   0.000086

count  total (s)   self (s)
    1   0.000032   0.000007   call airline#parts#define_function('whitespace', 'airline#extensions#whitespace#check')
                            
    1              0.000003   unlet! b:airline_whitespace_check
    1              0.000001   augroup airline_whitespace
    1              0.000064     autocmd!
    1              0.000009     autocmd CursorHold,BufWritePost * call <sid>ws_refresh()
    1              0.000001   augroup END

FUNCTION  <SNR>25_invoke_funcrefs()
Called 2 times
Total time:   0.016239
 Self time:   0.000268

count  total (s)   self (s)
    2   0.000485   0.000178   let builder = airline#builder#new(a:context)
    2   0.003005   0.000022   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    2              0.000003   if err == 1
    2   0.012704   0.000023     let a:context.line = builder.build()
    2              0.000010     let s:contexts[a:context.winnr] = a:context
    2              0.000028     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    2              0.000002   endif

FUNCTION  airline#themes#generate_color_map()
Called 12 times
Total time:   0.000517
 Self time:   0.000517

count  total (s)   self (s)
   12              0.000198   let palette = { 'airline_a': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , get(a:sect1 , 4 , '') ] , 'airline_b': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , get(a:sect2 , 4 , '') ] , 'airline_c': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , get(a:sect3 , 4 , '') ] , }
                            
   12              0.000014   if a:0 > 0
    4              0.000067     call extend(palette, { 'airline_x': [ a:1[0] , a:1[1] , a:1[2] , a:1[3] , get(a:1 , 4 , '' ) ] , 'airline_y': [ a:2[0] , a:2[1] , a:2[2] , a:2[3] , get(a:2 , 4 , '' ) ] , 'airline_z': [ a:3[0] , a:3[1] , a:3[2] , a:3[3] , get(a:3 , 4 , '' ) ] , })
    4              0.000003   else
    8              0.000111     call extend(palette, { 'airline_x': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , '' ] , 'airline_y': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , '' ] , 'airline_z': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , '' ] , })
    8              0.000008   endif
                            
   12              0.000013   return palette

FUNCTION  <SNR>22_BufEnterHook()
Called 1 time
Total time:   0.001433
 Self time:   0.000182

count  total (s)   self (s)
    1   0.000501   0.000149     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))) . ', &buftype = ' . string(&buftype))
    1              0.000002     if &buftype ==# ''
    1   0.000912   0.000013         call s:notifiers.refresh(g:SyntasticLoclist.current())
    1              0.000001     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
                                    let owner = str2nr(getbufvar(bufnr(''), 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  airline#highlighter#add_accent()
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000012   let s:accents[a:accent] = 1

FUNCTION  airline#themes#get_highlight2()
Called 18 times
Total time:   0.001492
 Self time:   0.000149

count  total (s)   self (s)
   18   0.001481   0.000138   return call('airline#highlighter#get_highlight2', [a:fg, a:bg] + a:000)

FUNCTION  <SNR>58_section_is_empty()
Called 26 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
   26              0.000042   let start=1
                            
                              " do not check for inactive windows
   26              0.000044   if a:self._context.active == 0
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   26              0.000078   if get(g:, 'airline_skip_empty_sections', 0) == 0
   26              0.000042     return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  29()
Called 1 time
Total time:   0.000037
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000025   0.000007     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  airline#highlighter#highlight()
Called 3 times
Total time:   0.019938
 Self time:   0.003286

count  total (s)   self (s)
    3              0.000013   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    3              0.000023   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    3              0.000010   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    6              0.000009   for mode in mapped
    3              0.000018     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    3              0.000010       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   27              0.000056       for kvp in items(dict)
   24              0.000059         let mode_colors = kvp[1]
   24   0.004819   0.000185         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
   72              0.000144         for accent in keys(s:accents)
   48              0.000128           if !has_key(p.accents, accent)
                                        continue
                                      endif
   48              0.000197           let colors = copy(mode_colors)
   48              0.000152           if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
                                      endif
   48              0.000116           if p.accents[accent][2] != ''
   24              0.000074             let colors[2] = p.accents[accent][2]
   24              0.000019           endif
   48              0.000082           if len(colors) >= 5
   48              0.000187             let colors[4] = get(p.accents[accent], 4, '')
   48              0.000042           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
   48   0.009799   0.000391           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
   48              0.000053         endfor
   24              0.000020       endfor
                            
                                  " TODO: optimize this
    9              0.000020       for sep in items(s:separators)
    6   0.002682   0.000072         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
    6              0.000006       endfor
    3              0.000001     endif
    3              0.000001   endfor

FUNCTION  <SNR>58_get_seperator()
Called 12 times
Total time:   0.007625
 Self time:   0.000215

count  total (s)   self (s)
   12   0.002536   0.000111   if s:should_change_group(a:prev_group, a:group)
   10   0.005063   0.000078     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
    2              0.000005     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>54_Get()
Called 721 times
Total time:   0.005227
 Self time:   0.005227

count  total (s)   self (s)
  721              0.002508   if get(a:dict, a:key, a:default) isnot# a:default
  355              0.001003     return a:prefix. get(a:dict, a:key)
                              else
  366              0.000307     return ''
                              endif

FUNCTION  <SNR>48_toggle_on()
Called 1 time
Total time:   0.001571
 Self time:   0.000547

count  total (s)   self (s)
    1   0.000321   0.000121   call airline#extensions#tabline#autoshow#on()
    1   0.000342   0.000121   call airline#extensions#tabline#tabs#on()
    1   0.000460   0.000122   call airline#extensions#tabline#buffers#on()
    1   0.000441   0.000176   call airline#extensions#tabline#ctrlspace#on()
                            
    1              0.000004   set tabline=%!airline#extensions#tabline#get()

FUNCTION  airline#themes#patch()
Called 1 time
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
   12              0.000019   for mode in keys(a:palette)
   11              0.000032     if !has_key(a:palette[mode], 'airline_warning')
    3              0.000013       let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
    3              0.000002     endif
   11              0.000029     if !has_key(a:palette[mode], 'airline_error')
    3              0.000012       let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
    3              0.000001     endif
   11              0.000004   endfor
                            
    1              0.000004   let a:palette.accents = get(a:palette, 'accents', {})
    1              0.000003   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    1              0.000003   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    1              0.000003   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    1              0.000002   if !has_key(a:palette.accents, 'green')
    1              0.000003     let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
    1              0.000001   endif
    1              0.000002   if !has_key(a:palette.accents, 'blue')
    1              0.000003     let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
    1              0.000001   endif
    1              0.000002   if !has_key(a:palette.accents, 'yellow')
    1              0.000003     let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
    1              0.000001   endif
    1              0.000002   if !has_key(a:palette.accents, 'orange')
    1              0.000006     let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
    1              0.000001   endif
    1              0.000002   if !has_key(a:palette.accents, 'purple')
    1              0.000003     let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
    1              0.000001   endif

FUNCTION  airline#extensions#wordcount#init()
Called 1 time
Total time:   0.000059
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000033   0.000005   call a:ext.add_statusline_func('airline#extensions#wordcount#apply')
    1              0.000025   autocmd BufReadPost,CursorMoved,CursorMovedI * call s:update()

FUNCTION  airline#extensions#apply()
Called 2 times
Total time:   0.000217
 Self time:   0.000112

count  total (s)   self (s)
    2              0.000006   let s:active_winnr = winnr()
                            
    2   0.000123   0.000018   if s:is_excluded_window()
                                return -1
                              endif
                            
    2              0.000003   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    2              0.000002   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    2              0.000008   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    2              0.000006   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  104()
Called 8 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    8              0.000033   call add(self._sections, ['', a:text])

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 1 time
Total time:   0.000241
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000004   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
    1              0.000009     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    1              0.000001   endif
                            
    1              0.000002   if !empty(colors)
    1   0.000218   0.000008     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    1              0.000000   endif

FUNCTION  <SNR>24_on_window_changed()
Called 2 times
Total time:   0.054408
 Self time:   0.000134

count  total (s)   self (s)
    2              0.000010   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    2              0.000016   let l:key = [bufnr('%'), winnr(), winnr('$')]
    2              0.000016   if get(t:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')'
    1              0.000001     return
                              endif
    1              0.000003   let t:airline_last_window_changed = l:key
    1   0.047406   0.000069   call s:init()
    1   0.006943   0.000006   call airline#update_statusline()

FUNCTION  78()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000004     if !exists('s:SyntasticRegistryInstance')
    1              0.000007         let s:SyntasticRegistryInstance = copy(self)
    1              0.000003         let s:SyntasticRegistryInstance._checkerMap = {}
    1              0.000000     endif
                            
    1              0.000002     return s:SyntasticRegistryInstance

FUNCTION  airline#extensions#tabline#ctrlspace#on()
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000002   augroup airline_tabline_ctrlspace
    1              0.000033     autocmd!
    1              0.000005     autocmd BufDelete * call airline#extensions#tabline#ctrlspace#invalidate()
    1              0.000001   augroup END

FUNCTION  syntastic#util#stamp()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000018     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  airline#extensions#syntastic#init()
Called 1 time
Total time:   0.000034
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000032   0.000006   call airline#parts#define_function('syntastic', 'airline#extensions#syntastic#get_warnings')

FUNCTION  airline#extensions#tabline#buffers#on()
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000002   augroup airline_tabline_buffers
    1              0.000033     autocmd!
    1              0.000005     autocmd BufDelete * call airline#extensions#tabline#buffers#invalidate()
    1              0.000011     autocmd User BufMRUChange call airline#extensions#tabline#buflist#invalidate()
    1              0.000003     autocmd User BufMRUChange call airline#extensions#tabline#buffers#invalidate()
    1              0.000001   augroup END

FUNCTION  100()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   call add(self._theme_funcrefs, function(a:name))

FUNCTION  101()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000010   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  airline#highlighter#load_theme()
Called 1 time
Total time:   0.011661
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000002   if pumvisible()
                                return
                              endif
    1              0.000010   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
    1   0.005786   0.000015   call airline#highlighter#highlight(['inactive'])
    1   0.005856   0.000008   call airline#highlighter#highlight(['normal'])

FUNCTION  103()
Called 16 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   16              0.000076   call add(self._sections, [a:group, a:contents])

FUNCTION  airline#highlighter#add_separator()
Called 12 times
Total time:   0.005903
 Self time:   0.000240

count  total (s)   self (s)
   12              0.000082   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   12   0.005813   0.000150   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  syntastic#util#var()
Called 9 times
Total time:   0.000126
 Self time:   0.000075

count  total (s)   self (s)
    9   0.000124   0.000073     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  <SNR>41_is_excluded_window()
Called 2 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    2              0.000005   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
    8              0.000010   for matchw in g:airline_exclude_filenames
    6              0.000042     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
    6              0.000004   endfor
                            
    2              0.000002   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    2              0.000002   return 0

FUNCTION  pathogen#slash()
Called 12 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
   12              0.000037   return !exists("+shellslash") || &shellslash ? '/' : '\'

FUNCTION  airline#extensions#po#apply()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000006   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  <SNR>58_get_transitioned_seperator()
Called 12 times
Total time:   0.006223
 Self time:   0.000320

count  total (s)   self (s)
   12              0.000022   let line = ''
   12   0.006003   0.000100   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   12              0.000069   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   12              0.000053   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   12              0.000041   let line .= '%#'.a:group.'#'
   12              0.000018   return line

FUNCTION  airline#init#bootstrap()
Called 3 times
Total time:   0.001139
 Self time:   0.000345

count  total (s)   self (s)
    3              0.000006   if s:loaded
    2              0.000002     return
                              endif
    1              0.000002   let s:loaded = 1
                            
    1              0.000002   let g:airline#init#bootstrapping = 1
    1   0.000022   0.000013   call s:check_defined('g:airline_left_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b0":">")
    1   0.000015   0.000007   call s:check_defined('g:airline_left_alt_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b1":">")
    1   0.000014   0.000006   call s:check_defined('g:airline_right_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b2":"<")
    1   0.000014   0.000006   call s:check_defined('g:airline_right_alt_sep', get(g:, 'airline_powerline_fonts', 0)?"\ue0b3":"<")
    1   0.000012   0.000005   call s:check_defined('g:airline_detect_modified', 1)
    1   0.000011   0.000003   call s:check_defined('g:airline_detect_paste', 1)
    1   0.000011   0.000004   call s:check_defined('g:airline_detect_crypt', 1)
    1   0.000010   0.000003   call s:check_defined('g:airline_detect_spell', 1)
    1   0.000011   0.000004   call s:check_defined('g:airline_detect_iminsert', 0)
    1   0.000011   0.000003   call s:check_defined('g:airline_inactive_collapse', 1)
    1   0.000013   0.000005   call s:check_defined('g:airline_exclude_filenames', ['DebuggerWatch','DebuggerStack','DebuggerStatus'])
    1   0.000012   0.000005   call s:check_defined('g:airline_exclude_filetypes', [])
    1   0.000011   0.000004   call s:check_defined('g:airline_exclude_preview', 0)
    1   0.000032   0.000010   call s:check_defined('g:airline_gui_mode', airline#init#gui_mode())
                            
    1   0.000012   0.000005   call s:check_defined('g:airline_mode_map', {})
    1              0.000019   call extend(g:airline_mode_map, { '__' : '------', 'n'  : 'NORMAL', 'i'  : 'INSERT', 'R'  : 'REPLACE', 'v'  : 'VISUAL', 'V'  : 'V-LINE', 'c'  : 'COMMAND', '' : 'V-BLOCK', 's'  : 'SELECT', 'S'  : 'S-LINE', '' : 'S-BLOCK', 't'  : 'TERMINAL', }, 'keep')
                            
    1   0.000012   0.000005   call s:check_defined('g:airline_theme_map', {})
    1              0.000011   call extend(g:airline_theme_map, { '\CTomorrow': 'tomorrow', 'base16': 'base16', 'mo[l|n]okai': 'molokai', 'wombat': 'wombat', 'zenburn': 'zenburn', 'solarized': 'solarized', }, 'keep')
                            
    1   0.000010   0.000005   call s:check_defined('g:airline_symbols', {})
    1              0.000026   call extend(g:airline_symbols, { 'paste': 'PASTE', 'spell': 'SPELL', 'readonly': get(g:, 'airline_powerline_fonts', 0) ? "\ue0a2" : 'RO', 'whitespace': get(g:, 'airline_powerline_fonts', 0) ? "\u2739" : '!', 'linenr': get(g:, 'airline_powerline_fonts', 0) ? "\ue0a1" : ':', 'maxlinenr': get(g:, 'airline_powerline_fonts', 0) ? "\u2630" : '', 'branch': get(g:, 'airline_powerline_fonts', 0) ? "\ue0a0" : '', 'notexists': "\u2204", 'modified': '+', 'space': ' ', 'crypt': get(g:, 'airline_crypt_symbol', nr2char(0x1F512)), }, 'keep')
                            
    1   0.000239   0.000086   call airline#parts#define('mode', { 'function': 'airline#parts#mode', 'accent': 'bold', })
    1   0.000031   0.000009   call airline#parts#define_function('iminsert', 'airline#parts#iminsert')
    1   0.000025   0.000004   call airline#parts#define_function('paste', 'airline#parts#paste')
    1   0.000024   0.000004   call airline#parts#define_function('crypt', 'airline#parts#crypt')
    1   0.000024   0.000004   call airline#parts#define_function('spell', 'airline#parts#spell')
    1   0.000027   0.000004   call airline#parts#define_function('filetype', 'airline#parts#filetype')
    1   0.000020   0.000006   call airline#parts#define('readonly', { 'function': 'airline#parts#readonly', 'accent': 'red', })
    1   0.000027   0.000007   call airline#parts#define_raw('file', '%f%m')
    1   0.000023   0.000004   call airline#parts#define_raw('path', '%F%m')
    1   0.000021   0.000006   call airline#parts#define('linenr', { 'raw': '%{g:airline_symbols.linenr}%#__accent_bold#%4l%#__restore__#', 'accent': 'bold'})
    1   0.000021   0.000006   call airline#parts#define('maxlinenr', { 'raw': '%#__accent_bold#/%L%{g:airline_symbols.maxlinenr}%#__restore__#', 'accent': 'bold'})
    1   0.000024   0.000004   call airline#parts#define_function('ffenc', 'airline#parts#ffenc')
    1   0.000285   0.000013   call airline#parts#define_empty(['hunks', 'branch', 'obsession', 'tagbar', 'syntastic', 'eclim', 'whitespace','windowswap', 'ycm_error_count', 'ycm_warning_count'])
    1   0.000028   0.000008   call airline#parts#define_text('capslock', '')
                            
    1              0.000002   unlet g:airline#init#bootstrapping

FUNCTION  pathogen#infect()
Called 1 time
Total time:   0.001857
 Self time:   0.000104

count  total (s)   self (s)
    2              0.000009   for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
    1              0.000019     if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
                                  call pathogen#surround(path)
                                elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#surround(path . '/{}')
                                elseif path =~# '[{}*]'
    1   0.001719   0.000010       call pathogen#interpose(path)
    1              0.000000     else
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#interpose(path . '/{}')
                                endif
    1              0.000000   endfor
    1   0.000013   0.000007   call pathogen#cycle_filetype()
    1   0.000042   0.000004   if pathogen#is_disabled($MYVIMRC)
                                return 'finish'
                              endif
    1              0.000001   return ''

FUNCTION  pathogen#join()
Called 1 time
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
    1              0.000003   if type(a:1) == type(1) && a:1
                                let i = 1
                                let space = ' '
                              else
    1              0.000002     let i = 0
    1              0.000001     let space = ''
    1              0.000001   endif
    1              0.000001   let path = ""
    2              0.000003   while i < a:0
    1              0.000004     if type(a:000[i]) == type([])
    1              0.000002       let list = a:000[i]
    1              0.000002       let j = 0
   11              0.000020       while j < len(list)
   10              0.000111         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
   10              0.000031         let path .= ',' . escaped
   10              0.000013         let j += 1
   10              0.000005       endwhile
    1              0.000001     else
                                  let path .= "," . a:000[i]
                                endif
    1              0.000001     let i += 1
    1              0.000001   endwhile
    1              0.000007   return substitute(path,'^,','','')

FUNCTION  27()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     let newObj = copy(self)
    1              0.000001     return newObj

FUNCTION  28()
Called 2 times
Total time:   0.000033
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000032   0.000008     return syntastic#util#var('echo_current_error')

FUNCTION  airline#builder#new()
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000011   let builder = copy(s:prototype)
    2              0.000006   let builder._context = a:context
    2              0.000004   let builder._sections = []
                            
    2              0.000023   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    2              0.000003   return builder

FUNCTION  syntastic#util#isRunningWindows()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000008     return has('win16') || has('win32') || has('win64')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.054408   0.000134  <SNR>24_on_window_changed()
    1   0.047337   0.000379  <SNR>24_init()
    1   0.035834   0.000048  airline#switch_theme()
    1   0.027111   0.000087  airline#load_theme()
    1   0.025406   0.000548  syntastic#util#system()
  103   0.021699   0.006475  airline#highlighter#exec()
    3   0.019938   0.003286  airline#highlighter#highlight()
    2   0.016480   0.000232  airline#update_statusline()
    2   0.016239   0.000268  <SNR>25_invoke_funcrefs()
  171   0.016018   0.005071  airline#highlighter#get_highlight()
    2   0.012681   0.002007  105()
    1   0.011661   0.000042  airline#highlighter#load_theme()
  378   0.010051             <SNR>54_get_syn()
    1   0.008675   0.000115  airline#check_mode()
   18   0.008273   0.000772  <SNR>54_exec_separator()
   12   0.007625   0.000215  <SNR>58_get_seperator()
    3   0.006714   0.000382  airline#util#exec_funcrefs()
   12   0.006223   0.000320  <SNR>58_get_transitioned_seperator()
   12   0.005903   0.000240  airline#highlighter#add_separator()
    1   0.005737   0.002873  airline#extensions#load()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  378              0.010051  <SNR>54_get_syn()
  103   0.021699   0.006475  airline#highlighter#exec()
  721              0.005227  <SNR>54_Get()
  171   0.016018   0.005071  airline#highlighter#get_highlight()
    3   0.019938   0.003286  airline#highlighter#highlight()
    1   0.005737   0.002873  airline#extensions#load()
    2   0.012681   0.002007  105()
  189              0.001940  <SNR>54_get_array()
    9   0.002465   0.001777  <SNR>53_create()
   16              0.001056  <SNR>58_get_accented_line()
   22   0.000938   0.000841  <SNR>59_get_section()
   18   0.008273   0.000772  <SNR>54_exec_separator()
    5   0.000785   0.000768  pathogen#expand()
    2   0.003456   0.000570  airline#themes#base16#refresh()
   16   0.001529   0.000560  <SNR>59_add_section()
    1   0.025406   0.000548  syntastic#util#system()
    1   0.001571   0.000547  <SNR>48_toggle_on()
   12              0.000517  airline#themes#generate_color_map()
   26              0.000437  <SNR>58_get_prev_group()
   44   0.004319   0.000401  airline#themes#get_highlight()

